{"pages":[{"title":"Categories","date":"2023-11-29T02:08:16.537Z","path":"categories/index.html","text":"分类"},{"title":"About Me","date":"2023-11-29T02:08:16.537Z","path":"about/index.html","text":"1. Me Im a robotics perception beginner, my online virtual name is silencht. 2. Social Media email: &lt;silencht[at]qq[dot]com&gt; （Recommended） qq: &lt;MTE2MjMzMzQ1NQ==&gt; (you can decode on this url) wechat: &lt;c2lsZW5jaHQ=&gt; (you can decode on this url) 3. Degrees Master, Electronic and Information Engineering, Yanshan University Bachelor, Communication Engineering, Chongqing University of Technology 4. Interests Simultaneous Localization and Mapping (SLAM) Robotics, Perception Embedded System AI (a little, may be) 5. Work during the master's degree 5.1 Master's Thesis 5.2 Journal Paper wait to complete..."},{"title":"Tags","date":"2023-11-29T02:08:16.657Z","path":"tags/index.html","text":"标签"}],"posts":[{"title":"kalibr_note","date":"2024-01-05T08:49:39.016Z","path":"wiki/robot/note/kalibr_note/","text":"d435i双目+IMU联合标定 1. build Kalibr from source code install ROS1 on system, for example 12345678910111213141516171819202122sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654sudo apt-get updateexport ROS1_DISTRO=noetic # melodic=18.04, noetic=20.04sudo apt-get install ros-$ROS1_DISTRO-desktop-fullsudo apt-get install python-catkin-tools # ubuntu 18.04sudo apt-get install python3-catkin-tools python3-osrf-pycommon # ubuntu 20.04#酌情根据需要安装依赖项（optional）sudo apt-get install -y \\ git wget autoconf automake nano \\ libeigen3-dev libboost-all-dev libsuitesparse-dev \\ doxygen libopencv-dev \\ libpoco-dev libtbb-dev libblas-dev liblapack-dev libv4l-dev#Then due to different Python versions, you will need to install the following:# Ubuntu 18.04sudo apt-get install -y python3-dev python-pip python-scipy \\ python-matplotlib ipython python-wxgtk4.0 python-tk python-igraph python-pyx# Ubuntu 20.04sudo apt-get install -y python3-dev python3-pip python3-scipy \\ python3-matplotlib ipython3 python3-wxgtk4.0 python3-tk python3-igraph python3-pyx create a catkin workspace and clone the kalibr project 1234567891011mkdir -p ~/kalibr/srccd ~/kalibrexport ROS1_DISTRO=noetic # kinetic=16.04, melodic=18.04, noetic=20.04source /opt/ros/$ROS1_DISTRO/setup.bashcatkin initcatkin config --extend /opt/ros/$ROS1_DISTROcatkin config --merge-devel # Necessary for catkin_tools &gt;= 0.4.catkin config --cmake-args -DCMAKE_BUILD_TYPE=Release#then clone the projectcd ~/kalibr/srcgit clone https://github.com/ethz-asl/kalibr.git build 123cd ~/kalibr#根据需要修改j数值catkin build -DCMAKE_BUILD_TYPE=Release -j14 source the catkin workspace setup to use Kalibr，至此Kalibr安装完成 12source ~/kalibr/devel/setup.bashrosrun kalibr &lt;command_you_want_to_run_here&gt; 安装code_utils &amp; imu_utils 工具用于后面标定IMU 12345678910111213141516171819202122232425262728293031#先安装ceres# google-glog + gflagssudo apt-get install libgoogle-glog-dev libgflags-dev# now ready to build, test, and install Ceres.# download ceres-solver-2.2.0 from https://github.com/ceres-solver/ceres-solver/archive/refs/tags/2.2.0.tar.gztar zxf ceres-solver-2.2.0.tar.gzmkdir ceres-bincd ceres-bincmake ../ceres-solver-2.2.0make -j14make test# Optionally install Ceres, it can also be exported using CMake which# allows Ceres to be used without requiring installation, see the documentation# for the EXPORT_BUILD_DIR option for more information.sudo make install#安装code utilssudo apt install libdw-devmkdir -p ~/imu_calib/srccd ~/imu_calib/srccatkin_init_workspacegit clone https://github.com/silencht/code_utils.git#仓库文件已经将sumpixel_test.cpp中#include &quot;backward.hpp&quot;改为：#include &quot;code_utils/backward.hpp&quot;#如果下方步骤编译出错，可酌情再次修改为#include &quot;backward.hpp&quot;catkin_make -j14#安装imu utilscd ~/imu_calib/src/git clone https://github.com/silencht/imu_utils.gitcd ..catkin_make -j14 为d435i相机安装realsense ros1驱动包 12345678910111213141516#https://github.com/IntelRealSense/realsense-ros/tree/ros1-legacy#create a catkin workspace for realsense rosmkdir -p ~/d435i_ros/srccd ~/d435i_ros/srcgit clone https://github.com/silencht/realsense-ros.gitcd realsense-ros/git checkout `git tag | sort -V | grep -P &quot;^2.\\d+\\.\\d+&quot; | tail -1`cd ..catkin_init_workspacecd ..catkin_make cleancatkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Releasecatkin_make install#运行和测试查看roslaunch realsense2_camera rs_camera.launchrviz 2. IMU标定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#rs_camera_for_calib.launch主要相对于rs_camera.launch修改了# &lt;arg name=&quot;infra_width&quot; default=&quot;640&quot;/&gt; 此行作用：将红外图像分辨率由848*480变为640*480# &lt;arg name=&quot;gyro_fps&quot; default=&quot;400&quot;/&gt;# &lt;arg name=&quot;accel_fps&quot; default=&quot;250&quot;/&gt;# &lt;arg name=&quot;enable_gyro&quot; default=&quot;true&quot;/&gt;# &lt;arg name=&quot;enable_accel&quot; default=&quot;true&quot;/&gt;# &lt;arg name=&quot;unite_imu_method&quot; default=&quot;linear_interpolation&quot;/&gt;#启动相机驱动程序，开始发布数据roslaunch realsense2_camera rs_camera_for_calib.launch#此时相机开始输出数据，其中有imu数据，可使用如下命令查看数据是否正常发布changhe@changhe:~/d435i_ros$ rostopic list -v | grep imu * /camera/imu [sensor_msgs/Imu] 1 publisher * /camera/gyro/imu_info [realsense2_camera/IMUInfo] 1 publisher * /camera/accel/imu_info [realsense2_camera/IMUInfo] 1 publisherchanghe@changhe:~/d435i_ros$ rostopic echo /camera/imuheader: seq: 10135 stamp: secs: 1704355811 nsecs: 680399179 frame_id: &quot;camera_imu_optical_frame&quot;orientation: x: 0.0 y: 0.0 z: 0.0 w: 0.0orientation_covariance: [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]angular_velocity: x: -0.001745329238474369 y: 0.001745329238474369 z: 0.0angular_velocity_covariance: [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]linear_acceleration: x: -0.00493930911018656 y: -9.846020630401458 z: 0.019613299518823624linear_acceleration_covariance: [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]#静置相机，录制2小时以上的ROS bag，2小时以后使用ctrl+c终止命令，imu_calib目录下产生imu_calibration.bag文件#或者也可以跳过该步骤，直接使用静置相机的话题发布数据，不记录ROS bagcd ~/imu_calibrosbag record -O imu_calibration /camera/imu#运行IMU校准程序，如果认为2小时太长，可以在d435i_imu_calibration.launch中max_time_min设置value调整计时分钟source ~/imu_calib/devel/setup.bashroslaunch imu_utils d435i_imu_calibration.launch#执行上述命令后，输出以下信息，便可等待程序执行完成（2小时以后）[ INFO] [1704356481.837577493]: Loaded imu_topic: /camera/imu[ INFO] [1704356481.838011572]: Loaded imu_name: d435i[ INFO] [1704356481.838159386]: Loaded data_save_path: /home/changhe/imu_calib/src/imu_utils/data/[ INFO] [1704356481.838308947]: Loaded max_time_min: 120[ INFO] [1704356481.838460625]: Loaded max_cluster: 400gyr x num of Cluster 400gyr y num of Cluster 400gyr z num of Cluster 400acc x num of Cluster 400acc y num of Cluster 400acc z num of Cluster 400wait for imu data.#打开ROS bag数据包进行回放，如果使用相机的直出发布数据则忽略该步骤rosbag play -r 400 imu_calibration.bag#标定结束后，标定结果位于imu_utils/data目录下的d435i_imu_param.yaml文件内,终端输出示例：wait for imu data.gyr x numData 2878675gyr x start_t 1.70436e+09gyr x end_t 1.70436e+09gyr x dt -------------7200.01 s-------------120 min-------------2 hgyr x freq 399.816gyr x period 0.00250115gyr y numData 2878675gyr y start_t 1.70436e+09gyr y end_t 1.70436e+09gyr y dt -------------7200.01 s-------------120 min-------------2 hgyr y freq 399.816gyr y period 0.00250115gyr z numData 2878675gyr z start_t 1.70436e+09gyr z end_t 1.70436e+09gyr z dt -------------7200.01 s-------------120 min-------------2 hgyr z freq 399.816gyr z period 0.00250115Gyro X C -2.87589 70.9924 -7.40893 0.642781 -0.00746316 Bias Instability 4.1718e-06 rad/s Bias Instability 2.14632e-05 rad/s, at 361.957 s White Noise 21.8314 rad/s White Noise 0.00606455 rad/s bias -0.15276 degree/s-------------------Gyro y C -2.85711 70.9111 -5.49533 0.648136 -0.0109878 Bias Instability 1.40587e-05 rad/s Bias Instability 1.93153e-05 rad/s, at 609.529 s White Noise 22.6084 rad/s White Noise 0.0062829 rad/s bias 0.0119102 degree/s-------------------Gyro z C -0.975676 27.4672 -4.80227 0.445228 -0.00711166 Bias Instability 1.5707e-06 rad/s Bias Instability 1.59334e-05 rad/s, at 87.0977 s White Noise 7.53363 rad/s White Noise 0.00209385 rad/s bias -0.0410812 degree/s-------------------============================================================================================acc x numData 2878675acc x start_t 1.70436e+09acc x end_t 1.70436e+09acc x dt -------------7200.01 s-------------120 min-------------2 hacc x freq 399.816acc x period 0.00250115acc y numData 2878675acc y start_t 1.70436e+09acc y end_t 1.70436e+09acc y dt -------------7200.01 s-------------120 min-------------2 hacc y freq 399.816acc y period 0.00250115acc z numData 2878675acc z start_t 1.70436e+09acc z end_t 1.70436e+09acc z dt -------------7200.01 s-------------120 min-------------2 hacc z freq 399.816acc z period 0.00250115acc X C -4.98469e-06 0.000757756 3.7721e-05 2.22768e-05 -3.97843e-07 Bias Instability 0.000280485 m/s^2 White Noise 0.0162395 m/s^2-------------------acc y C -2.49845e-07 0.000834302 -1.96216e-05 1.89497e-05 -3.22867e-07 Bias Instability 0.000192201 m/s^2 White Noise 0.0171629 m/s^2-------------------acc z C -2.81212e-06 0.000594583 6.58393e-05 6.43312e-06 -1.03843e-07 Bias Instability 0.000179308 m/s^2 White Noise 0.0128838 m/s^2-------------------[imu_an-1] process has finished cleanlylog file: /home/changhe/.ros/log/965a1072-aad8-11ee-b508-a13a0030ff2c/imu_an-1*.logall processes on machine have died, roslaunch will exitshutting down processing monitor...... shutting down processing monitor completedone#d435i_imu_param.yaml文件内容示例%YAML:1.0---type: IMUname: d435iGyr: unit: &quot; rad/s&quot; avg-axis: gyr_n: 4.8137652096146783e-03 gyr_w: 1.8903981803128362e-05 x-axis: gyr_n: 6.0645500436790623e-03 gyr_w: 2.1463185558878976e-05 y-axis: gyr_n: 6.2828973927536100e-03 gyr_w: 1.9315340333546505e-05 z-axis: gyr_n: 2.0938481924113613e-03 gyr_w: 1.5933419516959604e-05Acc: unit: &quot; m/s^2&quot; avg-axis: acc_n: 1.5428717790802770e-02 acc_w: 2.1733118964279978e-04 x-axis: acc_n: 1.6239510893649358e-02 acc_w: 2.8048486828980107e-04 y-axis: acc_n: 1.7162885741267130e-02 acc_w: 1.9220055801685360e-04 z-axis: acc_n: 1.2883756737491822e-02 acc_w: 1.7930814262174464e-04 3. 双目标定 生成标定板并用A4纸打印 1234567891011121314cd ~/kalibrsource devel/setup.sh#--type apriltag 标定板类型#--nx [NUM_COLS] 列个数#--ny [NUM_ROWS] 行个数#--tsize [TAG_WIDTH_M] 二维码方格长度，单位m#--tspace [TAG_SPACING_PERCENT] 小方格与二维码方格长度比例rosrun kalibr kalibr_create_target_pdf --type apriltag --nx 6 --ny 6 --tsize 0.022 --tspace 0.3#新建april_6x6_A4.yaml文件，内容如下target_type: &#x27;aprilgrid&#x27; #gridtypetagCols: 6 #number of apriltagstagRows: 6 #number of apriltagstagSize: 0.022 #size of apriltag, edge to edge [m]tagSpacing: 0.3 #ratio of space between tags to tagSize 关闭双目结构光发射器，避免图像产生斑点 1234roslaunch realsense2_camera rs_camera_for_calib.launchrvizrosrun rqt_reconfigure rqt_reconfigure#将camera/stereo_module标签页右侧的emitter_enabled设置为Off(0)，即关闭发射器，此时rviz中的双目图像斑点消失 【请忽略该步骤】限制相机帧数（官方推荐4Hz）因为出现 Cameras are not connected through mutual observations, please check the dataset. Maybe adjust the approx. sync. tolerance.报错所以该步骤放弃。 123rosrun topic_tools throttle messages /camera/infra1/image_rect_raw 4.0 /infra_leftrosrun topic_tools throttle messages /camera/infra2/image_rect_raw 4.0 /infra_right#可以通过rostopic hz /infra_left命令或者直接在rviz中检查 录制ROS bag 123456789101112131415161718cd ~/kalibrrosbag record -O multicameras_calibration /camera/infra1/image_rect_raw /camera/infra2/image_rect_raw#官方推荐标定板对着相机动，但是由于标定板是A4纸比较软，所以这里反过来(实际官方视频也是这么做的：https://www.youtube.com/watch?app=desktop&amp;v=puNXsnrYWTY)#运动的方式为：先绕相机的各自三个轴，每个轴旋转三次，然后再沿着相机的三个轴，每个轴平移三次，基本就可以了，运动期间要保证相机基本能一直看到标定板的全部信息。#录制完毕后kalibr目录下生成multicameras_calibration.bag文件#可通过rosbag info multicameras_calibration.bag查看数据包信息,示例如下：changhe@changhe:~/kalibr$ rosbag info multicameras_calibration.bag path: multicameras_calibration.bagversion: 2.0duration: 1:11s (71s)start: Jan 05 2024 09:44:41.37 (1704419081.37)end: Jan 05 2024 09:45:52.49 (1704419152.49)size: 1.6 GBmessages: 4268compression: none [2134/2134 chunks]types: sensor_msgs/Image [060021388200f6f0f447d0fcd9c64743]topics: /camera/infra1/image_rect_raw 2134 msgs : sensor_msgs/Image /camera/infra2/image_rect_raw 2134 msgs : sensor_msgs/Image 使用Kalibr进行双目标定 Reprojection errors should be in a normal range (0.1-0.2 px for a good calibration) 123456789101112131415161718192021cd ~/kalibrsource devel/setup.bash#注：april_6x6_A4.yaml是3.1节生成的#--target：标定板参数信息存放的路径，即我们上面的april_s.yaml的路径#--bag：录制的Camera数据包的路径#--bag-from-to：起始和终止时间，单位是秒。为了避免开始录制和结束录制时的抖动，这里取了第3秒到第65秒之间的信息#--models：相机模型，一般为针孔模型，https://github.com/ethz-asl/kalibr/wiki/supported-models#--topics：影像流发布的话题#--show-extraction：显示检测特征点的过程rosrun kalibr kalibr_calibrate_cameras --target april_6x6_A4.yaml --bag multicameras_calibration.bag --bag-from-to 3 65 --models pinhole-radtan pinhole-radtan --topics /camera/infra1/image_rect_raw /camera/infra2/image_rect_raw --show-extraction#执行成功后，生成三个文件，分别为：1. multicameras_calibration-results-cam.txt2. multicameras_calibration-camchain.yaml3. multicameras_calibration-report-cam.pdf#附：#使用3.3步骤时，会出现双目图像流时间戳不同步问题，所以放弃3.3步骤，以下是相关issues以及可能的解决措施#https://github.com/ethz-asl/kalibr/issues/364#https://github.com/ethz-asl/kalibr/issues/332#命令后添加 --approx-sync 0.04 将时间同步容忍度增加到0.04秒rosrun kalibr kalibr_calibrate_cameras --target april_6x6_A4.yaml --bag multicameras_calibration.bag --bag-from-to 3 65 --models pinhole-radtan pinhole-radtan --topics /camera/infra1/image_rect_raw /camera/infra2/image_rect_raw --show-extraction --approx-sync 0.04 4. 双目&amp;IMU联合标定 新建camchain.yaml文件 123456789101112131415161718192021#根据3.5节得到的multicameras_calibration-camchain.yaml在~/kalibr目录创建camchain.yaml文件#camchain.yaml内容参考如下cam0: camera_model: pinhole intrinsics: [384.57401093793385, 384.77603230830897, 319.36432154640477, 236.5865796387184] distortion_model: radtan distortion_coeffs: [0.000868210041633816, -0.001536564418790415, -0.0008338819079702226, 0.0005407357906101209] rostopic: /camera/infra1/image_rect_raw resolution: [640, 480]cam1: camera_model: pinhole intrinsics: [384.71257117832874, 385.0226535924584, 319.9598090030288, 236.36875214589423] distortion_model: radtan distortion_coeffs: [0.0027736443531086595, -0.004051540794976078, -0.0010880219876272697, 0.0006497706840705447] T_cn_cnm1: - [0.999997213819325, -6.564576770509914e-05, -0.0023596703620665503, -0.05009032712390797] - [6.840714919526547e-05, 0.9999993130009001, 0.0011701786988816156, 4.8368258872807713e-05] - [0.0023595919236960978, -0.0011703368568748496, 0.9999965313127803, -0.0001744522191402009] - [0.0, 0.0, 0.0, 1.0] rostopic: /camera/infra2/image_rect_raw resolution: [640, 480] 新建imu.yaml文件 12345678910111213#根据第2节获得的d435i_imu_param.yaml文件在~/kalibr目录创建imu.yaml文件#d435i_imu_param.yaml文件位于~/imu_calib/src/imu_utils/data/目录下#imu.yaml内容参考如下：#Accelerometersaccelerometer_noise_density: 1.5428717790802770e-02 #Noise density (continuous-time)accelerometer_random_walk: 2.1733118964279978e-04 #Bias random walk#Gyroscopesgyroscope_noise_density: 4.8137652096146783e-03 #Noise density (continuous-time)gyroscope_random_walk: 1.8903981803128362e-05 #Bias random walkrostopic: /camera/imu #the IMU ROS topicupdate_rate: 400.0 #Hz (for discretization of the values above) 录制ROS bag数据 1234567891011121314151617181920212223242526272829303132333435#~/d435i_ros/src/realsense-ros/realsense2_camera/launch/rs_camera_imu_for_calib.launch文件相比rs_camera_for_calib.launch#改动了以下代码，将双目帧率调整至40hz，并打开了同步开关# &lt;arg name=&quot;infra_fps&quot; default=&quot;40&quot;/&gt;# &lt;arg name=&quot;enable_sync&quot; default=&quot;true&quot;/&gt;#启动相机驱动roslaunch realsense2_camera rs_camera_imu_for_calib.launch#打开rviz，订阅双目话题，关闭结构光，仿照3.4节动作录制数据rvizrosrun rqt_reconfigure rqt_reconfigure#将camera/stereo_module标签页右侧的emitter_enabled设置为Off(0)，即关闭发射器，此时rviz中的双目图像斑点消失#开始录制数据包，注意拿起放下相机时的数据应尽可能排除，从而避免相机的抖动/振动cd ~/kalibr/rosbag record -O imu_stereo.bag /camera/infra1/image_rect_raw /camera/infra2/image_rect_raw /camera/imu#录制完成后~/kalibr/目录下产生imu_stereo.bagchanghe@changhe:~/kalibr$ rosbag info imu_stereo.bag path: imu_stereo.bagversion: 2.0duration: 2:02s (122s)start: Jan 05 2024 12:12:07.82 (1704427927.82)end: Jan 05 2024 12:14:10.61 (1704428050.61)size: 2.1 GBmessages: 56462compression: none [2457/2457 chunks]types: sensor_msgs/Image [060021388200f6f0f447d0fcd9c64743] sensor_msgs/Imu [6a62c6daae103f4ff57a132d6f95cec2]topics: /camera/imu 49094 msgs : sensor_msgs/Imu /camera/infra1/image_rect_raw 3684 msgs : sensor_msgs/Image /camera/infra2/image_rect_raw 3684 msgs : sensor_msgs/Image #附：#由于rostopic hz topic_name检查时发现imu频率在125hz，很奇怪，故以下步骤跳过忽略（本文采取双目 40hz，imu 400hz的频率采集）#cameras should run at 20 Hz and IMU at 200 Hz，from https://github.com/ethz-asl/kalibr/wiki/calibrating-the-vi-sensor#检查频率可通过 rostopic hz topic_namerosrun topic_tools throttle messages /camera/infra1/image_rect_raw 20.0 /infra_left &amp; rosrun topic_tools throttle messages /camera/infra2/image_rect_raw 20.0 /infra_right &amp; rosrun topic_tools throttle messages /camera/imu 200.0 /imu 使用Kalibr进行双目+IMU联合标定 123456789source ~/kalibr/devel/setup.bash#使用rosrun kalibr kalibr_calibrate_imu_camera启动标定程序rosrun kalibr kalibr_calibrate_imu_camera --bag imu_stereo.bag --cam camchain.yaml --imu imu.yaml --target april_6x6_A4.yaml --bag-from-to 5 115 --show-extraction#等待一段时间，获得结果，共四个文件1. imu_stereo-camchain-imucam.yaml2. imu_stereo-imu.yaml3. imu_stereo-results-imucam.txt4. imu_stereo-report-imucam.pdf#注：reprojection errors should be in a normal range (0.1-0.2 px for a good calibration) 参考内容 https://blog.csdn.net/qq_38364548/article/details/124917067 http://zhaoxuhui.top/blog/2020/09/09/kalibr-installation-and-use.html http://zhaoxuhui.top/blog/2020/09/29/intel-realsense-D435i-calibration-kalibr.html https://github.com/gaowenliang https://github.com/ethz-asl/kalibr/wiki/calibrating-the-vi-sensor https://www.youtube.com/watch?app=desktop&amp;v=puNXsnrYWTY","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"}]},{"title":"gdb","date":"2023-11-29T02:08:16.537Z","path":"wiki/cs/compile&debug/gdb/","text":"1. 启动gdb调试 1. 编译程序 程序编译时需要附加调试信息-g，并关闭优化-O0 1234567891011121314$ gcc -g -o helloworld helloworld.c$ gdb helloworldGNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2Copyright (C) 2020 Free Software Foundation, Inc.……Reading symbols from xxx/helloworld...done.#如果不带-g，即gcc -o helloworld helloworld.c，则输出Reading symbols from xxx/helloworld...(no debugging symbols found)...done.#编译命令带-g生成程序后，可以使用Linux的strip命令移除该程序的调试信息#使用strip命令之前-rwxr-xr-x. 1 root root 12416 Sep 8 09:45 helloworld#使用strip命令之后，文件大小变小（12416-&gt;6312），此时再用gdb启动该程序，则会返回no debugging symbols found$ strip helloworld-rwxr-xr-x. 1 root root 6312 Sep 8 09:55 helloworld 2. 启动调试 三种方式 123456789101112131415161718192021#1. 直接启动程序进行调试$ gdb helloworld#2. 如果程序已经启动在运行，使用attach命令将gdb附加到该程序进程ID上（gdb attach pid）#进程ID可以使用ps命令获取$ ps -ef | grep helloworldchanghe 217055 216643 99 10:43 pts/2 00:00:55 ./helloworld$ gdb attach 217055#3. 程序Crash后调试core文件#Linux默认不开启程序Crash产生core文件机制，可以使用ulimit -c查看是否开启，输出0则是不开启$ ulimit -c#开启产生core机制可以使用ulimit -c unlimited命令，unlimited意为不限制core文件大小，也可改成具体数值，比如1024（即1024k字节大小）#ulimit -c unlimited命令只在当前终端有效，关闭终端后失效。设置永久生效的方式有两种：#一是在/etc/security/limits.conf 中增加一行#&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;* soft core unlimited#二是在/etc/proﬁle文件（所有用户）或~/.bashrc（当前用户）末尾加入该命令ulimit -c unlimited （或 ulimit -c 1024）#程序崩溃生成core.pid文件（需要编译时添加-g）后，使用下面命令进行调试$ gdb filename corename 程序崩溃后很难知道当时它运行的PID，所以也就不知道对应哪个core文件。以下是记录程序对应core文件的两个方法 1234567891011121314151617//1. 程序启动时记录自己的PID，这样就可以根据core.pid去查找对应的core文件了void writePid()&#123;uint32_t curPid = (uint32_t) getpid();FILE* f = fopen(&quot;helloworld.pid&quot;, &quot;w&quot;);assert(f);char szPid[32];snprintf(szPid, sizeof(szPid), &quot;%d&quot;, curPid);fwrite(szPid, strlen(szPid), 1, f);fclose(f);&#125;//2. 自定义生成core文件的目录名称mkdir ~/core_dump_directory//%e是程序名，%p是PID，%t是文件生成时间echo &quot;~/core_dump_directory/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern//最终会在 ~/core_dump_directory 目录下（需具备写入权限）生成的 test 的 core 文件名格式如下-rw-------. 1 user user 409600 Jan 14 13:54 core-helloworld-13154-1547445291 2. 命令详解 run 启动调试后，只是在程序上附加了gdb，并没有启动该程序，需要输入run命令启动这个程序。 程序启动后可使用Ctrl+C终端程序，再次输入run，可以重新启动该程序。 continue 如果不想重新启动程序，而是想让中断的程序继续运行，可以输入continue命令 break、tbreak 123456#在名为function的函数入口出添加一个断点(gdb) break function#在gdb调试器所在的当前文件第num行处添加一个断点(gdb) break num#在filename文件第num行处添加一个断点(gdb) break filename:num break命令是添加一个永久的断点，tbreak命令是添加一个临时断点，触发一次后自动删除。 backtrace、frame backtrace命令可以简写为bt，用来查看当前所在线程的调用堆栈。堆栈编号以#number表示。 如果在主线程，那么最顶层堆栈是main()函数。 切换到某堆栈，可以使用frame命令（可简写为f） 1$ frame number #堆栈编号不用加“#” info break、enable、disable、delete 1234567891011121314151617#查看所有断点(gdb) info break # 或 info bNum Type Disp Enb Address What1 breakpoint keep y 0x000000000004d93a in main at server.c:61472 breakpoint keep y 0x0000000000041593 in dictSdsKeyCaseCompare at server.c:12693 breakpoint keep y 0x0000000000043589 in beforeSleep at server.c:2364#可见示例中一共存在3个断点，分别在6147、1269、2364行#如果想禁用某个断点，使用 disable 断点编号 就可以禁用这个断点；同理，被禁用的断点也可以使用 enable 断点编号 重新开启(gdb) disable 2(gdb) info bNum Type Disp Enb Address What1 breakpoint keep n 0x000000000004d93a in main at server.c:61472 breakpoint keep y 0x0000000000041593 in dictSdsKeyCaseCompare at server.c:12693 breakpoint keep y 0x0000000000043589 in beforeSleep at server.c:2364#可见，禁用断点2后，Enb下方的标志由y变为n. 同理，使用enable 2命令重启后，该标志又会回到y#enable、disable命令后不加断点编号，即表示开启、禁用所有断点#delete 断点编号，即表示删除某断点。同理，不加断点编号，即表示删除所有断点 list 该命令可以查看当前断点前后的代码（默认范围为10行），可以简写为l. 再次输入命令继续向后显示10行代码。 list +和list -分别表示向后和向前显示代码。 list 也可以显示其他文件某一行前后的代码。 1list FILE:LINENUM #to list around that line in that file, 更多用法输入help list print、ptype print 命令可以在调试过程中查看变量的值，也可以修改当前内存中的变量值，可以简写成 p print 命令不仅可以输出变量值，也可以输出特定表达式计算结果值，甚至可以输出一些函数的执行结 果值。 1234567891011121314151617181920212223242526272829303132#打印server.port变量的值 (gdb) print variable(gdb) p server.port$1 = 6379#打印server.port变量的类型(gdb) ptype server.porttype = int#列出当前对象的各个成员变量值(gdb) p *this#打印三个变量的和(gdb) p a+b+c#打印函数执行结果(gdb) p function()#某个时刻，某个系统函数执行失败了，通过系统变量 errno 得到一个错误码，可以使用(gdb) p strerror(errno) #将这个错误码对应的文字信息打印出来，这样就不用去 man 手册上查找这个错误码对应的错误含义#修改变量的值(gdb) p server.port=6400$4 = 6400#打印变量时可以指定输出格式 (gdb) print /format variable(gdb) p /x server.port$6 = 0x1900#format常见取值o octal 八进制显示x hex 十六进制显示d decimal 十进制显示u unsigned decimal 无符号十进制显示t binary 二进制显示f float 浮点值显示a address 内存地址格式显示(与十六进制相似)i instruction 指令格式显示s string 字符串形式显示z hex, zero padded on the left 十六进制左侧补0显示 info、thread 可以使用 info threads 来查看进程当前所有线程信息 12345678910111213141516171819202122232425262728293031323334(gdb) info threads Id Target Id Frame * 1 Thread 0x7ffff79d57c0 (LWP 230901) &quot;redis-server&quot; 0x00007ffff7c9046e in epoll_wait ( epfd=5, events=0x5555557a1db0, maxevents=10128, timeout=100) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30 2 Thread 0x7ffff6ba6700 (LWP 230905) &quot;bio_close_file&quot; futex_wait_cancelable ( private=&lt;optimized out&gt;, expected=0, futex_word=0x5555557073e8 &lt;bio_newjob_cond+40&gt;) at ../sysdeps/nptl/futex-internal.h:183 3 Thread 0x7ffff63a5700 (LWP 230906) &quot;bio_aof_fsync&quot; futex_wait_cancelable ( private=&lt;optimized out&gt;, expected=0, futex_word=0x555555707418 &lt;bio_newjob_cond+88&gt;) at ../sysdeps/nptl/futex-internal.h:183 4 Thread 0x7ffff5ba4700 (LWP 230907) &quot;bio_lazy_free&quot; futex_wait_cancelable ( private=&lt;optimized out&gt;, expected=0, futex_word=0x555555707448 &lt;bio_newjob_cond+136&gt;) at ../sysdeps/nptl/futex-internal.h:183#一共有4个线程，当前gdb附加在1号线程（带星号）。#【所有的线程ID在第三栏(LWP number)中。在早期的 Linux 系统的内核里面，不存在真正的线程实现# 当时所有的线程都是用进程来实现，称之为LWP，即Light Weight Process（轻量级进程）】#切换到其他线程，使用thread 线程编号(gdb) thread 3[Switching to thread 3 (Thread 0x7ffff63a5700 (LWP 231546))]#0 futex_wait_cancelable (private=&lt;optimized out&gt;, expected=0, futex_word=0x555555707418 &lt;bio_newjob_cond+88&gt;) at ../sysdeps/nptl/futex-internal.h:183183 ../sysdeps/nptl/futex-internal.h: No such file or directory.(gdb) info threads Id Target Id Frame 1 Thread 0x7ffff79d57c0 (LWP 231538) &quot;redis-server&quot; 0x00007ffff7c9046e in epoll_wait (epfd=5, events=0x5555557a1db0, maxevents=10128, timeout=100) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30 2 Thread 0x7ffff6ba6700 (LWP 231545) &quot;bio_close_file&quot; futex_wait_cancelable (private=&lt;optimized out&gt;, expected=0, futex_word=0x5555557073e8 &lt;bio_newjob_cond+40&gt;) at ../sysdeps/nptl/futex-internal.h:183* 3 Thread 0x7ffff63a5700 (LWP 231546) &quot;bio_aof_fsync&quot; futex_wait_cancelable (private=&lt;optimized out&gt;, expected=0, futex_word=0x555555707418 &lt;bio_newjob_cond+88&gt;) at ../sysdeps/nptl/futex-internal.h:183 4 Thread 0x7ffff5ba4700 (LWP 231547) &quot;bio_lazy_free&quot; futex_wait_cancelable (private=&lt;optimized out&gt;, expected=0, futex_word=0x555555707448 &lt;bio_newjob_cond+136&gt;) at ../sysdeps/nptl/futex-internal.h:183 如何找到main函数所在的主线程，并切换过去？ 1234567891011121314#_start 是C程序的入口函数，可以设置断点在入口函数内，然后运行程序，查看当前线程：(gdb) break _startBreakpoint 1 at 0x55555558bb80(gdb) runThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/changhe/gdb/redis-6.2.4/src/redis-server [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.Breakpoint 1, 0x000055555558bb80 in _start ()(gdb) info threads Id Target Id Frame * 1 Thread 0x7ffff79d57c0 (LWP 231538) &quot;redis-server&quot; 0x000055555558bb80 in _start () info 命令还可以用来查看当前堆栈处函数的参数值：info args 1234567891011121314(gdb) bt#0 0x00007ffff71e2603 in epoll_wait () from /usr/lib64/libc.so.6#1 0x0000000000428a9e in aeApiPoll (eventLoop=0x5e5770, tvp=0x7fffffffe140) at ae_epoll.c:112#2 0x00000000004297e2 in aeProcessEvents (eventLoop=0x5e5770, flags=27) at ae.c:447#3 0x0000000000429ab6 in aeMain (eventLoop=0x5e5770) at ae.c:539#4 0x00000000004372bb in main (argc=1, argv=0x7fffffffe308) at server.c:5175(gdb) f 2 #切换到堆栈 #2,堆栈 #2 调用处的函数是 aeProcessEvents(),一共有两个参数#2 0x00000000004297e2 in aeProcessEvents (eventLoop=0x5e5770, flags=27) at ae.c:447447 numevents = aeApiPoll(eventLoop, tvp);(gdb) info args #使用该命令输出当前函数的两个参数值，指针类型的参数，gdb 默认会输出该变量的指针地址值eventLoop = 0x5e5770flags = 27(gdb) p *eventLoop #要想输出指针指向的对象的值，可以使用print命令，#如果还要查看其成员值，继续使用 变量名-&gt;字段名 即可（如 p eventLoop-&gt;maxfd ） next、step、until、finish、return、jump 命令 缩写 作用 next n step over，单步步过，不进入函数体内部 step s step into，单步步入，进入函数体内部 until u until 程序行号，指定程序运行到某一行代码处停下 finish 立即执行当前函数剩余代码并正常返回 return 立即结束执行当前函数并返回（如果当前函数还有剩余的代码未执行，也不会执行） jump j jump location，location 可以是程序行号或者函数地址，jump 会让程序执行流跳转到指定位置执行 until 注意 与 break 命令不同，until 命令中的行号是 GDB 中显示的行号，而不是源代码文件中的行号。这里的行号以 gdb 调试器中的行号为准（可以通过list查看），不是源码文件中的行号，由于存在条件编译，部分代码可能不会被编译进可执行文件中，所以实际的调试符号文件中的行号与源码文件中的行号可能会不完全一致。 jump 注意： 123456789101112int somefunc()&#123; //代码A //代码B //代码C //代码D //代码E //代码F&#125;//假设断点初始位置在行号 3 处（代码 A），这个时候使用 jump 6，那么程序会跳过代码 B//和 C 的执行，执行完代码 D（ 跳转点），程序并不会停在代码 6 处，而是继续执行后续代码，因此如//果想查看执行跳转处的代码后的结果，需要在行号 6、7 或 8 处设置断点。 1234567891011121314151617//jump命令有一个妙用就是可以执行一些想要执行的代码，而这些代码在正常的逻辑下可能并不会执行int main()&#123; int a = 0; if (a != 0) &#123; printf(&quot;if condition\\n&quot;); &#125; else &#123; printf(&quot;else condition\\n&quot;); &#125;return 0;&#125;//在行号 4 、14 处设置一个断点，当触发行号 4 处的断点后，正常情况下程序执行流会走 else 分//支，可以使用 jump 7 强行让程序执行 if 分支，接着 gdb 会因触发行号 14 处的断点而停下来，此//时接着执行 jump 11，程序会将 else 分支中的代码重新执行一遍 disassemble 在一些高级调试时，我们可能要查看某段代码的汇编指令去排查问题，或者是在调试一些没有调试信息的发布版程序时，也只能通过反汇编代码去定位问题。 disassemble 会输出当前所在函数的汇编指令，假设我们现在在 redis 的 initServer() 中执行该命令会输出 initServer() 函数的汇编指令. 12345678910111213141516171819202122(gdb) b initServerBreakpoint 2 at 0x555555599666: file server.c, line 3137.(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/changhe/gdb/redis-6.2.4/src/redis-server [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.235674:C 12 Oct 2023 16:00:36.542 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo235674:C 12 Oct 2023 16:00:36.542 # Redis version=6.2.4, bits=64, commit=00000000, modified=0, pid=235674, just started235674:C 12 Oct 2023 16:00:36.542 # Warning: no config file specified, using the default config. In order to specify a config file use /home/changhe/gdb/redis-6.2.4/src/redis-server /path/to/redis.confBreakpoint 2, initServer () at server.c:31373137 void initServer(void) &#123;(gdb) disassemble Dump of assembler code for function initServer:=&gt; 0x0000555555599666 &lt;+0&gt;: endbr64 0x000055555559966a &lt;+4&gt;: push %rbp 0x000055555559966b &lt;+5&gt;: mov %rsp,%rbp 0x000055555559966e &lt;+8&gt;: push %rbx 0x000055555559966f &lt;+9&gt;: sub $0x18,%rsp …… gdb 默认反汇编为 AT&amp;T 格式的指令，可以通过 show disassembly-ﬂavor 查看。如果习惯 intel 汇编 格式的，用命令 set disassembly-flavor intel 来设置。 1234567891011(gdb) show disassembly-ﬂavorThe disassembly flavor is &quot;att&quot;.(gdb) set disassembly-flavor intel(gdb) disassemble Dump of assembler code for function initServer:=&gt; 0x0000555555599666 &lt;+0&gt;: endbr64 0x000055555559966a &lt;+4&gt;: push rbp 0x000055555559966b &lt;+5&gt;: mov rbp,rsp 0x000055555559966e &lt;+8&gt;: push rbx 0x000055555559966f &lt;+9&gt;: sub rsp,0x18 …… 这个命令在我们只有程序崩溃后产生 core 文件，且无对应的调试符号时非常有用，我们可以通过分析 汇编代码定位一些错误。","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"compile&debug","slug":"cs/compile-debug","permalink":"https://silencht.github.io/categories/cs/compile-debug/"}]},{"title":"性能分析工具之perf","date":"2023-11-29T02:08:16.537Z","path":"wiki/cs/compile&debug/perf/","text":"1. 简介 perf 是 Linux 内核提供的性能分析工具，可以分析程序运行的性能瓶颈和优化点。通常随着 Linux 内核的安装而自动安装。它通常包含在 linux-tools 或 perf-tools 包中，具体取决于你所使用的 Linux 发行版。 使用perf --version便可以查看perf的软件版本。 12$ perf --versionperf version 5.15.111 如果提示找不到该命令，可通过以下命令进行安装（Ubuntu发行版） 1sudo apt-get install linux-tools-common 2. 使用 2.1 分析正在运行的程序 如果要分析的程序可执行文件名称为 grid_map，使用如下命令 12345678910111213#查看目录下的文件，可见存在可执行文件grid_map，运行之ls grid_map grid_map.cpp CMakeLists.txt./grid_map#假设该程序正在运行中，通过ps命令查看它的进程号，可得PID进程号为880154ps -ef | grep grid_mapchanghe 880154 880083 99 18:01 pts/5 00:00:24 ./grid_map#使用perf命令分析该程序sudo perf record -F 99 -p 880154 -g -- sleep 30[ perf record: Woken up 1 times to write data ][ perf record: Captured and wrote 0.522 MB perf.data (4534 samples) ]lsgrid_map grid_map.cpp CMakeLists.txt perf.data 命令说明 sudo: 以超级用户权限运行命令，因为 perf 需要访问内核信息 perf record: 用于收集性能数据 -F 99: 设置采样的频率为 99 Hz。这意味着 perf 将每秒对正在运行的程序进行99次采样 -p 880154: 指定要监视的进程的进程 ID (PID)。在这个例子中，880154 是希望分析的grid_map进程PID。 -g: 启用堆栈跟踪，记录每个采样时的调用堆栈信息，以便更详细地了解程序的执行路径 -- sleep 30: 持续采集30秒 采集完成后，输出一个perf.data文件 2.2 分析可执行文件 使用如下命令 123sudo perf record -F 99 -g ./grid_map --sleep 30[ perf record: Woken up 2 times to write data ][ perf record: Captured and wrote 0.606 MB perf.data (5112 samples) ] 命令说明 其实同2.1，就是将-p PID替换为了可执行文件路径 3. 使用火焰图可视化结果 FlameGraph是由BrendanGregg开发的一款开源可视化性能分析工具，形象的称为火焰图。其基于 perf 结果产生的SVG 图片，用来展示 CPU 的调用栈。 要使用火焰图可视化perf分析结果，首先下载FlameGraph 12#注意：FlameGraph仓库下载的目录影响下面代码./FlameGraph/stackcollapse-perf.pl的执行路径git clone https://github.com/brendangregg/FlameGraph 分析结果可视化 1234567#现在要对分析结果文件perf.data进行火焰图可视化lsgrid_map grid_map.cpp CMakeLists.txt perf.datasudo perf script -i perf.data &gt; perf.unfoldsudo ./FlameGraph/stackcollapse-perf.pl perf.unfold &gt; perf.foldedsudo ./FlameGraph/flamegraph.pl perf.folded &gt; perf.svg#现在目录下便有一个名为perf.svg的文件了 命令说明 perf script: 从 perf.data 文件中生成可读的文本格式的性能数据。该命令会将数据写入标准输出 -i perf.data: 指定 perf 工具读取 perf.data 文件 &gt; perf.unfold: 将标准输出重定向到名为 perf.unfold 的文件中。这个文件包含了可读的性能数据 ./FlameGraph/stackcollapse-perf.pl: 该脚本将 perf 的输出进行处理 &gt; perf.folded: 将处理后的输出重定向到名为 perf.folded 的文件中。这个文件包含了折叠后的性能数据 ./FlameGraph/flamegraph.pl: 该脚本将perf.folded转换为 Flame Graph 的 SVG 图形。 使用浏览器将perf.svg文件打开便可以查看结果图，示例图如下： y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。 x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。 也可以实时查看当前系统程序性能分析数据 12perf record -F 999 -a -g -- sleep 60perf script | ./stackcollapse-perf.pl | ./flamegraph.pl &gt; out.svg perf script： 这个命令从实时数据中读取。它会连接到正在运行的 perf record 进程（如果有的话）或者当前的系统事件，然后输出相应的性能数据。 这个命令通常用于实时查看当前系统的性能数据，而不是读取之前保存的数据文件。 由火焰图可见，grid_map::MedianFilter::update和grid_map::NormalVectorsFilter::update两个函数是程序性能的关键所在。继续向上回溯便可以逐渐发现程序的执行的“热点函数”。 有了这些分析，便可以针对性的对程序提出一些优化。 4. 参考资料 如何读懂火焰图？ Linux C/C++性能优化分析工具Perf使用教程","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"compile&debug","slug":"cs/compile-debug","permalink":"https://silencht.github.io/categories/cs/compile-debug/"}]},{"title":"MySQL","date":"2023-11-29T02:08:16.537Z","path":"wiki/cs/database/MySQL/","text":"1.安装mysql 1.1 WINDOWS环境 参考微信读书《MySQL8从零开始学》 1.2 LINUX环境 5.7 123sudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev 安装过程中会提示设置密码什么的，记住密码不要忘。 第三条命令出现 正在读取软件包列表... 完成 正在分析软件包的依赖关系树 正在读取状态信息... 完成 有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是 因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件 包尚未被创建……错误，根据博客解决之，网址为：https://www.cnblogs.com/mliudong/p/4217945.html 安装完成之后可以使用如下命令来检查是否安装成功： 1sudo netstat -tap | grep mysql 检查命令出现“sudo: netstat：找不到命令”，查找博客https://blog.csdn.net/weixin_41931602/article/details/83211455，输入命令:sudo apt-get install net-tools 后解决问题。 1.3 LINUX环境 8.0 https://blog.csdn.net/iehadoop/article/details/82961264 1.4 MySQL常用命令 1.4.1 登陆： 123456mysql -u root -p root用户本地登陆mysql –u用户名 [–h主机名或者服务器IP地址] –p;输入密码;一般用户远程登陆 1.4.2 MySQL命令： 1234567891011121314SHOW DATABASES;列出 MySQL 数据库管理系统的数据库列表。USE 数据库名 ;选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。SHOW TABLES;显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。SHOW COLUMNS FROM 数据表;显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。select * from 数据表;获取该数据表的所有记录的数据。 2.创建数据库 1CREATE DATABASE 数据库名; 3.创建用户 创建可以访问数据库gesture的yoloyolo用户，密码为silencht 1234GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROPON gesture.*TO &#x27;yoloyolo&#x27;@&#x27;192.168.1.%&#x27;IDENTIFIED BY &#x27;silencht&#x27;; 4.创建数据表 123456789CREATE TABLE gesture_tbl(gesture_id INT UNSIGNED AUTO_INCREMENT,c1 INT,p1 FLOAT,c2 INT,p2 FLOAT,fps FLOAT,PRIMARY KEY (gesture_id))ENGINE=InnoDB DEFAULT CHARSET=utf8; 5.插入原始的3行初始化数据 123456789101112INSERT INTO gesture_tbl(c1,p1,c2,p2,fps)VALUES (&#x27;2&#x27;,&#x27;98.654874&#x27;,&#x27;6&#x27;,&#x27;46.544648&#x27;,&#x27;26.7684&#x27;);INSERT INTO gesture_tbl(c1,p1,c2,p2,fps)VALUES (&#x27;18&#x27;,&#x27;96.4564534&#x27;,&#x27;9&#x27;,&#x27;0&#x27;,&#x27;19.6574&#x27;);INSERT INTO gesture_tbl(c1,p1,c2,p2,fps)VALUES (&#x27;9&#x27;,&#x27;83.65546564&#x27;,&#x27;20&#x27;,&#x27;36.456464&#x27;,&#x27;24.4864&#x27;); 6.（示例）命令行更新表格第二行数据 1UPDATE gesture_tbl SET c1 = &quot;6&quot;, p1 = &quot;96.8586&quot;, c2 =&quot;18&quot;, p2 =&quot;16.67452&quot;, fps = &quot;21.4186&quot; WHERE gesture_id = 2; 7. C语言调用MySQL的接口，进行增删改查操作 代码位于此仓库：https://github.com/silencht/Use-C-language-to-call-Mysql","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"database","slug":"cs/database","permalink":"https://silencht.github.io/categories/cs/database/"}]},{"title":"组合电路","date":"2023-11-29T02:08:16.537Z","path":"wiki/ee/数字电子技术/组合电路/","text":"0. 序 1.我常常在想，数字电子技术和程序设计基础C是何等的相似，以至于我总想把数电理解为电路中的c语言。组合逻辑电路中的译码器，编码器，数据选择器等等可以看做C语言中的各种函数，电路输入即为函数形参，电路输出即为函数返回值。我们在设计电路时，可以把各种封装器件按照它们的功能运用在不同的位置，我们编写程序时，把各种函数按照功能放在main函数中的不同行，在运用器件or函数的时候，我们不会考虑它内部的运作情况，仅仅关注它的输入与输出的关系。 2.数字电路按照逻辑功能的不同可分为组合逻辑电路与时序逻辑电路。其中，组合逻辑电路的本质即为:任意时刻输出仅取决于该时刻的输入。高度概括为:无反馈、无记忆。 1. 电路的设计方法 方法就像是一纸蓝图，常用的组合电路、器件就像是依靠蓝图建造的幢幢房屋。 设计方法: 1逻辑抽象:分析事件因果，确定输入输出。一般将因作为输入，果作为输出 2定义逻辑状态0/1的含义 3根据因果关系列写真值表 4将真值表转化为逻辑函数 5选定器件类型 6根据实际，化简函数或变换成适当形式 7画出电路图 8工艺设计 2. 常用电路、器件的罗列 这部分内容有迹可循，大多按照器件(每类器件选一到几个典型实际器件)功能/定义/目的，真值表，逻辑表达式，内部电路图，封装原件图，原件外部拓展等来介绍。 常用器件: 编码器:为了区分一系列不同事物，将其中每个事物用一个二进制代码表示，这就是编码。 首先介绍普通编码器，之后由于普通编码器任何时刻只允许输入一个编码器信号，否则输出将发生混乱的缺点，将输入信号按照优先顺序排好队，改进为优先编码器，于是便允许同时输入两个以上的编码信号，容错率大大增加。 译码器:将每个输入的二进制代码译成对应的输出高低电平信号或另外一个代码 首先介绍结构简单的适用于大规模集成电路内部的二极管与门译码器，但其有输入电阻较低，输出电阻较高、输出的高低电平信号发生偏移等缺点。于是又介绍CMOS门译码器，最后介绍一些显示译码器(半导体数码管与液晶显示器) 数据选择器:又称多路开关。在选择输入(地址输入)的作用下，从多个数据输入通道中选择某一通道的数据传至输出端。 此时，局部总结一下这三个器件的关系。我们其实可以把译码器(以74HC138为例)看做一个数据分配器，将片选输入端S1作为数据输入端，将A2A1A0作为地址输入端，功能是将S1输入端的信号输出到A2A1A0所选定的输出线上去。 于是便有这样两种关系: (1) 将S视为开关时，译码器与编码器可以看做互为反操作。一组高低电平经过编码输出为二进制码，再经过译码又输出为一组高低电平。 (2) 将S视为数据时，译码器看作数据分配器，其与数据选择器可以看做互为反操作。1个数据经过数据分配输出为n个数据，再经过数据选择又输出为1个数据。 最后，我想了很久，倒是没发现编码器与数据选择器的强烈联系。(因为我觉得按照不同角度来看，译码器可以看做分配器并分别与编码器与选择器互逆的话，编码器与选择器应该有某种角度的相似。) 加法器:能够完成两数之间的相加运算，是构成运算器的基本单元。 首先介绍极为简单的半加器，由于半加器不考虑来自低位进位的缺陷，将两个半加器和一个或门组成了可以考虑来自低位进位的全加器。由于全加器只能进行一位数据之间的运算，因此将多个全加器扩展为电路结构简单的可以进行多位数据加法的串行进位加法器，由于串行进位加法器运算速度慢，因此改进原理，设计成以提高电路复杂程度为代价的运算速度快的超前进位加法器。 数值比较器:比较两个数值的大小。 首先介绍最简单的一位数值比较器，进而扩展为从高位到低位逐位比较的多位数值比较器。 3. 竞争-冒险现象 由于竞争而在电路输出端可能产生尖峰脉冲的现象的产生原因，检查方法，消除手段，至此组合逻辑电路到了尾声。 4. 总结 从组合电路介绍的元器件来看，编码译码，数据选择，加法，比较等五花八门。但这些器件都脱离不开组合电路的设计方法，器件的灵魂都源于设计方法的宏伟蓝图。 这也使得，每个电路模块(器件)都可以仅用一张真值表来表达任何功能类型。 所以，依据真值表，我们可以把输出数据看成输入数据所对应的编码，那么所有组合电路模块的功能都可以看成是一种译码行为。所以我们可以把所有的组合电路的元器件归结为一般意义上的译码电路，称之为广义译码器。 由此，在组合逻辑电路的范畴中，无论设计出何种功能迥异的器件，我们都可以直指其本质: 按照真值表设计的“译码器”！ 参考资料 《数字电子技术基础》第五版，阎石主编，高等教育出版社 《数字电子技术基础》第二版，潘松、陈龙、黄继业编著，科学出版社","tags":[],"categories":[{"name":"ee","slug":"ee","permalink":"https://silencht.github.io/categories/ee/"},{"name":"数字电子技术","slug":"ee/数字电子技术","permalink":"https://silencht.github.io/categories/ee/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"}]},{"title":"触发器","date":"2023-11-29T02:08:16.537Z","path":"wiki/ee/数字电子技术/触发器/","text":"0. 序 逻辑电路可分为“组合”与“时序”两大类。上节的介绍的“组合逻辑电路”，可高度概括为:无反馈、无记忆。自然，与其对应的“时序逻辑电路”便是：有反馈、有记忆。即时序逻辑电路的输出不仅取决于其当前的输入，还与过去的“状态”有关。 1. 时序电路的灵魂——“记忆” 设计电路，完成我们所需要的各种复杂功能，很多时候不可能进行一次操作就得到我们想要的结果。因此，期间要对很多中间结果进行“记忆”，这就需要一系列能够存储“状态”的电路模块。就像组合电路中的与或非门基本单元构成一样，这种具有存储记忆功能的模块是组成时序电路的基本单元。 存储元件的记忆功能决定了其必须具备两个最基本的特点： 具有两个相对稳定的输出状态，表示逻辑状态0和1，即“双稳态” 能够通过外加触发信号，设置或改变元件的状态，即“可更改” 满足这两个特点的最简单的存储电路结构之一，便是基本SR锁存器（Set-Reset Latch） 2. 基本记忆元件——锁存器（latch） 2.1 基本SR锁存器 电平触发1 首先介绍最简单的存储单元电路——基本SR锁存器的物理结构、四种输入下的工作原理，然后列出其逻辑功能的两种描述方法： 状态转移真值表及特征方程 状态转移图和激励表 锁存器一个非常重要的特性是输出值只在输入值发生改变时，才会跟着变化。新的输出值的延迟仅受门电路传输延迟时间的影响。这是锁存器的“透明性”，所以有时称锁存器为透明锁存器（Transparent latches）. 缺陷：S和R端同时有效时，输出的新状态不能确定，因此实际应用需要满足一定的约定条件。 2.2 同步SR锁存器 电平触发 而在实际应用中，常常需要使各基本SR锁存器的逻辑状态在同一时刻更新（多个锁存器需要同时动作），为此在SR锁存器基础上引入一个同步信号CLK来控制电路，这个同步信号也称为使能信号、时钟脉冲，简称时钟。这种引入受时钟控制的锁存器便称为同步SR锁存器。 通过物理结构和工作原理的介绍，得知： 同步SR锁存器仅当CLK信号有效时，功能与基本SR锁存器相同（透明性：输出信号随时随输入信号状态的改变而跳转） 当CLK信号无效时，该锁存器状态一直保持不变 在使用过程中，有时候还需要在CLK的有效电平到达之前预先将锁存器置成指定的状态。为此，在电路上往往还加入异步置1/置0端。 然后常规介绍其逻辑功能的两种描述方法。 缺陷：S和R端同时有效时，输出的新状态不能确定，因此实际应用需要满足一定的约定条件。 2.3 D锁存器 电平触发 同步SR锁存器的输入有两个端，但在一些系统中，数据只有一路信号，因而只需要一个数据输入端。最简单的解决办法就是将同步SR锁存器的S端作为数据输入端，然后用一个非门将S端信号反向后作为R端的输入信号。这种结构的电路就叫做D锁存器。D锁存器也有透明性。 注：D锁存器不存在约束条件。 由同步锁存器的动作特点，可以想到，如果在CLK有效期间，输入信号的状态多次发生变化，那么锁存器的输出状态也将发生多次翻转，这种现象称为空翻。即“CLK有效电平持续期间”的透明性降低了触发器的抗干扰能力。 所以，为了提高锁存器工作的可靠性，增强抗干扰能力，改善空翻问题，希望器件在每个CLK周期内输出端的状态只能改变一次，由此便有了触发器。 3. 同步的双稳态器件——触发器（Flip-Flop） 先解决一个问题， 问：锁存器和触发器有什么区别？ 答：它们从一个状态变为另一个状态的方式不同。触发器在特定时段内对输入进行采样，并只在时钟信号所确定的时刻改变其输出；锁存器则不断监测其所有的输入，在任何时刻输出都可能发生变化。触发器利用了锁存器的存储原理，但是加上了触发功能，可以控制保存的时间。简单总结为： 锁存器对时钟脉冲电平（有效电平期间）敏感，为电平触发方式，在有效电平期间都工作 触发器对时钟脉冲边沿（上升沿下降沿）敏感，为脉冲和边沿触发方式，在边沿来临时变化状态 在锁存器的基础上，设计出主从触发器、维持阻塞触发器、利用门电路传输延迟时间的边沿触发器以及利用二极管进行电平配置的边沿触发器等。 3.1 主从SR触发器 脉冲触发 主从S-R触发器由两个同步SR锁存器级联（Cascade）而成。通过主从锁存器与时钟脉冲加上非门的级联，使得主触发器在脉冲有效期间采集S和R端的状态，在脉冲边沿到达之后，主触发器保存最后边沿瞬间的状态，然后将此状态传递给从触发器。 所以主从SR触发器每个CLK周期内输出端的状态只能改变一次。 缺陷： 主触发器本身是一个电平触发的S-R锁存器，所以主触发器依然有在时钟脉冲有效电平持续期间的“一次翻转2”问题 ； S和R端同时有效时，主触发器输出的新状态不能确定，而且输入信号仍需遵守一定的约束条件。 3.2 主从JK触发器 脉冲触发 为了主从S-R触发器即便出现S、R同时有效情况，依然能确定触发器的次态。即解决主从S-R触发器第二个缺陷，需要进一步改进触发器的电路结构。 将主从S-R触发器两个输出端“交叉”接回到输入端形成反馈，称之为：主从JK触发器。 形成反馈回路的主从JK触发器在S和R端同时有效时，输出信号是上个输出信号的反相，而不是主从S-R触发器的未确定状态。 缺陷：由主从S-R触发器改进不彻底带来的主触发器“一次翻转”问题 。 主从结构的SR与JK触发器的 主触发器 依然避免不了由锁存器原理天生的透明性带来的“一次翻转”问题。 为了进一步提高触发器的可靠性，增强抗干扰能力，彻底解决第一个缺陷——“一次翻转”问题（使得触发器的输出状态与CLK边沿之前和之后的输入状态的变化无关），设计出了各种边沿触发的触发器电路。 3.3 主从边沿D触发器 边沿触发 由两个D锁存器级联（Cascade）而成，为CMOS集成电路的主从结构的触发器。 由于来自D锁存器改进，因此其天生没有约束条件的缺陷；而且由于边沿D触发器其输出和输入的直接对应关系，所以除了在边沿升降的建立时间内发生的输入变化将导致输出状态不可预知以外，没有“一次翻转”问题。 为了实现异步置位和复位功能，又引入了SD和RD置位端和复位端。 3.4 维持阻塞D触发器 边沿触发 采用六个与非门组成，可以做到更快更小，为TTL型电路的维持阻塞结构的触发器。同样没有“一次翻转”问题。 3.5 延迟边沿JK触发器 边沿触发 即 利用门电路传输延迟时间的边沿触发器就是边沿JK触发器。通过门电路的传输延迟时间，解决了“一次翻转”问题。 4. 总结与分类 触发器的电路结构与逻辑功能之间不存在固定的对应关系；电路的触发方式由电路结构形式决定，所以电路结构与触发方式之间有固定的对应关系。 凡是采用同步SR结构的触发器，一定是电平触发方式；凡是采用主从SR结构的触发器，一定是脉冲触发方式；凡是采用两个电平触发D触发器结构、维持阻塞结构或利用门电路延迟时间结构的触发器，一定是边沿触发方式。 1.电平触发 触发信号为有效电平（高或低）时，输入信号进入触发器电路，置触发器为相应状态。触发信号变为无效电平后，输入信号被封锁，触发器状态保持。 状态随有效信号全过程改变。 2.脉冲触发 常用主从结构实现，即主、从触发器串联，触发信号反相。以正脉冲触发为例，当触发信号为高时，输入信号进入主触发器，置主触发器状态；触发器变低后，输入信号被封锁，主触发器状态保持，同时，从触发器的状态根据主触发器状态确定。 信号只可能改变一次。 3.边沿触发 指的是接收时钟脉冲CP 的某一约定跳变(正跳变或负跳变)来到时的输入数据。在CP=l 及CP=0 期间以及CP非约定跳变到来时，触发器不接收数据的触发器。仅与该时刻的状态有关。 原出处链接 不管锁存器与触发器的触发方式如何，有无各种缺陷，只要触发器的逻辑功能（特性表）相同，就将之归为一类。通常将时钟控制的触发器分为 SR触发器、JK触发器、D触发器、T触发器等几种类型。 从JK、SR、T三种触发器比较，可以看出JK触发器逻辑功能最强，包含了SR、T触发器的所有逻辑功能，因此使用SR和T触发器的场合可以完全用JK触发器替代。所以，目前生产的触发器定型产品中只有JK触发器和D触发器两大类。 扩展： JK触发器JK这两个字母有什么含义？ JK触发器的J和K是什么意思？ 5. 导图 暂略. 参考资料 1.《数字电子技术基础》第五版，阎石主编，高等教育出版社 2.《数字逻辑设计及应用》姜书艳主编，电子科技大学出版社 3.《数字逻辑设计 学习指导与题解》曾洁、李会勇编著，电子科技大学出版社 【】后面的文字说明触发器的触发方式，触发方式的说明见第四部分——总结与分类中↩︎ 主从JK触发器中也存在类似的问题，即CLK =1 的全部时间里主触发器都可以接收输入信号。而且，由于Q 、Q' 端接回到了输入门上， 所以在Q =0 时主触发器只能接受置1 输入信号，在Q =1 时主触发器只能接受置 0 信号。其结果就是在CLK =1 期间主触发器只有可能翻转一次，一旦翻转了就不会翻回原来的状态。但在主从SR 触发器中，由于没有Q 、Q' 端接到输入端的反馈线，所以CLK=1期间S 、R 状态多次改变时主触发器状态也会随着多次翻转。↩︎","tags":[],"categories":[{"name":"ee","slug":"ee","permalink":"https://silencht.github.io/categories/ee/"},{"name":"数字电子技术","slug":"ee/数字电子技术","permalink":"https://silencht.github.io/categories/ee/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"}]},{"title":"电路原理脉络","date":"2023-11-29T02:08:16.537Z","path":"wiki/ee/电路/电路原理/","text":"线性电阻电路的分析方法和电路定理 1.装备 （注：从根本上说，电荷q和能量w是描述电现象的原始变量，为便于描述电路，从q和w引入电路变量i，u和p。其中电流、电压、功率的微积分定义式以及p=ui这四个式子是集总电路问题中最基本、普遍适用的公式，不论电路是线性的还是非线性的，时不变的还是时变的。） 电流i（\\(i=\\frac{dq}{dt}\\) ），电压u （\\(u=\\frac{dw}{dq}\\) ） 电荷q、能量w、磁链\\(\\psi\\) 、时间t 2.强化装备 电阻R（\\(r=\\frac{u}{i}\\) ）&amp;电导G（\\(g=\\frac{i}{u}\\) ）、功率P（\\(p=\\frac{dw}{dt} =\\frac{dw}{dq} \\cdot \\frac{dq}{dt} =ui\\)） 3.基本规则 （注：基尔霍夫定律与元件的VCR是解决一切集总电路的基本依据，理论上可以解决所有电路的电压电流问题） 基尔霍夫定律（KCL+KVL）、欧姆定律（$i= $） 4.内容 （注1：尽管大多数专业书都厚如砖头，但是其中的各种繁杂公式可能追本溯源都是那么几个最基本最原始的公式再加上使用条件，适用范围、或者是与其他知识互相结合而推导出来的。按我的拙见，电路原理无乱如何也离不开欧姆与基尔霍夫两大定律，这两个定律就是支撑这门课程的树干一般的存在。） （注2：电路分析三大基本方法：相量法，叠加方法（理论基础即叠加定理），分解方法（替代定理在这一方法中起着重要作用）） 4.1 电路等效变换 （两个单口（二端）网络N1和N2，如果N1端钮的VCR（电压电流关系）与N2端钮的VCR完全相同，则N2就和N1是相互等效的。至于N1和N2的内部结构可以完全不同。） （串并联电阻，电源等效，戴维南、诺顿定理都是由前面的基本定义导出的，Y-变换是等效概念运用于三端网络的结果）。 电阻等效变换： 串联（R总=R1+R2+R3+……）、并联（……）、Y- 变换； 电源等效变换：电压源和电阻串联与电流源和电阻并联电路之间的变换 4.2 线性电阻电路分析方法 （两类约束是解决集总电路的基本依据。但是由基本依据求解电路参数大多时候方程式的数量繁多，我们当然希望求解一个电路问题所需联立方程越少越好。联立方程是独立的。因此我们采取一些“前置、限制条件”总结归纳出几种求解电路的基本方法，由此求解具有某些特征的电路，运用不同的方法使得运算量大大减少。但是值得注意的是，我们在将方法改进的同时，也增添了许多限制因素，使得改进的方法拥有局限性，局限性即下图中的缺点，这同时也是我们在解题的同时应该注意的。） 4.3 叠加定理 反应线性电路最根本性质的原理。在线性电路中，电路的响应（即任一支路的电压u或电流i）=比例常数电路的激励（即作用的电路的电压源电压us或者电流源电流is）的叠加和。（举不恰当的数学例子，正比例函数y=kx，k是常数，二次函数y=kxx，第一个kx（与正比例函数中的k做比较）是变量。所以u=ri类比正比例函数，p=ri*i类比二次函数。根据数学函数性质，p的求解就不符合“叠加”的要求，因为它不具有正比例函数那种线性关系。但是求解电路功率，可以先分别求出每一电源单独作用时对电路提供的功率，再进行叠加） 4.4 戴维南与诺顿定理 作用都是如何化简含源线性单口网络的。戴维南定理最大的功劳在于论证了含源线性单口网络，在端口处u、i为关联参考方向的前提下，其VCR具有u=Ai+B这一普遍形式。诺顿定理的功劳实质上是论证了这一形式的i=u/A-B/A。（其中B是开路电压，A是单口网络内部电源置零时的等效电阻） 4.5 替代定理 在一个给定的电路中，若已知某一支路（或单口网络）的电压u和电流i，则该支路（或单口网络整体）可以用一个电压源u，或一个电流源i，或一个电阻R=u/i来置换。**注意，替代并非等效！！！这是两个不同的概念！！！（另一种定义表述方法：替代定理表述，在任意一个具有唯一解的电路中，若已知某支路k的电压uk、电流ik，并且该支路与电路中的其他支路不存在着耦合作用，则无论该支路由什么元件构成，都可以用一个端电压为us=uk的独立电压源或电流为is=ik的独立电流源来替代，电压源的极性与原支路电压极性相同，电流源的电流方向则与原支路电流方向相同。） 4.6 替代定理与等效变换的区别与联系 4.7 替代定理基本要点 应用替代定理的必要前提是应用该定理以前和之后所得到的电路中的所有支路电压和电流均应具有唯一解，这一点对非线性电路应特别加以注意 被替代支路k与电路中其他支路不可存在着耦合关系，即支路k中不能有其控制量在支路k以外的受控源，支路k以外的受控源，其控制量也不可在支路k中，支路k也不能与其以外支路存在着磁耦合关系 。 替代定理适用于集总参数电路，他们可以是线性，非线性，时不变或时变的，在线性时不变的电路分析问题中，应用尤为普遍，当电路中的非线性元件的电压或电流已知时，可以应用替代定理，从而把非线性电路变为线性电路来求解。 应用替代定理不会改变原电路的任意支路电压或支路电流，即替代前后电路中各支路电压和电流均保持不变。替代定理不是电路的一种等效替换。替代定理和第二章的等效变换是不同的。例如若被替代电路的外部情况发生变化，则原替代可能会失效。 参考资料 《电路分析 习题精解》孙瀚荪 编，科学出版社 《电子电气工程师必知必会》【美】Darren Ashby 著，尹华杰译，人民邮电出版社 《电路原理》编者：于歆杰、朱桂萍、陆文娟，清华大学出版社，2007年3月第一次印刷","tags":[],"categories":[{"name":"ee","slug":"ee","permalink":"https://silencht.github.io/categories/ee/"},{"name":"电路","slug":"ee/电路","permalink":"https://silencht.github.io/categories/ee/%E7%94%B5%E8%B7%AF/"}]},{"title":"相量法","date":"2023-11-29T02:08:16.537Z","path":"wiki/ee/电路/相量法/","text":"观看此文应具备基础知识：学习电路至正弦激励下动态电路的稳态分析一章、微积分基础、微分方程等 约定正文符号如下：（①②③…等为公式标识符；❶❷❸…等为文末注释标识符），相关量后面的‘h’是homogeneous通解的首字母，‘p’是particular特解的首字母，数学中的虚数 i 为了避免在电路中与电流 i 混淆，所以虚数 i在此记作 j，相量法中I头上的点由于这里不好编辑，所以用头上的~表示 首先，先来看一道简单的电路习题： 题目： 如图\\(Us\\)为正弦电压源，其值为\\(Umsin｛wt+\\varphi u｝\\)，其中\\(\\varphi u\\)是电压源的初相位。设电感初始值\\(iL｛0^{-} ｝=0\\)安培，\\(t=0\\)时，开关S从1合向2，求换路后电感电流\\(iL｛t｝（t≥0）\\). 解1（对比之前直流电压源\\(Us\\)做法，这是我一开始想到的方法，但是理解到后面，我认为这个方法应该是不通的）： 一阶RC/RL电路经典法求解一般步骤： 建立描述电路的微分方程 求齐次微分方程的通解和非齐次微分方程的一个特解 将齐次微分方程的通解与非齐次微分方程的的一个特解相加，得到非齐次微分方程的通解，利用初始条件确定通解的系数 1.描述换路后电路的微分方程为（实质为KVL）： \\(L\\frac{di_{L} }{dt} +Rdi_{L}=U_{m} sin｛wt+\\varphi u｝\\)----① 令\\(\\frac{di_{L}}{dt} =y^{&#39;}\\) ,\\(iL=y\\),代入①式有： \\(Ly^{&#39;} +Ry=U_{m} sin｛wt+\\varphi u｝\\) ----② 2.列写特征方程（P算子解法❶）：\\(LP+R=0\\Rightarrow P=-\\frac{R}{L}\\), 因而齐次微分方程的通解为：$yh=ke^{- t} $（其中k为待确定量）， 自由项\\(f｛t｝=U_{m} sin｛wt+\\varphi u｝\\)， 设特解\\(yp=A\\)，\\(y^{&#39;} =0\\)（A为常数）代入原方程②，有 \\(yp=A=\\frac{U_{m} }{R}sin[wt+\\varphi u] =I_{m} sin[wt+\\varphi u]\\), 3.方程通解为：\\(y=yh+yp=i_{L}[0^{+} ]=k\\cdot e^{-\\frac{L}{R} \\cdot t} +I_{m} sin[wt+\\varphi u]\\)， 代入初始条件：\\(y|_{t=0^{+} } =i_{L}[0^{+}] =i_{L}[0^{-}]=0\\), 求得系数\\(k=-I_{m} sin[wt+\\varphi u]\\)， 最后可求得题目结果： $i_{L}[t]=I_{m}sin[wt+u]-I_{m}sin[wt+u]e^{-t } $③(t≥0) 乍一看似乎并没有错，但这个式子应该是错误的。学过高中物理知识即可知道，电感对于交流电是有阻碍作用的（通直流阻交流），这个阻碍作用在R中并不能体现出来（因为电阻的电阻为R，也就变相说明电路中阻碍电流的只有线性电阻），而且在学习了后续课程之后可以知道，电感电容这类电学器件是有感抗与容抗的【在求解一阶动态电路三要素法中：时间常数RiC，L/Ri中Ri的含义是从电路的储能原件两端看进去的戴维南等效电阻】； 式子中的\\(\\varphi u\\)也是错误的，学过后续课程之后也可以知道，电感上的电流是落后与电压90°相位的（同样地，电容上的电流也是超前电压90°相位的）。 所以这个方法行不通（可能有解决、改进的办法，但是我没有想出）。 解2（此为《电路原理》书中解法，有删减、补充、改动）： 1.描述换路后电路的微分方程为：$L +Ri_{L}=U_{m}sin[wt+u] $----④ 2.齐次微分方程的通解仍为指数形式：\\(i_{Lh} =Ae^{-\\frac{R}{L} \\cdot t}（t≥0）\\) 非齐次微分方程的一个特解与外加激励应具有同样的形式，设为： \\(i_{Lp} =I_{m} sin[wt+\\varphi i ]（t≥0）\\) 将上式代入式子④，有： \\(wLI_{m}cos[wt+\\varphi i]+RI_{m}sin[wt+\\varphi i]=U_{m}sin[wt+\\varphi u]\\), 对等号左边进行三角变换（辅助角公式❷）： \\(\\sqrt{[wL]^{2} +R^{2} } \\cdot I_{m} sin[wt+\\varphi i+\\varphi ]=U_{m} sin[wt+\\varphi u]\\)⑤, 其中\\(\\varphi\\) 称为电路的阻抗角，$tan= $， 比较⑤中等号左右两边的对应项： \\(\\sqrt{[wL]^{2} +R^{2} } \\cdot I_{m}\\Leftrightarrow U_{m}\\) 与\\(sin[wt+\\varphi i+\\varphi ]\\Leftrightarrow sin[wt+\\varphi u]\\)， 可求得：$I_{m} = \\(与\\)i=u-=u-arctan $， 因此，式子④的一个特解为：\\(i_{Lp} =\\frac{U_{m} }{\\sqrt{[wL]^{2} +R^{2} } } sin[wt+\\varphi u-\\varphi ](t≥0)\\)， 3.电感电流的全响应为：\\(i=i_{Lh} +i_{Lp}=Ae^{-\\frac{R}{L} \\cdot t}+\\frac{U_{m} }{\\sqrt{[wL]^{2} +R^{2} } } sin[wt+\\varphi u-\\varphi ]（t≥0）\\) 代入初始条件：\\(i_{L} [0^{+} ]=i_{L} [0^{-} ]=0\\)， 有：\\(A+\\frac{U_{m} }{\\sqrt{[wL]^{2} +R^{2} } } sin[\\varphi u-\\varphi ]=0\\Rightarrow A=-\\frac{U_{m} }{\\sqrt{[wL]^{2} +R^{2} } } sin[\\varphi u-\\varphi ]\\), 因此，电感电流为： \\(i_{L} =\\frac{U_{m} }{\\sqrt{[wL]^{2} +R^{2} } } sin[wt+\\varphi u-\\varphi ]-\\frac{U_{m} }{\\sqrt{[wL]^{2} +R^{2} } } sin[\\varphi u-\\varphi ]e^{-\\frac{R}{L} \\cdot t}\\)⑥（t≥0）. 【总结】 1.比较解1、解2结果③（现将Im按照解1变形）与⑥： \\(i_{L}[t]=\\frac{U_{m} }{R} sin[wt+\\varphi u]-\\frac{U_{m} }{R}sin[wt+\\varphi u]\\cdot e^{-\\frac{R}{L}t }\\) ③ \\(i_{L} =\\frac{U_{m} }{\\sqrt{[wL]^{2} +R^{2} } } sin[wt+\\varphi u-\\varphi ]-\\frac{U_{m} }{\\sqrt{[wL]^{2} +R^{2} } } sin[\\varphi u-\\varphi ]e^{-\\frac{R}{L} \\cdot t}\\)⑥ 可见，解1后面分析是正确的： ◆sin[这里的值是有相位变换的] ◆比较分子$U_{m} \\(下面的分母，可见解1中的R的确不是单纯的电路电阻值。含储能元件的此电路中对电流阻力的表现形式是这样的：\\){ } $。 可预见的是：电感元件在电路中对电流阻力作用是与电源的角频率w与其本身电感值L共同决定的。这些便是接下来的感抗方面的内容了。 2.通过解2我们发现：上例仅仅是最简单的一阶动态电路，其复杂程度已经令人咂舌。 可以预见，如果在各种大型电路网络中利用此类方法求解，是比较困难的（请允许我用了“比较”这个词汇，鄙见：因为在计算机飞速发展的时代，求解一些普通点的微分方程似乎并不是什么难事？）。由此： 我们不禁想象，是不是有一种方法，可以不用求解微分方程，仅仅像之前直流电源那样，利用线性方程求解，那该多好啊？ 于是，天才工程师斯泰因梅茨疯狂的在电压电流上加了个点，一个伟大的方法诞生了——相量法！ 开始 我们盯住上述题目中：电压源\\(U_{s}= Umsin｛wt+\\varphi u｝\\) 以及用微分方程求解电路过程中的各个方程式。其中有各种各样的已知量、未知量：电压、电流的幅值$U_{m} /I_{m} \\(，初相角\\)u/i\\(，以及激励的频率\\)w$等等。 帅的人可能已经发现：无论是题设、过程、结果，我们如此多的方程式中只要含有三角函数的式子，其中的频率无一不是\\(w\\)！显然，在给定频率的正弦电压电源中，其电路的频率保持不变。可以预见的，正弦电流电源同样如此。 那么，我们想：我们在题目中关注的量（也可以理解为：其中参与方程式变换的量）一般为三个：电压、电流的幅值$U_{m} /I_{m} \\(；初相角\\)u/i\\(；激励的频率\\)w\\(。既然电路中自始至终频率\\)w$死活不变【可以理解为：方程式中参与实际运算的量仅仅为幅值与初相角】，那么我们是不是可以残忍的抛弃这个好吃懒做的家伙、仅仅关心真正的两位劳模：幅值与初相角呢？ 如何将频率*时间从三角函数的大别墅【在此将三角函数如\\(sin[wt+\\varphi ]\\)中的[]戏称为别墅，其中的频率*时间、初相角为别墅中的成员】中拖出来扔到大街？在抛弃频率*时间这个好吃懒做的家伙之后，运算过程能否得以简化？让我们拭目以待。 常规的三角函数变换手段似乎难以将别墅中阴险的频率小伙子诱骗出来，是时候发大招了——欧拉的愤怒！ 欧拉公式❸【请阅读下文之前务必阅读此注释，重要！重要！重要！】： \\(e^{jx} =cosx+j\\cdot sinx\\) 仔细观察公式，将之与$ Umsin｛wt+u｝$比较、分析。还是没有启发？ 那么我们将欧拉公式进一步变换：\\(e^{j[wt+\\varphi ]} =cos[wt+\\varphi ]+j\\cdot sin[wt+\\varphi ]\\Rightarrow e^{jwt+j\\varphi } =cos[wt+\\varphi ]+j\\cdot sin[wt+\\varphi ]\\)， 再变：\\(e^{jwt } \\cdot e^{j\\varphi } =｛coswt+jsinwt ]\\cdot ｛cos\\varphi +jsin\\varphi ｝\\)，现在呢，是不是有点眉目了？ 我们思考：正弦电压源表达式三角函数大别墅中的两个成员不就可以运用欧拉公式变换为两个e指数函数的乘积形式，从而将之从别墅中分离吗？ 按照这个思路，根据：\\(k\\cdot sinx=k\\cdot IM[e^{jx} ]=IM[k\\cdot e^{jx} ]\\)， 于是，电流源\\(i=I_{m} sin[wt+\\varphi i]\\)可以表示为：\\(I_{m} \\cdot IM[e^{j[wt+\\varphi i]} ]=IM[I_{m} \\cdot e^{j[wt+\\varphi i]} ]\\)⑦， 高中的时候（嗯，电路原理课程前面也推到过的，在此不细说），我们就知道：正弦交流电的幅值是有效值的$ \\(倍，即\\)I_{m} = I$。 ⑦式又可以表示为：\\(IM[\\sqrt{2} I\\cdot e^{j\\varphi i}\\cdot e^{jwt} ]\\)⑧，现在总算将\\(IM[ e^{jwt} ]\\)，也就是\\(wt\\)这个家伙拖出来了！【——来人呐，帮朕把这个刁民拖出去，打一百二十大板！——嗻！】 再继续之前，还要介绍一个概念：旋转因子❹。 那让我们乘胜追击，单独看剩下的两个劳模（幅值与初相角）：\\(\\sqrt{2} I\\cdot e^{j\\varphi i}\\)，乘号$$左侧代表幅值，右侧代表初相角。 那么我们之后的运算全都建立在⑧式中的两个劳模 \\(I\\cdot e^{j\\varphi i}\\)，等到运算完成之后，再把\\(wt\\)这个家伙塞进来，反向逆推算子，不就可以得到结果了吗？ 为了简便起见，我们约定：\\(\\tilde{I} =I\\cdot e^{j\\varphi i} =I\\cdot ∠\\varphi i\\) 小结： \\(I_{m} sin[wt+\\psi i]=IM[\\sqrt{2}I\\cdot e^{\\psi i} \\cdot e^{jwt} ]\\),\\(e^{jx} =cosx+j\\cdot sinx\\) 结束 1.将\\(i（t）\\)变成$ $的过程称为从时域到频域的相量变换： \\[ i[t]=I_{m} cos[wt+\\varphi ]\\Rightarrow i[t]=IM[I_{m}e^{j[wt+\\varphi ]} ]\\Rightarrow \\tilde{I} =I_{m}e^{j\\varphi } \\Rightarrow \\tilde{I}=I_{m} \\] 2.大体流程图： 3.以下是知友【@frente nemo 】对相量法的相关理解，供参考： 我想他用的就是以不变应万变的道理吧，所有量都以一个频率在变，其效果就更想对静止差不多了吧，但是他们对电容和电感产生了新的影响，因为他们的电流电压之间有微分和积分的关系。在新的思路下你可以将电感变成jwl，将电容变成1/jwc，接下来你又改思考为什么可以这样变。这是在极坐标下的电流电压关系可以推导出来的。你要再追根溯源说，为什么可以用复数来代替正弦？那是因为欧拉公式将正弦转化成了复数表达。你还问欧拉公式又是什么？它是迈克劳林（泰勒）公式得到的。你必须不断地思考，不断地提问才能明白这一起是怎么回事。 链接：https://www.zhihu.com/question/19851763/answer/37465084 4.接下来，按照思路，可以推导“元件约束与基尔霍夫定律下的相量形式”，然后就可以求解相关习题了！~ 最后引用这位知友的一句话作为本文的结束： 伟大的人类用自己的智慧把交流量头上打个点，然后一切又归于平静了。 注释 【约定注释部分符号如下：（ⅠⅡⅢ…等为公式标识符】 ❶列写特征方程求解一阶微分方程（在我看来，电路求解中的P算子解法接近于高等数学微分方程的特征方程解法，三要素解法接近于高等数学中的通解公式解法。） 下面给出【高等数学一阶微分方程知识以及其特征方程解法】与【直流电压源动态电路中P算子解法】的互相对照： 高等数学一阶线性微分方程基础知识： 对于形如： ----Ⅰ的方程，叫做一阶线性微分方程。 如果对于Ⅰ中，若： ，那么方程： ----Ⅱ称为齐次的；否则，方程Ⅰ称为非齐次的。 一阶非齐次线性微分方程特征方程解法（部分过程参考自文献）： 如果一阶常系数非齐次线性微分方程的一般形式是：$my^{'} +py=qe^{x} $ (m、p、q为常数，一般情况下\\(\\lambda =0\\))。 对于此方程,一般先求出对应的齐次方程的通解,再用常数变易法求原方程的通解。 对应的齐次方程的通解：列写对应特征方程\\(mr+p=0\\)（r为未知量），求解得出$r=- \\(，则齐次通解为：\\)yh=k e^{-x }$ ，下面求非齐次特解。 特解应设为\\(yp=x^{k} \\cdot e^{\\lambda x} Rm[x]\\),求解步骤： \\(Rm[x]\\)是与q同次的多项式，因\\(q\\)为常数，所以\\(Rm[x]\\)取\\(x=1\\)的常数，在此我们约定为常数A \\(\\lambda =0\\)与r对照比较，一般情况下\\(\\lambda \\ne r\\)，因此\\(\\lambda =0\\)不是特征方程的根，所以特解表达式中k取0 把特解表达式（此时特解表达式应为\\(yp =A\\)，\\(y^{&#39;} =0\\)[常数A求导为0]）代入（需要求导的求导之后代入）一般形式的原方程（此时原方程应为\\(my^{&#39;} +py=q）\\)，得： \\(pA=q\\Rightarrow yp=A=\\frac{q}{p}\\) 原方程的通解等于其对应的齐次方程的通解与其一个特解的和： \\(y=yh+yp=k \\cdot e^{-\\frac{p}{m}x }+\\frac{q}{p}\\) ❷在数学中，辅助角是指三角变换中收缩变换的代表辅助角公式：\\(asinx+bcosx=\\sqrt{(a^2+b^2)} sin(x+\\varphi )\\)，其中\\(tan\\varphi =\\frac{b}{a}\\) ❸欧拉公式与复数： 在介绍欧拉公式之前，先要说明的是虚数。经历过高考的我们都知道，复数这个词可以用一个形如\\(a+jb\\)的整体来表示，这里a、b都是通常的实数且b≠0，而\\(j\\)和通常实数不同，具有\\(j^{2} =-1\\)这个性质。虽然看起来很难理解，但是在此只能强迫读者默认这个事实。如果想对复数有更深入的认识，不妨读一下《复分析 可视化方法》这本书。 1. 复数及其运算： 设A为一复数，a和b分别是它的实部和虚部，则复数A的代数形式（又称直角坐标形式）为：\\(A=a+jb\\)，上式中，\\(j=\\sqrt{-1}\\) 为虚数单位。 2. 复数的实部和虚部分别用下列符号表示：\\(Re[A]=a,Im[A]=b\\)。在此不用纠结于Re与Im，可以看作一种算子（就像高中做的那些新定义题目一样，如：定义a#b=ab，那么我们遇到2#3就等于2×3=6）。 【但是为了防止算子\\(Im\\)与电流幅值\\(I_{m}\\) 混淆，在本文中我们约定用\\(IM\\)做取虚部算子写法】 复数经过它们的运算后分别得到该复数的实部和虚部。 复数A还可以表示为三角形式：\\(A=|A|[cos\\Theta +jsin\\Theta ]\\)， 根据欧拉公式又可进一步写成指数形式：$A=|A|e^{j} $， 还可以改写为极坐标形式：\\(A=|A|∠\\Theta\\) 。 其中：若$A=a+jb=|A|∠$，则 \\(a=|A|cos\\Theta ,b=|A|sin\\Theta\\) ,\\(|A|=\\sqrt{a^{2} +b^{2} } ,\\Theta =arctan[\\frac{b}{a} ]\\) 几何表示： 3. 复数的运算：【图片来源：《电路原理》P390-392】 文字浓缩： 两个复数之和A+B由通常向量加法的平行四边形法则给出 两个复数的乘法：AB之长是A之长与B之长的乘积，AB的幅角是A与B的幅角之和 4. 欧拉公式的猜想式推导（非严格）： 设\\(f(x)=\\cos x+j\\sin x\\),有：\\(f(x)f(y)=f(x+y)\\)， 猜知：\\(f(x)\\)为指数函数，设： \\(f(x)=e^{kx} =\\cos x+j\\sin x\\)（其中k为常数，j为虚数单位） 两边求导，得: \\(k\\cdot e^{kx} =-\\sin x+j\\cos x=j^{2}\\sin x+j\\cos x=j[\\cos x+j\\sin x]\\)， 其中[]中便是\\(e^{kx}\\),即：\\(k\\cdot e^{kx} =j\\cdot e^{kx}\\)， 消去\\(e^{kx}\\)（其不为0）, 则\\(k=j\\), 因此我们有：\\(e^{jx} =\\cos x+j\\sin x\\) 5. 欧拉公式 更加有趣的是，在《复分析》这本书的注释中，有这样一句话： 我们相信，现在的证法支持一个观点，即这种恒等式只是复数乘法的简单法则的复杂化了的表现形式。 被誉为上帝公式的欧拉公式，仅仅是复数乘法法则的表现形式！有兴趣的可以读一读这本书的前面几章内容~ ❹旋转因子： 我们假设初值：\\(A=|A|\\cdot e^{j\\Theta }\\) ，如图： 然后做运算：\\(A\\cdot e^{j\\psi } =|A|\\cdot e^{j\\Theta } \\cdot e^{j\\psi }=|A|\\cdot e^{j[\\Theta +\\psi ]}\\) ， 我们可以想象，A的初值是A的绝对值乘e的\\(j\\Theta\\) 次方，当它再乘e的$j$次方时，几何直观看来为： 总结为：任何一个复数乘以\\(e^{j\\psi }\\) 之后，等于这个复数模不变，相角逆时针增加\\(\\psi\\) 度 \\(e^{jwt}\\) 是以角速度w逆时针方向旋转的单位长度的有向线段，称之为旋转因子。 参考文献 《 一阶常系数线性微分方程的某些求法的比较》，作者：汤文菊、胡荣、简志宏 .文章编号:1008-8458(2005)04-0009-02 《高等数学》第七版上册，同济大学数学系编，高等教育出版社，2015年6月第五次印刷 《电路原理》编著：于歆杰、朱桂萍、陆文娟，清华大学出版社，2007年3月第一次印刷 《工程电路分析》（engineering circuit analysis）第七版，作者：【美】William H. Hayt，Jr. Jack E.Kemmerly Steven M.Durbin 编著 ，周玲玲、蒋乐天 等译.，电子工业出版社，2007年7月第一次印刷 《复分析 可视化方法》（visual complex analysis）作者：【美】Tristan Needhan 著，齐民友译，人民邮电出版社，2009年7月北京第一次印刷","tags":[],"categories":[{"name":"ee","slug":"ee","permalink":"https://silencht.github.io/categories/ee/"},{"name":"电路","slug":"ee/电路","permalink":"https://silencht.github.io/categories/ee/%E7%94%B5%E8%B7%AF/"}]},{"title":"视觉SLAM:搞定坐标系、三角测量、PnP","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/note/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/","text":"视觉SLAM:搞定坐标系、三角测量、PnP Author: [行知SLAM] Link: [https://zhuanlan.zhihu.com/p/80921759] 1.正文 四个坐标系：世界坐标系、相机坐标系、图像坐标系、像素坐标系。 世界坐标系：机器人或相机运动过程中，肯定需要知道它的位置，因此需要设定世界坐标系，认定固定不动，作为 参考坐标系，描述世界中的任何一点P（Xw,Yw,Zw)。 相机坐标系：相机或机器人运动的一个坐标系，通过世界坐标系的变换（旋转R,平移T）计算得到。因此主要是将 世界坐标系描述的点坐标P（Xw,Yw,Zw)转换成相机坐标系下描述P（Xc,Yc,Zc)，方便计算得到在成像坐标系的坐 标。 图像（成像）坐标系：描述点在图像坐标系的成像点位置。 像素坐标：在相机中得到的是一个像素，因此主要将图像坐标系的点转换成像素坐标系下。 1.1.将世界坐标系转换得到相机坐标系 旋转 平移 旋转矩阵：R，三维旋转矩阵构成特殊正交群SO(3)。知道它的物理意义就是表示旋转即可。 变换矩阵：T,旋转+平移.变换矩阵构成特殊欧式群SE(3)。 旋转向量（轴角）：一个旋转轴+一个旋转角，外积表示旋转， 欧拉角：绕z轴旋转，得到偏航角yaw,绕旋转之后Y轴旋转，得到俯仰角pitch,绕旋转之后X轴旋转，得到滚转角 roll。 四元数，q=a+bi+cj+dk，类比虚数，同样用来表示旋转。 a.欧式变换：有6个自由度，在变换前后，保持不变的性质是长度、夹角、体积。 b.相似变换：有7个自由度，在变换前后，保持不变的性质是体积比。 c.仿射变换：有12个自由度，在变换前后，保持不变的性质是平行性、体积比。 d.射影变换：有16个自由度，在变换前后，保持不变的性质是接触平面的相交和相切。 计算旋转矩阵 旋转矩阵有9个量，3*3. 1.2相机坐标系与图像坐标系 从相机坐标系到图像坐标系，属于透视投影关系，从3D转换到2D。 此时P点已由上面经过世界坐标系转换成相机坐标系下表述P(Xc,Yc,Zc)。 1.3图像坐标系与像素坐标系 像素坐标系和图像坐标系都在成像平面上，只是各自的原点和度量单位不一样。图像坐标系的原点为相机光轴与成 像平面的交点，通常情况下是成像平面的中点或者叫principal point。图像坐标系的单位是mm，属于物理单位，而像素坐标系的单位是pixel，我们平常描述一个像素点都是几行几列。所以这二者之间的转换如下：其中dx和dy 表示每一列和每一行分别代表多少mm，即1pixel=dx mm . 那么通过上面四个坐标系的转换就可以得到一个点从世界坐标系如何转换到像素坐标系的。 高翔十四讲简洁描述：K表示相机内参，T表示相机外参，即旋转平移。 其中相机的内参和外参可以通过张正友标定获取（戳这里查看张正友标定的资料)。通过最终的转换关系来看，一个三维中的坐标点，的确可以在图像中找到一个对应的像素点，但是反过来，通过图像中的一个点找到它在三维中 对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。 2.视觉里程计 视觉里程计的任务是估算相邻图相间的运动，以及局部地图的样子。由上面的像素坐标系间的关系，我们可以通过 对极约束、三角测量、pnp求得相机的运动。 2D-2D对极约束 预备知识： A为n维方阵，若有A'=-A，则称矩阵A为反对称矩阵。对于反对称矩阵，它的主对角线上的元素全为零，而位 于主对角线两侧对称的元反号。 外积：axb=ab。将记成一个反对称符号，这样就把外积axb写成了矩阵与向量的乘法a^b。 向量的外积结果就是一个和原来两个向量垂直的向量，更为熟知的叫法是法向量，该向量垂直于a和b向量构 成的平面。 点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影。 对极约束求相机运动，由于我们通过特征点匹配确定了像素点p2的位置，可以推断p的空间位置，以及相机的运动。 世界坐标： 两个像素点p1,p2的位置： 本质矩阵E（Essential Matrix) 基础矩阵F(Fndamental) 单应矩阵(Homography) 求解步骤： 1.根据配对点的像素位置求出E或者F. 2.根据E或者F求出R,t。 也就是只要知道配对点的像素位置就可以通过对极约束求出相机位姿。 三角测量 估计了相机运动后，需要用相机的运动估计特征点的空间位置。 单目SLAM中，通过三角测量估计地图的深度。 3D-2D:PnP（Perspective-n-Point） 描述了当知道n个3D空间点及其投影位置时，如何估计相机的位姿。 特征点的3D位置可以由三角化或RGB-D相机的深度图确定。 在双目或RGB-D的视觉里程计中，我们可以直接使用PnP估计相机运动。 单目视觉里程计中，必须先进行初始化，然后才能使用PnP。 3D-2D方法不需要使用对极约束，又可以在很少的匹配点中获得较好的运动估计。 PnP问题有，用3对点估计位姿的P3P、直接线性变换、EPnP、非线性优化(BA)。 直接线性变换 P3P 目的是求相机位姿。输入数据为3对3D-2D匹配点。3D点为A,B,C,2D点为a,b,c。 知道3D点的世界坐标系中的坐标和2D点的图像位置，不知道相机坐标系的坐标。（之前的是根据已知外参和世界 坐标系的坐标可以求得相机坐标系的坐标，现在不知道相机位姿)。 利用三角形对应关系，求出得到A,B,C相机坐标系下的3D坐标。最后把问题转换成一个3D（世界坐标系）到3D(相 机坐标系)下的位姿估计问题。 Bundle Adjustment 重投影误差的问题。 3D-3D:ICP（Iterative,Closet Point,迭代最近点） 3D-3D的位姿估计问题，假设有一组配对好的3D点。 ICP位姿估计没有出现相机模型，和相机没关系。 在RGBD SLAM中，可以用这种方式估计相机位姿。 求解方式主要两种：线性代数求解（主要是SVD),非线性优化方式求解（类似于BA). SVD方法 以上部分参考高博PPT及相关博客：https://blog.csdn.net/sunshine_zoe/article/details/73457686?utm_source=blog xgwz0 注：未经授权，请勿转载。","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"}]},{"title":"贝叶斯滤波（Bayes Filter）推导","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/note/贝叶斯滤波推导/","text":"约定 $t时刻的状态记为x_t $ \\(t 时刻的测量数据记为 z_t\\) \\(t_1到t_2时刻的观测数据流（t_1\\leq t_2）记为z_{t1:t2}=z_{t1},z_{t1+1},z_{t1+2},…,z_{t2}\\) \\((t-1,t]时间内的控制数据记为u_t\\) \\(t_1到t_2时刻的控制数据流（t_1\\leq t_2）记为u_{t1:t2}=u_{t1},u_{t1+1},u_{t1+2},…,u_{t2}\\) \\(状态变量x_t的置信度记为bel(x_t)\\) \\(执行控制量u_t后，进行观测z_t之前的状态变量x_t的置信度记为\\overline{b e l}(x_t)\\) 引用 \\(\\begin{array}{l} \\mathrm{P}(\\mathrm{x} \\mid \\mathrm{y}, \\mathrm{z})\\\\ =\\frac{\\mathrm{p}(\\mathrm{y}, \\mathrm{z} \\mid \\mathrm{x}) \\mathrm{p}(\\mathrm{x})}{\\mathrm{p}(\\mathrm{y}, \\mathrm{z})} \\\\ =\\frac{\\mathrm{p}(\\mathrm{x}, \\mathrm{y}, \\mathrm{z})}{\\mathrm{p}(\\mathrm{y}, \\mathrm{z})} \\\\ =\\frac{\\mathrm{p}(\\mathrm{x}, \\mathrm{y}, \\mathrm{z})}{\\mathrm{p}(\\mathrm{y} \\mid \\mathrm{z}) \\mathrm{p}(\\mathrm{z})} \\\\ =\\frac{\\mathrm{p}(\\mathrm{x}, \\mathrm{y}, \\mathrm{z}) \\mathrm{p}(\\mathrm{x}, \\mathrm{z})}{\\mathrm{p}(\\mathrm{y} \\mid \\mathrm{z}) \\mathrm{p}(\\mathrm{z}) \\mathrm{p}(\\mathrm{x}, \\mathrm{z})} \\\\ \\because \\frac{\\mathrm{p}(\\mathrm{x}, \\mathrm{y}, \\mathrm{z})}{\\mathrm{p}(\\mathrm{x}, \\mathrm{z})}=\\mathrm{P}(\\mathrm{y} \\mid \\mathrm{x}, \\mathrm{z}), \\frac{\\mathrm{p}(\\mathrm{x}, \\mathrm{z})}{\\mathrm{p}(\\mathrm{z})}=\\mathrm{P}(\\mathrm{x} \\mid \\mathrm{z}) \\\\ \\therefore \\mathrm{p}(\\mathrm{x} \\mid \\mathrm{y}, \\mathrm{z})=\\frac{\\mathrm{p}(\\mathrm{y} \\mid \\mathrm{x}, \\mathrm{z}) \\mathrm{p}(\\mathrm{x} \\mid \\mathrm{z})}{\\mathrm{p}(\\mathrm{y} \\mid \\mathrm{z})} \\end{array}\\) \\(p(x)=\\int p(x \\mid y) p(y) d y\\) \\(p(x \\mid y)=\\frac{p(x, y)}{p(y)}\\) 推导 前提：正确初始化初始时刻 \\(t=0\\) 的置信度 \\(bel(x_0)\\) 。 \\(\\begin{array}{l} \\operatorname{bel}\\left(x_{t}\\right)\\\\ =p\\left(x_{t} \\mid z_{t}, z_{1: t-1}, u_{1: t}\\right)\\\\ =p\\left(z_{t} \\mid x_{t}, z_{1: t-1}, u_{1: t}\\right) \\cdot p\\left(x_{t} \\mid z_{1: t-1}, u_{1: t} \\right) \\cdot (p\\left(z_{t} \\mid z_{1: t-1}, u_{1: t}\\right))^{-1}\\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}, z_{1: t-1}, u_{1: t}\\right) \\cdot p\\left(x_{t} \\mid z_{1: t-1}, u_{1: t}\\right) \\end{array}\\) 如果状态 $x_t $ 能很好的预测未来，那么就说状态 \\(x_t\\) 是完备complete的。状态的完备性意味着历史状态、测量值以及控制量都不再能够提供使我们更准确预测未来的额外信息。 关于完备性的定义并不要求未来是状态的一个确切的函数。未来是随机的，但除了状态 \\(x_t\\)，之前的任何状态都不能对未来产生影响。 满足这一特性的过程就是人们常说的马尔可夫链Markov chains。 若状态 \\(x_t\\) 是完备complete的，有： \\(p\\left(z_{t} \\mid x_{t}, z_{1: t-1}, u_{1: t}\\right)=p\\left(z_{t} \\mid x_{t}\\right)\\) 即， \\(\\begin{array}{l} \\operatorname{bel}\\left(x_{t}\\right)\\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot p\\left(x_{t} \\mid z_{1: t-1}, u_{1: t}\\right)\\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\overline{b e l}(x_t)\\\\ \\begin{array}{l} =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\frac{p\\left(x_{t} \\cdot z_{1: t-1} \\cdot u_{1: t}\\right)}{p\\left(z_{1: t-1} \\cdot u_{1: t}\\right)}\\\\ \\begin{array}{l} =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\frac{\\int_{x_{t-1}} p\\left(x_{t} \\cdot z_{1: t-1} \\cdot u_{1: t} \\mid x_{t-1}\\right) \\cdot p\\left(x_{t-1}\\right) d x_{t-1}}{p\\left(z_{1: t-1} \\cdot u_{1: t}\\right)} \\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\frac{\\int_{x_{t-1}} p\\left(x_{t} \\cdot z_{1: t-1} \\cdot u_{1: t} \\cdot x_{t-1}\\right) d x_{t-1}}{p\\left(z_{1: t-1} \\cdot u_{1: t}\\right)} \\end{array}\\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\int_{x_{t-1}} \\frac{p\\left(x_{t} \\cdot z_{1: t-1} \\cdot u_{1: t} \\cdot x_{t-1}\\right)}{p\\left(z_{1: t-1} \\cdot u_{1: t} \\cdot x_{t-1}\\right)} \\cdot \\frac{p\\left(z_{1: t-1} \\cdot u_{1: t} \\cdot x_{t-1}\\right)}{p\\left(z_{1: t-1} \\cdot u_{1: t}\\right)} d x_{t-1}\\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\int_{x_{t-1}} p\\left(x_{t} \\mid x_{t-1}, z_{1: t-1}, u_{1: t}\\right) \\cdot p\\left(x_{t-1} \\mid z_{1: t-1}, u_{1: t}\\right) d x_{t-1}\\\\ \\end{array} \\end{array}\\) 全概率公式 P(x)=∫P(x|y)P(y)dy 贝叶斯公式 P(x|y)=P(xy) / P(y) 因为假设了状态具有完备性，所以如果我们知道了 $x_{t-1} $ ，过去的观测量和控制量将不携带关于状态 \\(x_t\\) 的信息。因此，有： \\(p\\left(x_{t} \\mid x_{t-1}, z_{1: t-1}, u_{1: t}\\right)=p\\left(x_{t} \\mid x_{t-1}, u_{t}\\right)\\) 且，考虑到t时刻的控制量 \\(u_t\\) 与t-1时刻的状态 \\(x_{t-1}\\) 无关，则： \\(\\begin{array}{l} \\operatorname{bel}\\left(x_{t}\\right)\\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\int_{x_{t-1}} p\\left(x_{t} \\mid x_{t-1}, u_{t}\\right) \\cdot p\\left(x_{t-1} \\mid z_{1: t-1}, u_{1: t}\\right) d x_{t-1}\\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\int_{x_{t-1}} p\\left(x_{t} \\mid x_{t-1}, u_{t}\\right) \\cdot p\\left(x_{t-1} \\mid z_{1: t-1}, u_{1: t-1}\\right) d x_{t-1}\\\\ =\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\cdot \\int_{x_{t-1}} p\\left(x_{t} \\mid x_{t-1}, u_{t}\\right) \\cdot b e l\\left(x_{t-1}\\right) d x_{t-1} \\end{array}\\) 结论 \\(\\begin{array}{l} \\overline{\\operatorname{bel}}\\left(x_{t}\\right)=\\int p\\left(x_{t} \\mid x_{t-1},u_{t}\\right) \\text { bel }\\left(x_{t-1}\\right) d x_{t-1} \\\\ \\operatorname{bel}\\left(x_{t}\\right)=\\eta \\cdot p\\left(z_{t} \\mid x_{t}\\right) \\overline{\\operatorname{bel}}\\left(x_{t}\\right) \\end{array}\\)","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"}]},{"title":"2006-slam-review","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/paper/2006-slam-review/","text":"Part I The Essential Algorithms 0、摘要 本教程介绍了同时定位和建图(SLAM)，以及在过去十年中对SLAM进行的广泛研究。SLAM是移动机器人可以构建环境地图，同时使用该地图来计算其自身位置的过程。在过去的十年里，在解决SLAM问题和许多令人信服的SLAM方法的实现方面，已经取得了快速而令人兴奋的进展。本教程的第一部分（本文），描述了SLAM问题的概率形式、基本的解决方法和重要的实现。本教程的第二部分将关注大规模和复杂环境的SLAM问题的最新进展和新公式。 1、介绍 SLAM问题：移动机器人被放置在未知环境中的未知位置，然后逐步构建环境一致地图，同时确定自己在该地图中的位置。因为SLAM问题的解决方案将提供使机器人真正自主的手段，因此被视为移动机器人社区的“圣杯”。 SLAM问题的“解决方案”是过去十年机器人社区的显著成果之一。SLAM问题已经通过许多不同形式的理论所表述和解决。SLAM也在许多不同的领域实现，从室内机器人，到室外、水下和空中系统。在理论和概念层面上，SLAM现在可以被认为是一个已解决的问题。然而，在实际实现更通用的SLAM解决方案方面，特别是在构建和使用感知丰富的地图作为SLAM算法的一部分方面，仍然存在实质性的问题。 第一部分结构： 第二节首先提供了SLAM早期发展的简要历史 第三节介绍了现在的标准贝叶斯形式的SLAM问题的结构，并解释了SLAM过程的演变 第四节描述了SLAM问题的两个关键计算解决方案：通过使用扩展卡尔曼滤波器(EKF-SLAM)和Rao布莱威尔德粒子滤波器(RaoBlackwellised particle fifilters FastSLAM)。其他最近（相对于2006年而言）的解决方案将在的第二部分中讨论 第五节描述了SLAM的一些重要的现实实现，强调了那些可以供学者自由下载和研究的传感器数据和软件 本教程的第二部分描述了SLAM中计算、收敛性和数据关联中的主要问题。在过去的五年里，这些主题一直是SLAM研究社区的主要焦点。 2、SLAM早期历史 2.1 起源 SLAM问题起源于1986年在旧金山举行的IEEE机器人和自动化会议上。这时，概率方法才刚刚开始被引入机器人技术和人工智能。许多研究人员一直在研究将估计理论的方法应用于建图和定位问题；这些人包括彼得·切斯曼、吉姆·克劳利和休·杜兰特-怀特。在会议过程中，充满了关于一致建图的长期讨论。在这个过程中，拉贾·查蒂拉、奥利弗·弗杰拉斯、兰德尔·史密斯和其他人也为这次对话做出了有用的贡献。 2.2 发展受阻 这次对话的结果是认识到一致概率建图是机器人技术中的一个基本问题。在接下来的几年里，人们产生了一些关键的论文。史密斯和切斯曼[39]和Durrant-Whyte[17]的工作为描述地标和操纵几何不确定性之间的关系建立了一个统计基础。这项工作的一个关键要素表明了地图中不同地标的位置的估计之间一定有高度的相关性，而这些相关性确实会随着连续的观测而增长。 与此同时，阿亚奇和福杰拉斯[1]正在从事早期的视觉导航工作，Crowley[9]和Chatila和Laumond[6]正在使用卡尔曼滤波型算法进行移动机器人基于声纳的导航。这两股研究有很多共同点，不久之后就在史密斯、赛尔夫和芝士曼[40]的具有里程碑意义的论文中发表。这篇论文表明：当移动机器人在未知环境中对地标进行相对观察时，由于估计机器人位置[27]的共同误差，对这些地标的估计也都必然相互相关。这一点的含义是深远的，这说明全局一致定位与建图问题的解决方案将由机器人姿态和每一个地标位置组成联合状态，在每个地标观察之后更新。反过来说，这将需要估计器使用一个巨大的状态向量（在地图中维护地标的数量顺序），计算规模也将是地标数量的平方级。 至关重要的是，这项工作并没有研究地图的收敛特性或其稳态行为。事实上，当时人们普遍认为，地图估计的误差不会收敛，而是会表现出具有无限误差增长的随机游走行为。因此，出于定位问题的计算复杂性以及对地图的敛散性的无知，研究人员反而专注于一系列近似一致的建图问题解决方案，这些方案假设甚至强制使地标之间的相关性最小化，把完整的滤波器filter简化成了机器人filter上一系列解耦的地标landmarks（例如[28]，[38]）。同样出于这些原因，关于同步结合定位和建图问题的理论工作暂时停止，工作通常集中在定位或建图的独立问题上。 2.3 理论突破 随着意识到同步结合定位和建图问题一旦被表述为一个单一的估计问题实际是收敛的，理论上也就出现了突破。最重要的是，人们认识到，大多数研究人员试图最小化的地标之间的相关性实际上是问题的关键部分，相反，这些相关性增长得越多，解决方案就越好。在1995年[16]机器人研究国际研讨会上发表的一篇移动机器人调查论文中，有关SLAM问题的结构、收敛结果和“SLAM”缩写等首次亮相。Csorba[11]，[10]提出了关于收敛的基本理论和许多初步结果。已经有几个在地图和定位方面工作的小组，特别是在麻省理工学院的[29]、萨拉戈萨[5]，[4]、悉尼[20]的ACFR、[45]以及其他人[7]，[13]，开始认真研究SLAM在室内、室外和海底环境中的应用。 2.4 理论改进 此时，工作集中于提高计算效率和解决数据关联或“回路闭环”中的问题。1999年的机器人研究国际研讨会(ISRR‘99)[23]是一个重要的会议点，在这里举行了第一次SLAM会议，并在基于卡尔曼滤波器的SLAM方法与Thrun[42]引入的概率定位和建图方法之间实现了一定程度的收敛性。2000年IEEEICRA关于SLAM的研讨会吸引了15名研究人员，并重点关注了算法复杂性、数据关联和实现挑战等问题。接下来在2002年ICRA举办的SLAM研讨会吸引了150名具有广泛兴趣和应用的研究人员。2002年，由斯德哥尔摩的亨里克·克里斯汀森在KTH举办的大满贯夏季学校吸引了所有关键研究人员和来自世界各地的大约50名博士生，在建设该领域方面取得了巨大的成功。近年来，人们对SLAM的兴趣呈指数级增长，研讨会继续在ICRA和IROS举行。SLAM暑期学校也于2004年在托卢斯，2006年在牛津大学开办。 3、SLAM公式和结构 SLAM是指移动机器人可以构建环境地图，同时使用此地图来推断其自身位置的一个过程。在SLAM中，平台的轨迹和所有地标的位置都是在线估计的，其不需要任何先验的位置知识。 3.1 前期 考虑一个移动机器人在一个环境中移动，使用位于机器人上的传感器对一些未知地标进行观测，如下图所示。在时间时刻 $ k$ ，定义以下变量： $ x_{k} $：状态向量，描述机器人在时间 $ k$ 时的位置和姿态的向量 $ u_{k} $：控制向量，驱动机器人由 $ k-1$ 时刻 $ x_{k-1}$ 姿态 至 $ k$ 时刻 $ x_{k}$ 姿态 $ m_{i}$：描述第 $ i^{th}$ 个地标位置的向量，其真实位置假设为时不变的 $ z_{ik}$：机器人在 $ k$ 时刻\"观测\"到第 $ i^{th}$ 个地标时产生的观测数据（当任意时刻有多个地标被观测到或当特定地标与此次讨论discussion无关时，观测数据被简写为 $ z_{k}$ ） 此外，还定义了以下集合： \\[ \\mathbf{X}_{0: k}=\\left\\{\\mathbf{x}_{0}, \\mathbf{x}_{1}, \\cdots, \\mathbf{x}_{k}\\right\\}=\\left\\{\\mathbf{X}_{0: k-1}, \\mathbf{x}_{k}\\right\\}：机器人轨迹历史 \\] \\[ \\mathbf{U}_{0: k}=\\left\\{\\mathbf{u}_{1}, \\mathbf{u}_{2}, \\cdots, \\mathbf{u}_{k}\\right\\}=\\left\\{\\mathbf{U}_{0: k-1}, \\mathbf{u}_{k}\\right\\}：控制输入历史 \\] \\[ \\mathbf{m}=\\left\\{\\mathbf{m}_{1}, \\mathbf{m}_{2}, \\cdots, \\mathbf{m}_{n}\\right\\} ：路标集合 \\] \\[ \\mathbf{Z}_{0: k}=\\left\\{\\mathbf{z}_{1}, \\mathbf{z}_{2}, \\cdots, \\mathbf{z}_{k}\\right\\}=\\left\\{\\mathbf{Z}_{0: k-1}, \\mathbf{z}_{k}\\right\\}：所有的路标观测集合 \\] 3.2 概率SLAM ​ 在概率形式中，同时定位和地图构建(SLAM)问题要求计算所有时间 $ k$ 的概率分布： \\[ P\\left(\\mathbf{x}_{k}, \\mathbf{m} \\mid \\mathbf{Z}_{0: k}, \\mathbf{U}_{0: k}, \\mathbf{x}_{0}\\right) \\] 这种概率分布描述了地标位置 $ m$ 和机器人位姿 $ x_{k}$ (在时间 $ k$ 时 )的联合后验密度（后验：其实也就是知道了控制输入和观测数据的结果，反过来推测地标和位姿），给定传感器记录的观测数据集合 $ {0: k}$和从时间 $ 0$ 到 $ k$ 的控制输入历史 $ U{0:k}$，以及机器人的初始位姿 $ x_{0}$ 。一般来说，对SLAM问题的递归解是可取的：从时刻 $ k-1$ 的分布 $ P({k-1}, {0: k-1}, {0: k-1})$ 开始，根据控制 $ u{k} $ 和观测数据 $ z_{k} $ ，用贝叶斯定理进行计算。该计算需要定义一个运动模型（state transition model）和一个观测模型（observation model），分别描述控制输入和观测数据的影响。 观测模型描述了在知道机器人位姿和地标位置时观测 $ z_{k} $ 的概率，并且通常以下式进行描述： \\[ P\\left(\\mathbf{z}_{k}\\mid \\mathbf{x}_{k},\\mathbf{m}\\right) \\] 可以合理地假设，一旦定义了机器人的位姿和地标集，那么给定地图和当前的机器人位姿，观测结果是有条件地相互独立（independent）的。 运动模型可以用状态转换形式的概率分布来描述： \\[ P\\left(\\mathbf{x}_{k}\\mid \\mathbf{x}_{k-1},\\mathbf{u}_{k}\\right) \\] 也就是说，状态转换被假设是一个马尔可夫过程，其下一个状态 $ x_{k}$ 只依赖于立即进行的状态 $ x_{k-1}$ 和所应用的控制向量 $ u_{k}$ ，并且独立于观测结果和地标。 SLAM算法现在以标准的有序两步递归：预测（时间更新）+ 校正（测量更新）形式实现： 时间更新（运动模型） \\[ \\begin{array}{l} P\\left(\\mathbf{x}_{k}, \\mathbf{m} \\mid \\mathbf{Z}_{0: k-1}, \\mathbf{U}_{0: k}, \\mathbf{x}_{0}\\right) \\\\ =\\int P\\left(\\mathbf{x}_{k} \\mid \\mathbf{x}_{k-1}, \\mathbf{u}_{k}\\right) \\times P\\left(\\mathbf{x}_{k-1}, \\mathbf{m} \\mid \\mathbf{Z}_{0: k-1}, \\mathbf{U}_{0: k-1}, \\mathbf{x}_{0}\\right) \\mathrm{d} \\mathbf{x}_{k-1} \\end{array} \\] 测量更新（观测模型） \\[ \\begin{array}{l} P\\left(\\mathbf{x}_{k}, \\mathbf{m} \\mid \\mathbf{Z}_{0: k}, \\mathbf{U}_{0: k}, \\mathbf{x}_{0}\\right) \\\\ =\\frac{P\\left(\\mathbf{z}_{k} \\mid \\mathbf{x}_{k}, \\mathbf{m}\\right) P\\left(\\mathbf{x}_{k}, \\mathbf{m} \\mid \\mathbf{Z}_{0: k-1}, \\mathbf{U}_{0: k}, \\mathbf{x}_{0}\\right)}{P\\left(\\mathbf{z}_{k} \\mid \\mathbf{Z}_{0: k-1}, \\mathbf{U}_{0: k}\\right)} \\end{array} \\] 两个等式提供了一个递归程序，用于计算机器人位姿 $ x_{k}$ 和 $ x_{k}$ 在时间 $ k$ 上的联合后验概率 $ P({k}, {0: k}, {0: k}, {0})$。 值得注意的是，建图问题可以表述为计算条件密度： \\[ P\\left(\\mathbf{m} \\mid \\mathbf{X}_{0: k}, \\mathbf{Z}_{0: k}, \\mathbf{U}_{0:k}\\right) \\] 这假设机器人 $ x_{k}$ 的位置在服从初始位置的知识上，一直以来都是已知的（或至少是确定性的）。然后通过融合来自不同位置的观测结果来构造一个地图 $ $。 反之，定位问题可以表述为计算概率分布： \\[ P\\left(\\mathbf{x}_{k} \\mid \\mathbf{Z}_{0: k}, \\mathbf{U}_{0:k},\\mathbf{m}\\right) \\] 这假设地标位置是确定已知的，其目标是基于这些地标来计算机器人位置的估计。 3.3 概率SLAM的结构 为了简化本节中的讨论，我们将删除方程式 $ P({k}, {0: k}, {0: k}, {0})$ 中对历史变量的条件处理，并在上下文允许的情况下，将地标和机器人位姿上所需的联合后验写为 $ P({k}, {k})$ ，甚至写成$ P(_{k},)$ 。 观测模型 $ P({k}{k},)$ 明确说明了观测结果对机器人和地标位置两者的依赖性。由此可见，联合后验不能以如下所示的明显方式进行分割： \\[ P\\left(\\mathbf{x}_{k}, \\mathbf{m} \\mid \\mathbf{z}_{k}\\right) \\neq P\\left(\\mathbf{x}_{k} \\mid \\mathbf{z}_{k}\\right) P\\left(\\mathbf{m} \\mid \\mathbf{z}_{k}\\right) \\] 事实上，从关于一致建图[39]，[17]的早期论文中就知道，这样的分割会导致不一致的估计。然而，SLAM问题的结构比这些方程更明显。 再次参考3.1节的机器人位姿地标观测图，可以看出，估计地标和真实地标位置之间的共同误差在地标之间很常见，而且误差的来源比较单一；在机器人进行地标位置的观测时，误差就产生了。反过来说，这意味着地标位置估计中的误差是高度相关的。实际上，这意味着任何两个地标之间的相对位置，如 $ {i}-{j}$ ，可以高精度的测量，即使其中的一个地标（如$ {i}$）的绝对位置可能相当不确定。在概率形式中，这意味着即使边缘密度 $ P({i})$ 可能相当分散，但一对地标 $ P({i},{j})$ 的联合概率密度也会达到峰值。 在SLAM中最重要的认识是，随着越来越多的观察结果的出现，地标估计之间的相关性在单调增加。实际上，这意味着地标的相对位置的估计总是不断改善，永远不会发散，不管机器人的运动如何。在概率术语中，这意味着随着地标观测结果的增加，所有地标 $ P()$ 上的联合概率密度将单调地达到峰值。 这种收敛的原因是机器人的观测地标之间相对位置的是“几乎独立”的测量。再次参考3.1节的机器人位姿地标观测图，考虑机器人在位置 $ x_{k} $ 观察两个地标 $ {i}$ 和 $ {j}$ 。此时，观察到的地标的相对位置显然与机器人的坐标系无关，从这个固定位置进行的连续观测将产生进一步独立的地标之间的相对关系的测量。现在，当机器人移动到位置 $ x_{k+1} $ 时，它再次观察到地标 $ {j}$ ，这允许机器人和地标的估计位置相对于之前的位置 $ x{k} $ 进行更新。反过来，即使 $ {i}$ 地标没有从新的位置看到，信息也会传播回来，以此更新地标 $ {i}$ 。这是因为从之前的测量结果相比，这两个地标是高度相关的（它们的相对位置是已知的）。 此外，相同的测量数据被用来更新这两个地标，这一事实使它们更加具有相关性。术语“几乎独立”的测量是合适的，因为观测误差将通过连续的机器人运动相关联。还要注意，在图中位置 $ x_{k+1} $ 中，机器人观察到两个相对于 $ {j}$ 的新地标。这些新的地标也立即与地图的其他部分联系或相关。稍后更新这些地标时也将更新地标 $ {j}$ ，在更新到 $ _{i}$ 等等。也就是说，所有的地标最终都形成了一个由相对位置或相关性连接起来的网络，每当观察到它们时，其精度或值都会增加。 此过程可视为将所有地标连接在一起的弹簧网络，或者作为嵌入所有地标的橡胶板，如下图： 在某地附近的观测行为就像对弹簧系统或橡胶板的位移，因此它在某地附近的效果很大，并且依赖于局部刚度（相关性）特性，效果又随着与其他地标的距离增大而减小。当机器人在这个环境中移动并观察地标时，弹簧将变得越来越（而且单调地）坚硬。在观测次数极多至极限条件下，就得到了刚性的地标图或准确的相对环境图。在构建地图时，机器人相对于地图测量的位置精度仅受地图质量和相对测量传感器的限制。在理论极限下，机器人的相对位置精度等于给定地图所可实现的定位精度。 4、SLAM解决方案 概率SLAM问题的解决方案包括为观测模型方程（6）和运动模型方程（7）寻找一个适当的表示，该表示允许有效和一致地计算方程（8）和（9）中的先验分布和后验分布。 到目前为止，最常见的表示形式是具有加性高斯噪声的状态空间模型，由此便有了使用扩展的卡尔曼滤波器(EKF)来解决4.1节的SLAM问题； 一个重要的替代表示形式是将方程式（7）中的运动模型描述为一组更一般的非高斯概率分布的样本，这导致了使用 Rao-Blackwellised粒子滤波器或FastSLAM算法 来解决4.2节中所述的SLAM问题。 虽然EKF-SLAM和FastSLAM是两种最重要的解决方法，但较新的替代方案也提供了很大的潜力，包括使用信息状态形式的[43]。本教程的第二部分将进一步讨论这些问题。 4.1 EKF-SLAM 待看 4.2 Rao-Blackwellised 滤波器 待看 5、SLAM的实现 近年来，概率SLAM的实际实现越来越令人印象深刻，其在更具有挑战性的环境中覆盖了更大的领域。在这里，我们将讨论两个有代表性的实现，并提到了其他值得注意的应用程序。 待看 6、结论 本文描述了SLAM问题，解决SLAM问题的基本方法，并总结了方法的关键实现和演示。虽然还有许多实际问题需要克服，特别是在更复杂的户外环境中。一般的SLAM方法现在是机器人技术的一个被充分理解和确立的一部分。本教程的第二部分将总结最近解决SLAM中一些剩余问题的工作，包括；计算、特征表示和数据关联。 7、PDF原文","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"paper","slug":"robot/paper","permalink":"https://silencht.github.io/categories/robot/paper/"}]},{"title":"2016-slam-review","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/paper/2016-slam-review/","text":"1. SLAM概念 1.1 SLAM是什么？ 同时定位与地图构建（英语：Simultaneous localization and mapping，一般直接称SLAM）是一种概念： 希望机器人从未知环境的未知地点出发，在运动过程中通过重复观测到的地图特征（比如，墙角，柱子等）定位自身位置和姿态，再根据自身位置增量式的构建地图，从而达到同时定位和地图构建的目的。 localization：我在什么地方？——定位 mapping：周围环境什么样子？——建图 simultaneous：先做什么？——同时 simultaneous map building and localization can be seen to present a question of which came fifirst, the chicken or the egg? (The map or the motion?) starting from the unknown location of the unknown environment, the robot locates its own position and attitude through repeated observation of environmental features in the movement process, and then builds an incremental map of the surrounding environment according to its own position, so as to achieve the purpose of simultaneous positioning and map construction. 同时建立地图和定位可以被视为一个是先有鸡还是先有蛋的问题。 从未知环境的未知地点出发，通过运动过程中对环境特征的反复观察，定位自身位置和姿态，然后根据自身位置来构建周围环境的增量地图，实现 同时 定位和地图构造的目的。 SLAM问题的本质：对运动主体自身和周围环境空间不确定性的估计 1.2 SLAM用在哪？ 1.2.1 适用场景 SLAM finds applications in all scenarios in which a prior map is not available and needs to be built. 那些没有办法构建先验地图且需要构建地图的所有场景。 1.2.2 不适用场景 SLAM may not be required if localization can be done reliably with respect to the known landmarks. 那些能依靠已知地标进行有效定位的场景。 1.3 SLAM为何兴起？ The popularity of the SLAM problem is connected with the emergence of indoor applications of mobile robotics. 与室内移动机器人的兴起息息相关。 The popularity of SLAM in the last 30 years is not surprising if one thinks about the manifold aspects that SLAM involves. At the lower level (called the front-end ) SLAM naturally intersects other research fifields such as computer vision and signal processing; At the higher level (that we later call the back-end ), SLAM is an appealing mix of geometry, graph theory, optimization, and probabilistic estimation. 如果考虑到SLAM涉及的多方面问题，那么它在这三十年的流行也就不足为奇。 从低层次，即SLAM前端来说，它与计算机视觉和信号处理等领域很自然的交叉作用； 从高层次，即SLAM后端来说，它是一个吸引人的几何、图论、优化和概率估计的组合。 1.4 SLAM有研究意义吗？ 1.4.1 自动机器人需要SLAM吗？ 1.4.1.0 引言 SLAM aims at building a globally consistent representation of the environment, leveraging both ego-motion measurements and loop closures. The keyword here is “loop closure”: if we sacrififice loop closures, SLAM reduces to odometry. In early applications, odometry was obtained by integrating wheel encoders. The pose estimate obtained from wheel odometry quickly drifts, making the estimate unusable after few meters. SLAM旨在利用自我运动测量和闭环检测来构建整体一致的环境表示。这里的关键词是“闭环检测”：如果我们丢弃闭环检测，那么SLAM将会退化为里程测量 / 里程计。在早期的应用中，可以通过积分车轮编码器来获得里程。然而，从车轮里程测量所获得的姿态估计快速漂移，使得估计数在短短几米之内就不可用。 A. Kelly. Mobile Robotics: Mathematics, Models, and Methods . Cambridge University Press, 2013. this was one of the main thrusts behind the development of SLAM: the observation of external landmarks is useful to reduce the trajectory drift and possibly correct it. 这个是SLAM发展背后的主要推动力之一：对于外部地标的观测有助于减少轨迹漂移并可能纠正之。 P. Newman, J. J. Leonard, J. D. Tardos, and J. Neira. Explore and Return: Experimental Validation of Real-Time Concurrent Mapping and Localization. In Proceedings of the IEEE International Conferenceon Robotics and Automation (ICRA), pages 1802–1809. IEEE, 2002. However, more recent odometry algorithms are based on visual and inertial information, and have very small drift (&lt; 0.5% of the trajectory length). 然而，很多最近的基于视觉和惯性信息的测速方法漂移越来越小。 C. Forster, L. Carlone, F. Dellaert, and D. Scaramuzza. On-Manifold Preintegration for Real-Time Visual–Inertial Odometry. IEEE Transactions on Robotics (TRO), PP(99):1–21, 2016. 那么问题来了， 我们真的还需要SLAM这个算法吗？ 答案有三方面 1.4.1.1 Odometry就是SLAM的一部分 视觉-惯性导航（VIN）就是一个简化版SLAM ​ 首先，在过去十年的SLAM发展中，研究本身就产生了基于视觉-惰性测量算法，这种算法目前代表了最先进的水平[163,175]。在这种意义上，视觉-惯性导航（visual-inertial navigation）就是SLAM：VIN可以被看作一个简化版SLAM系统，只不过这个系统的闭环检测（loop closure）或者位置识别（place recongnition）模块没有开启。 ​ 更一般的，SLAM直接导致了在相比以前文献（如航空航天工程中的惰性导航）更有挑战性的设置下（如没有GPS,低质量传感器等）关于传感器融合的研究。 1.4.1.2 Odometry 和 Loop Closure 缺一不可 单纯的里程计会无限探索新区域，加入位置识别有助于理解环境真实拓扑 第二个回答是关于环境的真实拓扑结构（true topology）的。一个只运行里程计（odometry）而关闭闭环检测（loop closure）的机器人会将世界解释为一个“无限走廊（infinite corridor）”，在这个“走廊”里，机器人一直保持着探索未定义的新区域，如图1左侧。回路闭环事件会通知机器人这个走廊与它自身发生相交（intersect），如图1右侧。闭环检测的优势现在开始变得清晰：加入闭环检测后，机器人可以理解环境的真实拓扑，也就有能力找到位置之间的最短路径（比如地图上的点B和点C）。 图1 图一：左图：利用里程计构建的地图。这个地图可看作是一条从起始位置 A 到最终位置 B的一条长走廊。在现实中实际距离很近的点（例如 B和 C）可能在测距图（odometric map）中是任意远的。右图：利用 SLAM构建的地图。通过充分利用回路闭环（loop closures），SLAM可以估计环境的实际拓扑结构（topology）并在地图中发现（discovers）最短路径（shortcuts）。 单纯的位置识别有可能被位置不同而场景相似的数据关联所欺骗 ​ 那么，既然获得正确的环境拓扑是SLAM的优点之一，那为什么不简单删掉度量信息（metric information）就只做位置识别呢？答案很简单：度量信息可以使得位置识别更简单和鲁棒；度量的重建会通知机器人有关闭环检测的机会，并允许丢弃虚假的回路闭环[150]。因此，尽管SLAM在原理上可能是冗余的（一个甲骨文位置识别模块足以胜任构建拓扑地图），但是SLAM（中的度量信息）为那些错误的数据关联和感知混叠提供了自然的防御（此时，对于环境中的实际位置不同而场景却相似的情况将不会欺骗到位置识别）。 ​ 从这个意义上来说，SLAM地图提供了一种既预测又验证未来测量结果的方法：我们相信这个机制将是机器人稳定运行的关键。 1.4.1.3 在要求全局一致地图中，SLAM是必须的 ​ 对于许多无论是内在还是外在需求全局一致（globally consistent）的地图（map）来说，SLAM是必需的。例如，在许多军用和民用应用中，机器人的目标是探索一个（未知）环境，然后向人类操作员报告一张确保全覆盖该环境的地图。另外一个例子是，机器人必须可以（对建筑、桥梁等）进行结构性检查；同样，在这种情况下，一个全局一致的三维重建是获得成功的需要。 1.4.2 SLAM在学术上已经被解决了吗？ ​ 这个问题很难回答。因为SLAM已经成为一个很广泛的话题，所以这个问题适合在 给定的 机器人/环境/性能 三者组合的情况下 提问。 1.4.2.1 比较成熟的领域：提高系统的精度、鲁棒性 配备 车轮编码器和激光扫描仪 的构建 二维地图 的 室内机器人已经有了相当的精度（&lt;10cm）和足够的鲁棒性（如低故障率），可以被认为在很大程度上已经得到解决； 配备 基于视觉SLAM 的 缓慢移动机器人（例如火星漫游者、家用机器人等），以及视觉惯性里程计（visual-inertial odometry）可以被视为是比较成熟的领域； 1.4.2.2 尚不成熟的领域：高速时失效 当机器人的 运动 或者 所处环境 具有挑战性的时候，SLAM算法很容易失效。例如，快速机器人动力学 、 高度动态的环境； SLAM算法往往无法满足严格性能要求场合。例如，快速闭环控制下的高速率估计（high rate estimation for fast closed-loop control） 如何平衡实时性和准确性是一个问题； 有关动态、非结构化、复杂、不确定和大规模的环境的解决方案仍有待探索； 1.5 视觉SLAM的相机决策 相机 优点 缺点 单目相机 结构简单，成本特别低 平移之后才能计算深度，无法确定真实尺度 双目相机 克服了单目相机的缺点 配置与标定较为复杂，深度量程和精度受双目基线与分辨率所限，视差计算非常消耗计算资源 深度相机 相比双目相机节省大量计算资源 测量范围窄、噪声大、视野小、易受日光干扰、无法测量透射材质等。主要用于室内，室外较难应用。 事件相机 相比传统相机具有更小的时间延迟，更快的更新速率、更强的动态范围、更低的功耗和更小的存储空间要求。有望成为继深度相机后的新型视觉传感器 完全依赖于场景动态,低动态环境下性能反而不如传统相机 2. SLAM的发展阶段 2.1 1986—2004：classical age（古典时期） 2.1.1 研究内容 the introduction of the main probabilistic formulations for SLAM , including approaches based on Extended Kalman Filters, Rao-Blackwellised Particle Filters, and maximum likelihood estimation. 引入了SLAM主要的概率公式，其中包括 扩展卡尔曼滤波、粒子滤波 和 最大似然估计 2.1.2 论文 A thorough historical review of the first 20 years of the SLAM problem 详细论述SLAM发展前二十年的review H. F. Durrant-Whyte and T. Bailey. Simultaneous Localisation and Mapping (SLAM): Part I. IEEE Robotics and Automation Magazine, 13(2):99–110, 2006. T. Bailey and H. F. Durrant-Whyte. Simultaneous Localisation and Mapping (SLAM): Part II. Robotics and Autonomous Systems (RAS), 13(3):108–117, 2006. Two other excellent references describing the three main SLAM formulations of the classical age 描述三大SLAM主要公式的论文 S. Thrun, W. Burgard, and D. Fox. Probabilistic Robotics. MIT Press,2005. C. Stachniss, S. Thrun, and J. J. Leonard. Simultaneous Localization and Mapping. In B. Siciliano and O. Khatib, editors, Springer Handbook of Robotics, chapter 46, pages 1153–1176. Springer, 2nd edition, 2016. 2.1.3 挑战 the basic challenges connected to efficiency and robust data association. 效率和鲁棒的数据关联的挑战 。 2.2 2004—2015：algorithmic-analysis age（算法分析时期） 2.2.1 研究内容 the study of fundamental properties of SLAM, including observability, convergence, and consistency. In this period, the key role of sparsity towards effificient SLAM solvers was also understood, and the main open-source SLAM libraries were developed. 研究SLAM的基本特性，包括可观测性、收敛性和一致性。在这一时期，（人们）理解了对SLAM的高效率解决器？起到关键作用的稀疏性，并开发了主要的开源SLAM库。 2.2.2 论文 partially covered 覆盖部分该时期内容的review G. Dissanayake, S. Huang, Z. Wang, and R. Ranasinghe. A review of recent developments in Simultaneous Localization and Mapping. In International Conference on Industrial and Information Systems*, pages 477–482. IEEE, 2011. 2.2.3 挑战 2.3 2015—至今：robust-perception age（稳健感知时期） 2.3.1 研究内容 2.3.1.1 稳健的性能 the SLAM system operates with low failure rate for an extended period of time in a broad set of environments; the system includes fail-safe mechanisms and has self-tuning capabilities in that it can adapt the selection of the system parameters to the scenario. 系统在广泛的环境中长期运行且具有低故障率；系统包括故障-安全机制和自调整功能，可以针对适应场景修改参数。 2.3.1.2 高级的理解 the SLAM system goes beyond basic geometry reconstruction to obtain a high-level understanding of the environment 系统超越基本的几何重建来获得对环境的更高级别的理解。（高级图形学、语义学、物理学、affordances） 2.3.1.3 资源意识 the SLAM system is tailored to the available sensing and computational resources, and provides means to adjust the computation load depending on the available resources 系统针对可用传感器与计算资源进行裁剪，提供根据可用资源调整计算负载的方法 2.3.1.4 任务驱动感知 the SLAM system is able to select relevant perceptual information and fifilter out irrelevant sensor data, in order to support the task the robot has to perform; moreover, the SLAM system produces adaptive map representations, whose complexity may vary depending on the task at hand 系统有 选择 相关感知信息 和 滤除 不相关传感数据 的能力 来支持机器人需要执行的任务。此外，系统产生自适应的根据手头任务不同而复杂性不同的地图表示。 2.3.2 论文 2.3.3 挑战 Visual SLAM still face some important obstacles like the illumination condition, high dynamic environment, fast motion, vigorous rotation and low texture environment. 视觉SLAM仍然面临着光照条件、高动态环境、运动快、旋转剧烈、低纹理环境等重要阻碍。 2.3.4 未来 基于智能手机、嵌入式平台（如无人机）的SLAM 详细的三维重建，使用深度学习的场景理解 多传感器融合问题 语义SLAM：还可以支持全局优化、闭环检测和重新定位；传统的SLAM依赖于点线面等几何特征来推断环境结构，而语义SLAM是使机器人像人类一样思考，从而在大规模场景中实现高精度实时定位的目标。 算法和传感器的深度融合，集成、专用的传感器将发挥出巨大的潜力 端到端 0.1 英文名词翻译/解释 metric 度量 semantic 语义 Semantic is used to describe things that deal with the meanings of words and sentences. pose 姿态，这里一般指机器人的位置和姿势 position and orientation topology 拓扑the way the parts of sth are arranged and related 3. PDF原文","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"paper","slug":"robot/paper","permalink":"https://silencht.github.io/categories/robot/paper/"}]},{"title":"orbslam1-translation","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/paper/orbslam1-translation/","text":"摘要 本文提出了ORB-SLAM，这是一种在大小场景、室内室外环境下都可以实时运行的基于特征的单目SLAM系统。系统对复杂的剧烈运动具有鲁棒性，允许宽基线的闭环和重定位，且包含完整的自动初始化。在最近几年的优秀算法基础上，我们从头开始设计了一种新颖的对包括追踪、建图、重定位、闭环所有SLAM任务在内都使用相同特征的系统。选择点和重建关键帧的适者生存策略具有很好的鲁棒性，并能够生成紧凑的可追踪的地图，只有当场景内容发生变化地图才改变，从而允许长时间运行。本文从最受欢迎的数据集中提供了27个序列的详尽评估。相对于其他最先进的单目SLAM方法，ORB-SLAM实现了前所未有的性能。为了造福社区，我们将源代码公开。 关键字：长期建图，定位，单目视觉，识别，同时定位和建图（SLAM） I. 引言 我们知道，在我们提供优质（strong）的匹配网络和良好的初始值预测的情况下，BA（bundle adjustment）方法可以给出相机定位的精确估计以及稀疏几何重建[1,2]。在很长一段时间内，在诸如VSLAM这种实时性应用中，BA方法（由于其理论算力的大开销）被认为是无法使用的。VSLAM的目标是在建图的同时估计相机的轨迹。如今我们知道，为了使BA计算成本在可承受范围内的同时还获得较为准确的结果，一个实时SLAM算法必须向BA提供以下信息： 在选定帧（关键帧）子集中场景特征（地图点）的相应观察 复杂性随着关键帧数量增长，关键帧的筛选要避免不必要的冗余 关键帧和地图点之间强大的网络配置用以产生准确的结果，也就是说关键帧中的观察到的地图点能够提供显著的视差以及足够的回环匹配 提供一个尽可能准确的用于BA非线性优化的关键帧位姿初始值 探索中的局部地图，优化的重点是具备更好的可扩展性（对于局部地图，优化只在局部进行而与全局尺寸无关） 可以实时进行快速全局优化（比如位姿图）以结束（close）闭环的能力 BA第一次实时应用是在Mouragon等人[3]提出的视觉里程计算法中，接着是Klein和Murray做出的突破性SLAM工作，其被称为并行追踪和建图（PTAM）[4]。尽管受制于小场景的应用，PTAM算法对关键帧的选择、特征匹配、点的三角化、每一帧的相机位姿估计、追踪失败后的重定位等提供了简单而有效的方法。不幸的是，缺少闭环检测和足够的对遮挡的处理（机制）、重定位的视图不变性差、在地图初始化时需要人工干预等因素严重限制了其应用。 在本文中，我们基于PTAM算法的主要框架，采用Gálvez-López和Tardós提出的place recognition（场景/位置识别）[5]算法，Strasdat等人提出的scale-aware loop closing（具备尺度感知的闭环检测）[6]算法以及文献[7]和[8]中的大尺度操作中共视（covisibility）信息的使用方法，重新设计了一种新的单目SLAM系统：ORB-SLAM，贡献主要包括： 对所有的任务采用相同的特征：追踪、地图构建、重定位和闭环检测。这使得我们的系统更有效率、简单可靠。采用的ORB特征[9]在没有GPU的情况下也有很好的实时性，且具有旋转不变性和光照不变性。 支持在大场景中实时运行。由于共视图（covisibility graph）的使用，特征点的跟踪与构图主要集中在局部共视区域，而与全局地图的尺寸无关。 使用一种我们称为Essential Graph的位姿图（pose graph）来优化位姿实现实时回环检测。它是由系统维护的生成树、闭环的链接和共视图（covisibility graph）的强边共同构建的。 实时相机重定位具有明显的旋转不变特性和光照不变性。这就使得跟踪丢失后可以恢复，增强了地图的重用性。 一种新的基于模型选择的自动和鲁棒的初始化程序，其允许创建平面和非平面场景的初始建图 提出了一种用来选择地图点和关键帧的“适者生存”方法：生成时放宽要求但剔除时提高要求。这种策略可以剔除冗余的关键帧，从而增强追踪的鲁棒性以及长时间运行的能力。 我们使用公共数据集对算法在室内和室外环境下的性能进行了评估，这些环境包括手持设备、汽车和机器人。值得一提的是，我们的方法与目前最优秀的直接SLAM算法[10]相比（直接SLAM算法直接通过对像素点的灰度进行优化而不是最小化特征重投影误差）能够实现更准确的摄像头定位。我们在文章的第IX-B部分还讨论了基于特征的SLAM算法比直接法更准确的可能原因。 闭环检测和重定位的方法是基于我们之前的工作[11]。系统最初的版本是论文[12]。本文中我们添加了初始化的方法、Essential graph、并完善了其他所有方法。我们详细描述了系统的各个板块，并且进行了详尽的实验验证。 据我们所知，这是目前最完整最可靠的单目SLAM系统。为了造福，我们将源代码开放。视频演示和源代码放在我们的项目网站上。 II. 相关工作 A、位置识别 Williams等人在综述[13]中比较了几种用于位置识别的方法，得出的结论是：基于外观的技术（即图像到图像的匹配）在大环境下大概率比地图到地图或图像到地图的方法更准确。在基于外观匹配的方法中，bags of words（词袋）[14]技术（比如概率方法FAB-MAP[15]算法）以高效率脱颖而出。DBoW2方法[5]首次使用了从BRIEF描述子[16]和非常高效的FAST特征检测算法[17]中获得的二进制词袋。与迄今为止用于词袋方法中的SURF[18]和SIFT[19]特征相比，这将特征提取所需的时间减少了一个数量级以上。尽管系统表现的非常高效和鲁棒，但采用不具有旋转不变性和尺度不变性的BRIEF描述子，系统被限制在只能运行在同一平面内（否则会造成尺度变化），闭环检测也只能从相似的视角中进行。在我们之前的工作[11]中，我们提出了一个使用ORB特征的DBoW2词袋位置识别器。ORB特征是具有旋转不变和尺度不变特性（在一定范围内）的二进制特征，因此，用它生成的快速识别器具有较好的视角不变性。我们在四个不同的数据集中证明了识别器的高召回率和鲁棒性：从10K图像数据库中提取一个候选闭环的运算时间少于39毫秒。在本文的工作中，我们提出了一种改进版本的采用共视（covisibility）信息的位置识别方法，其在检索数据库时返回几个假设情况而不仅仅是最好的匹配。 B、地图初始化 单目SLAM系统需要设计专门的程序来生成初始化地图，因为深度信息不可能从仅仅一幅图像中恢复出来。解决该问题的一个方法是一开始跟踪一个已知结构的对象[20]。而在使用滤波的方法中，可以用一个具有高不确定度的逆深度参数[21]来初始化点的深度信息，理想情况下该参数会在后期逐渐收敛到真值。最近Engel提出的半稠密方法[10]中就采用类似的方法将像素的深度信息初始化为一个具有高方差的随机值。 从两个视图的初始化方法要么假设局部场景平面性[4] [22]，并使用Faugeras等人的方法[23]从单应矩阵（homography）中恢复相对相机姿态，要么使用Nister[26]的五点算法（该方法存在多解的问题）计算一个建模了平面和一般场景的本质矩阵（essential matrix）[24] [25]（并利用本质矩阵恢复相对相机姿态）。这两种位姿重构方法在低视差下都没有很好的约束，如果平面场景内的所有点都过于接近摄像机中心之一，则结果会出现双重歧义[27]（twofold ambiguity solution）。另一方面，非平面场景可以通过线性8点算法[2]来计算一个唯一的基础矩阵（ fundamental matrix），相机的相对位姿就可以无歧义的恢复出来。 针对这一问题，我们在本文IV提出了一个新的基于模型选择的自动初始化方法，对平面场景算法选择单应性矩阵（homography），而对于非平面场景则选择基础矩阵（fundamental matrix）。模型选择的统计方法可参见Torr等人的论文[28]。基于类似的理论，我们设计了一种启发式初始化算法，算法会考虑到在接近退化情况（比如：平面，近似平面，或是低视差）下选择基础矩阵进行位姿估计存在的风险，则转而选择单应性计算。在平面的情况下，为了保险起见，如果最终解存在双重歧义则会避免进行初始化（因为可能会因为错误选择解而导致算法崩溃）。因此我们会延迟初始化过程，直到所选的模型在明显的视差下产生唯一的解。 C、单目SLAM 单目SLAM最初采用滤波方法[20],[21],[29],[30]来建模。在该类方法中，每一帧都通过滤波器联合估计地图特征位置和相机位姿。这样做带来的问题有：处理没什么新信息的连续帧图像时对计算资源的浪费、线性误差的累积。而另外一种SLAM方法是采用少数筛选过的图像（关键帧）来建图[3] [4]。因为建图不再与帧率相关联，因此基于关键帧的SLAM方法不但节省了计算资源，还可以进行高精度的BA优化。Strasdar等人在论文[31]中证明了在相同的计算成本上基于关键帧的方法比滤波方法结果更精确。 最具代表性的基于关键帧SLAM系统可能是由Klein和Murray等人提出的PTAM算法[4]。它第一次提出将相机追踪track和建图mapping拆分成两个并行的线程运行，并在小环境的实时增强现实应用中取得了成功。随后[32]在原始版本基础上改进了边缘特征，在跟踪过程中增加了旋转估计步骤，实现了更好的重定位方法。PTAM中的地图点通过图像区块与FAST角点匹配，这使得地图点仅适合于特征跟踪而不适合用于位置识别。实际上，PTAM算法并没有进行大闭环检测，其重定位也仅是基于关键帧低分辨率缩略图的相关性进行的，因此视角不变性较差。 Strasdat等人在论文[6]中提出了一个基于GPU实现的大尺度单目SLAM系统，该系统前端采用光流算法，其次用FAST特征匹配和仅运动（motion-only）BA；后端是基于滑动窗口（sliding-window）的BA。闭环检测通过具有相似性约束（7自由度）的位姿图（pose graph）优化来进行，该方法可以矫正在单目SLAM系统中出现的尺度偏移（scale drift）问题。在本文中，我们也将采用这种7自由度的位姿图优化方法，并将其应用到III-D节中定义的Essential Graph中。 Strasdat等人在文献[7]中采用了PTAM的前端，但其跟踪部分仅在一个从共视图（covisibility graph）提取的局部图（local map）中进行。他们提出了一个双窗口优化后端，在内部窗口中连续进行BA，在有限大小的外部窗口中构建位姿图。然而， 只有当外部窗口尺寸足够大到可以包含整个闭环的情况下，闭环检测才能起作用。在我们的系统中，我们采用了Strasdat等人提出的使用基于共视信息的局部地图并通过共视图来构建位姿图的优秀想法，但（实际是）将它们应用在（我们）完全重新设计的前端和后端里。另一个区别是，我们没有使用特别的特征做闭环检测（比如SURF），而是基于与追踪、建图相同的特征进行位置识别，因此获得了鲁棒的帧率重定位和闭环检测。 在Pirker等人的论文[33]中作者提出了CD-SLAM，这是一个非常完善的系统，它包括闭环检测，重定位，大尺度运行以及对动态环境运行所做的工作。但文中并没有提及地图初始化。（而且，）公共接口的缺乏使我们没法对其进行精确性、鲁棒性和大场景下能力的测试对比。 Song等人在论文[34]提出的视觉里程计方法中使用了ORB特征做追踪和一个短暂滑动窗口做BA后端。相比之下，我们的系统更加普适，因为他们（的系统中）没有涉及全局重定位、闭环检测，而且地图也不能复用。他们还使用了相机到地面的真实距离来限制单目SLAM算法的尺度漂移。 Lim等人在我们提交本文最初的版本[12]之后发表了论文[25]，他们也采用相同的特征进行跟踪、建图和闭环检测。但是，由于Lim等人的（对不具备尺度不变性）BRIEF描述子的选择，因此其系统运行受限在平面轨迹上。他们的系统仅从最后一帧关键帧跟踪特征点，因此访问过的地图不能复用（与视觉里程计很像），并且存在系统无限增长的问题。我们在VIII-E小节里面将我们的系统与该系统进行了定性比较。 Engel等人在最近的论文[10]里提出了LSD-SLAM，其可以构建大场景的半稠密地图。系统并没有采用使用特征点的BA方法，而是选择直接法（优化也是直接通过图像像素灰度进行）。系统结果让人印象深刻，其在没有GPU加速的情况下可以实时构建一个半稠密地图，相比基于特征点的SLAM系统输出的稀疏地图而言，LSD-SLAM方法在机器人领域有更大的应用潜力。然而，该系统的运行依旧需要基于特征点做闭环检测，且相机定位的精度也明显低于PTAM和我们的系统。相关实验结果我们将在VIII-B小节中展示，这一令人惊讶的结果在IX-B小节进行讨论。 Forster等人在论文[22]中提出了介于直接法和基于特征点法之间的半直接视觉里程计SVO。该系统不需要对每帧图像都提取特征点，且可以以很高的帧率运行，在四轴飞行器上取得了令人印象深刻的效果。然而，SVO没有进行闭环检测，且目前的实现主要基于下视摄像头运行。 最后，我们想讨论一下关键帧的选择。所有的视觉SLAM工作相关的文献都同意选择所有的地图点和图像帧运行一起进行BA是不可行的。因此在论文[31]中，Strasdat等人证明性价比最高（cost-effective）的方法是保留尽可能多的（地图）点，同时只保留非冗余关键帧。PTAM通过非常谨慎的插入关键帧以避免运算复杂度过度增长。然而，这种严格限制关键帧插入的策略可能会在困难的探索条件下导致追踪失败。我们的适者生存（survival of the fifittest）策略是在困难的场景下尽快插入关键帧，并稍后删除冗余的关键帧以避免额外的（计算）成本，这实现了前所未有的鲁棒性。 III. 系统架构 A、特征选择 我们系统的主要设计思想是将SLAM系统的建图、跟踪使用的相同特征应用在位置识别以达到（高）帧率（级别的）重定位和闭环检测。这就避免了像之前一些工作[6] [7] 需要额外插入一些识别性强的特征（recognition features）（以用于后期的闭环检测），因此我们的系统更有效率。我们每张图像的特征提取时间要远少于33毫秒，这就排除了流行的SIFT（300ms）[19]、SURF（300ms）[18]，或者是最近的A-KAZE(~100ms)[35]。为了获得更广泛的位置识别能力，我们需要（提取的特征具备）旋转不变性，这就排除了BRIEF[16]和LDB[36]。 我们选择了ORB[9]特征，它是关联了256位描述子（descriptor）的带方向（oriented）的多尺度（multi-scale）FAST角点。它们的计算和匹配速度非常快，同时对视角具有很好的旋转不变性（invariance）。这允许在更宽的基准线上匹配它们，所以提高了BA的精度。我们已经在论文[11]中证明了基于ORB特征的位置识别良好的性能。虽然本文的方案中采用ORB特征，但所提出的技术并不仅限于该特征。 B、三个线程：追踪、局部建图和闭环检测 图1 图2a：关键帧(蓝)、当前相机(绿)、地图点(黑,红)、当前局部地图点(红) 图2b：共视图 图2c：生成树(绿)、闭环回路(红) 图2d：本质图 我们的系统框架如图1所示，包括三个并行的线程：跟踪、局部建图和闭环检测。跟踪线程负责对每帧图像的相机进行定位，并决定什么时候插入新的关键帧。我们首先执行与前一帧图像的初始特征匹配，然后采用仅运动（motion-only）BA优化位姿。如果跟踪丢失（比如由于遮挡或是突然运动），则由位置识别模块进行全局重定位。一旦获得最初的相机位姿估计和特征匹配，则使用由系统维护的关键帧的共视图（covisibility graph）提取一个局部可视化地图，如图2(a),图2(b)所示。然后通过重投影方法搜索（当前帧）与局部地图点对应的匹配，并利用所有的匹配点再次优化当前相机位姿。最后，跟踪线程决定是否（将当前帧）插入新的关键帧。所有的跟踪步骤将在V小节详细阐述。创建初始化地图的新程序将在IV小节进行介绍。 局部建图线程负责处理新的关键帧，使用局部BA对相机位姿周围环境进行优化重构。在共视图（covisibility graph）已连接的所有关键帧中搜索新关键帧中未匹配的ORB特征新对应项，然后将之三角化为新的地图点。在创建后的一段时间内，根据跟踪过程中收集的信息，会应用严格苛刻的点剔除策略，以只保留高质量的点。局部建图线程也负责剔除（culling）冗余的关键帧。我们将在VI节详细说明局部建图的步骤。 闭环检测线程负责对每个新的关键帧进行闭环搜索（以确认是否形成闭环）。如果检测到了闭环，我们就计算一个通知闭环累积误差的相似变换。然后将闭环的两侧对齐，并将重复的点融合。最后，执行基于相似性约束[6]的位姿图优化以实现全局一致性。主要创新点在于，我们执行了基于Essential Graph的优化，它是一个基于共视图covisibility graph的一个稀疏子图，更多细节将在III-D小节解释。VII节详细解释了闭环检测和校正步骤的细节。 我们使用在g2o[37]中实现的列文伯格-马夸尔特法（Levenberg-Marquardt）算法来进行所有的优化。在附录中，我们描述了每个优化中涉及的误差项、误差函数和变量。 C、地图点、关键帧及其选择标准 每个地图点 \\(P_{i}\\) 存储以下信息： 它在世界坐标系中的3D坐标 \\(X_{w,i}\\) 平均观测方向 \\(n_{i}\\)，即该点所有观测方向（该方向是指连接该点和其对应观测关键帧光心的射线方向）的平均单位向量 一个具有代表性的ORB特征描述子 \\(D_{i}\\)，它是（与该地图点）关联的ORB描述子，其汉明距离相对于能观察到该点的关键帧中的所有其他关联的描述子都最小 可观测到该点的最大 \\(d_{max}\\) 和最小 \\(d_{min}\\) 观测距离，根据ORB特征的尺度不变性限制（得出的） 每个关键帧 \\(K_{i}\\) 存储以下信息： 相机位姿 \\(T_{i,w}\\)，这是一个将点从世界坐标系转换到相机坐标系下的刚体变换（矩阵） 相机内参，包括主点（principal point）和焦距（focal length） 从图像帧提取的所有ORB特征点，不管其是否已经关联了地图点。如果提供了畸变模型（distortion model）（参数），则其坐标将不会失真（undistorted） 地图点云和关键帧的创建策略较为宽松，但是之后则会通过一个非常严格苛刻的删选机制进行挑选，该机制会检测出冗余的关键帧和匹配错误的或不可跟踪的地图点然后进行删除。这样做的好处在于探索时，地图在扩建过程中具有一定的弹性，使得系统在外界条件比较恶劣的情况下（比如：旋转，相机快速运动）仍然可以实现鲁棒的跟踪。而（与此同时）当相机对同一个环境不断重新访问时，地图的大小是可控的，这就利于该系统的长期工作。另外，与PTAM算法相比我们构建的地图中包含极少的异常值（outliers），但付出的代价就是点的总数更少。地图点和关键帧的剔除程序分别将在VI-B节和VI-E节解释。 D、共视图和本质图 关键帧之间的共视（covisibility）信息在我们系统中几个模块上都非常有用，我们像论文[7]一样将其表示成一个无向加权图（undirected weighted graph）。（共视）图中每个节点代表一个关键帧，如果两个关键帧能同时观测到至少15个地图点，则这两个节点之间用一条边相连，两个关键帧能共同观测到的地图点数量作为这条边的权重θ。 为了矫正闭环回路，我们像论文[6]那样做位姿图优化，优化方法是延着位姿图将闭环回路的误差进行传播。考虑到共视图（covisibility graph）提供的所有边可能非常密集，我们提出构建一个保留了所有节点（关键帧）但边数却更少的本质图（Essential Graph）。本质图仍旧保持了一个强大的网络以获得精确的结果。系统从初始关键帧开始增量式地构建一个生成树，该树提供了一个边数量最少的共视图（covisibility graph）的连接子图。当插入新的关键帧时，将该关键帧与树上与其有最多共同观测点的关键帧相链接；反之，当一个关键帧通过剔除策略被删除时，系统将更新受该关键帧影响的链接。本质图（Essential Graph）包含了生成树（spanning tree）、具有高共视信息（covisibility）（即 \\(θ_{min}=100\\)）共视图的边的子集、以及闭环回路的边，（这样的组合共同）构建了一个强大的相机网络。图2展示了一个共视图、生成树和相关的本质图的例子。在本文VIII-E节的实验里，当（系统）运行位姿图优化时，结果就可以达到非常高的精度以至于（再运行）额外的全局BA优化几乎无法提升其精度。本质图的效率和 \\(θ_{min}\\) (对系统）的影响将在VIII-E节的结尾部分讨论。 E、基于词袋模型的位置识别 系统嵌入了基于DBoW2[5]算法来执行闭环检测和重定位的模块。视觉单词（visual words）是一个离散化的特征描述子空间，被称为视觉词典（visual vocabulary）。视觉词典是通过大量图像中提取ORB描述子离线创建的。正如我们之前的论文[11]所展现的：如果图像的通用性足够强，则相同的视觉词典在不同的环境下也能获得很好的性能。SLAM系统增量地构建一个包含倒置索引的数据库，用于存储视觉词典里的每个视觉单词以及它们被哪些关键帧观测到，因此数据库的检索效率非常高。当一个关键帧通过剔除程序被删除时，数据库也会进行相应更新。 由于关键帧之间可能会存在视图上的重叠，因此检索数据库时，可能返回不止一个高分值的关键帧结果。原版的DBoW2考虑到了（视图）重叠，（然后）提高了时间上更近的图像的分值。这里的局限性（limitation）在于：没有包括那些观测了同一地点但在不同时间插入的关键帧。为了解决这一问题，我们将这些在共视图中相连的关键帧进行分组。另外，我们的数据库返回分值高于最好分值75%以上的所有关键帧。 用词袋模型来表示特征匹配的另外一个优势在论文[5]里有详细介绍。当我们想计算两组ORB特征的对应关系时，我们可以强制限制在视觉词典树上某一层（我们在6个里面选第2个？）的相同节点里进行暴力匹配，（以此）加快搜索速度。我们将这个技巧应用到 三角化新的（地图）点，闭环检测和重定位 的搜索匹配中。我们还通过方向一致性测试来改进对应性，这可以去除异常值，确保所有对应（匹配点的）旋转方向一致，具体请看论文[11]。 IV. 地图自动初始化 略 V. 跟踪 在这一部分，我们将详细介绍跟踪线程在每一帧相机图像上执行的步骤。在几个步骤中都提到的相机位姿优化，包括仅运动（motion-only）BA，将在附录部分进行阐述。 A、ORB特征提取 我们在8层图像金字塔上提取FAST角点，图像金字塔尺度因子为1.2。我们发现：图像分辨率从512×384到752×480之间，提取1000个角点比较合适。对于更高的分辨率，如KITTI数据集[40]中提供的1241×376分辨率，则提取2000个角点。为了确保特征点均匀分布，我们将每层图像分成网格（grid），每个单元格（cell）提取至少5个角点。然后检测每个单元格（cell）内的角点，如果（某个单元格）角点数量不够，就调整检测器的阈值（再检测一次）。如果某些单元格内检测不出角点（无纹理或者低对比度），则每个单元格保留的角点数量也相应调整。最后，根据保留的FAST角点计算其方向和ORB特征描述子。ORB特征描述子将用于系统后续所有的特征匹配，而不是像PTAM那样根据图像区块相关性（patch correlation）进行搜索。 B、通过前一帧估计初始位姿 如果上一帧图像跟踪成功，我们就使用恒速运动（constant velocity motion）模型来预测相机的位姿（即认为摄像头处于匀速运动），然后对在最后一帧中观察到的地图点进行引导搜索。如果没有找到足够多的匹配点（比如明显违反了运动模型（的规律），即非匀速运动），我们就加大以上一帧中地图点位置（为中心的）搜索范围。然后根据找到的匹配关系对位姿进行优化。 C、通过全局重定位来初始化位姿 如果（扩大了搜索范围还是）跟踪失败，则将当前帧转化为词袋（BoW）向量，并查询识别数据库中用于全局重定位的候选关键帧。然后如III-E节所描述的那样，计算每个候选关键帧中与地图点相对应的ORB特征对应关系。接着，对每个候选关键帧执行RANSAC迭代，并使用PnP算法尝试计算当前帧的位姿。如果我们找到一个具有足够多的有效点（inliers）的位姿，那么优化该位姿，并执行和候选关键帧的地图点进行更多匹配的引导搜索。最后，基于找到的所有匹配点对相机位姿进一步优化，如果有效点（inliers）足够多，则跟踪程序将持续执行。 D、跟踪局部地图 一旦我们有了对相机姿态的估计和一组初始特征匹配，我们就可以将地图投影到帧上，并搜索更多的地图点对应关系。为了降低大地图的复杂性，我们只投影一个局部地图。该局部地图包含一组关键帧 \\(K1\\) （它们和当前帧有共同的地图点），还包括与关键帧 \\(K1\\) 在共视图中相邻的一组关键帧 \\(K2\\) 。这个局部地图中有一个参考关键帧\\(K_{ref} ∈ K1\\)，它与当前帧具有最多共同的地图点。现在对 \\(K1\\) , \\(K2\\) 中观测到的每个地图点，在当前帧中进行如下搜索： 计算该地图点在当前帧中的投影点 \\(x\\) 。如果投影位置超出图像边缘，就将该地图点删除 计算当前地图点观测方向 \\(v\\) 和地图点平均观测方向 \\(n\\) 的夹角。如果 \\(v\\cdot n&lt; \\cos(60°)\\) ，就将该地图点删除 计算从地图点到相机光心的距离 \\(d\\) 。如果它不在地图点的尺度不变区间内，即 \\(d∉[d_{min},d_{max}]\\)，就将该地图点删除 按照 \\(d/d_{min}\\) 计算当前帧的尺度 将地图点的代表特征描述子 \\(D\\) 和当前帧（位于预测的尺度层和靠近 \\(x\\) ）的未匹配ORB特征进行比较，做出最优匹配 相机位姿最后通过当前帧中获得所有的地图点进行优化。 补充：这个环节的目的是在当前帧和局部地图之间找到更多的匹配点对，来优化当前帧的位姿 E、新关键帧的判断 最后一步是决定当前帧是否可以作为新的关键帧。由于局部建图的过程中有一个剔除冗余关键帧的机制，所以我们将尝试尽可能快的插入新的关键帧以保证跟踪线程对具有挑战性的相机运动更具鲁棒性（尤其是对旋转运动）。要插入一个新的关键帧，必须满足以下所有条件： 距离上一次全局重定位后已超过20帧 局部建图处于空闲状态，或距上一个关键帧插入后已超过20帧 当前帧跟踪至少有50个地图点 追踪中，当前帧与参考关键帧 \\(K_{ref}\\) 同时可观测到的（地图）点少于90% 与PTAM中用关键帧之间的距离作为判断标准不同，我们加入一个最小的视图变换（即条件4）。条件1确保好的重定位，条件3确保好的跟踪。如果局部建图处于工作（busy）状态（即条件2的后半部分）的时候插入关键帧，则发送信号去暂停局部BA，以便尽可能快处理新的关键帧。 VI. 局部建图 这章我们将描述根据每个新的关键帧 \\(K_{i}\\) 构建局部地图的步骤。 A、关键帧插入 首先，我们更新共视图：为新关键帧 \\(K_{i}\\) 添加一个新节点，并更新因与其他关键帧有共同地图点（大于15个）产生的边。然后，我们更新与 \\(K_{i}\\) 具有最多共同（地图）点的关键帧的生成树的链接。最后，我们计算该关键帧的词带表示，这将有助于通过数据关联来三角化新的（地图）点。 B、最近的地图点剔除 地图点要想保留在地图中，必须在其创建后的前三个关键帧中通过一个严格的测试。该测试确保（留下的点都）能被跟踪，即这些点不是错误三角化（生成）的（比如由于错误的数据关联）。一个（地图）点必须满足下面两个条件： 跟踪线程在预测该（地图）点可见的所有帧中找到该点的帧数占总帧数的25%以上 创建地图点之后，接下来应该至少有3个关键帧可以观察到这个地图点 一旦一个地图点通过测试后，如果在任何时刻不能从三个及以上关键帧中观察到它，那么该地图点就会被剔除。当关键帧被剔除和局部BA丢弃异值点时，可能会发生这种情况。这个策略使得我们的地图包含很少的异常值（outliers）。 C、新地图点创建 新地图点的创建是通过对共视图（covisibility graph）中连接的关键帧 \\(K_{c}\\) 中的ORB（特征点）进行三角化实现的。对 \\(K_{i}\\) 中每个未匹配的ORB（特征点），我们在其他关键帧的未匹配点中进行查找（看是否有匹配上的特征点）。这个匹配过程在III-E节中有阐述，然后将剔除那些不满足对极约束的匹配项。ORB（特征点）对三角化后，为了将其接受为新（地图）点，该点要进行位置是否在相机前方、重投影误差（小）以及尺度一致性方面的检查。起初，（虽然）一个地图点被两个关键帧观测到，但它可以与其他关键帧中进行搜索匹配，所以它可以投影到其他相连的关键帧中。搜索算法的细节在本文V-D节中有讲述。 D、局部BA 局部BA针对当前处理的关键帧 \\(K_{i}\\) 、所有在共视图中与 \\(K_{i}\\) 连接的关键帧 \\(K_{c}\\) 以及这些被关键帧观测的所有地图点进行优化。所有其他可以观测到这些（地图）点但（在共视图中）与 \\(K_{i}\\) 没有连接的关键帧也包含在优化中（作为约束条件），但保持不变。优化过程中或者优化结束后，被标记为异常点的观测值会被剔除。有关此优化的更多细节，请参见附录。 E、局部关键帧筛选 为了使重建保持简洁，局部建图尽量检测冗余的关键帧然后剔除它们。这样会有很大好处，因为随着关键帧数量的增加，BA优化的复杂度也随之增加。当系统在同一场景下运行时，除非场景有所变化，否则关键帧的数量不会无限增长。这样一来，就增强了系统在相同环境下的可持续运行性。如果关键帧 \\(K_{c}\\) 中90%的（地图）点都可以被其他至少三个关键帧在相同或更精细的尺度下同时观测到（那认为 \\(K_{c}\\) 是冗余的），我们就将其剔除。尺度条件确保了地图点维护的关键帧的观测它们的尺度是最精细的。这个策略受Tan等人的工作[24]的启发，在这项工作中，关键帧在经过一个变换检测的过程后被丢弃。 VII. 闭环检测 当局部建图线程处理完一个关键帧 \\(K_{i}\\) 之后，闭环检测线程会尝试利用 \\(K_{i}\\) 做回环检测。具体步骤如下。 A、候选回环检测 我们先计算 \\(K_{i}\\) 和它在共视图中相邻帧（\\(θ_{min}=30\\)）的的词袋向量相似度，保留最低分值 \\(s_{min}\\) 。然后，我们检索识别数据库，丢掉那些分值低于 \\(s_{min}\\) 的关键帧。这和DBoW2中均值化分值的操作类似，可以获得好的鲁棒性，DBoW2中计算的是前一帧图像，而我们是使用的共视（covisibility）信息。另外，所有直接连接到 \\(K_{i}\\) 的关键帧都会从结果中删除。为了获得候选回环，我们必须连续检测到3个一致的候选回环（在共视图中相连的关键帧）。如果有几个与 \\(K_{i}\\) 相似的地方，就可能会有几个候选回环。 B、计算相似变换 单目SLAM系统有7个自由度可能产生漂移（drift），3个平移，3个旋转和1个尺度因子 [6]。因此，为了闭合回环，我们需要计算从当前关键帧 \\(K_{i}\\) 到回环关键帧 \\(K_{l}\\) 的相似变换，以获得回环的累积误差。计算相似变换也可以作为回环的几何验证。 我们首先按照III-E节中解释的过程，计算与 \\(K_{i}\\) 中ORB相关联的地图点和候选回环关键帧之间的对应关系。此时，对每个候选回环，我们有了一个3D到3D的对应关系。或者，我们对每个候选（回环关键帧）执行RANSAC迭代，通过Horn方法[42]找到相似变换。如果我们用足够的有效数据（inliers）找到了相似变换 \\(S_{il}\\) ，我们就可以优化它，并执行一个引导搜索（匹配）更多的对应关系。再此进行优化，如果 \\(S_{il}\\) 有足够多的有效数据支持时， \\(K_{l}\\) 回环就被接受。 C、回环融合 回环矫正的第一步是融合重复的地图点，在共视图中插入与回环相关的的新边。首先，通过相似变换 \\(S_{il}\\) 矫正当前关键帧位姿 \\(T_{iw}\\) ，并将该矫正传播到所有与 \\(K_{i}\\) 相邻的关键帧，连接转换，以便使回环的两侧进行对齐。然后，回环关键帧及其相邻（的关键帧）能观测到的所有地图点都投影到 \\(K_{i}\\) 以及与 \\(K_{i}\\) 相邻（的关键帧）上，并在投影的区域附近小范围内搜索它的对应匹配点，就像V-D节所做的那样。所有匹配的地图点和计算 \\(S_{il}\\) 过程中的有效数据（inliers）都被融合。融合过程中涉及的所有关键帧将会更新它们在共视图中的边，创建的新边将用于闭合回环。 D、本质图优化 如III-D节所示，为了有效地闭合回环，我们通过本质图（Essential Graph）优化位姿图，这样可以将回环闭合的误差通过（本质）图传播。对相似性变换进行优化，以校正尺度漂移[6]。误差条件和损失函数详见附录。优化过后，每个地图点都根据可以观测到它的一个关键帧的校正进行变换。 VIII. 实验 略 IX. 结论和讨论 A、结论 略 B、稀疏/特征点 vs. 稠密/直接法 略 C、未来工作 我们系统的精度可以通过结合无限远点跟踪来进一步增强。这些没有足够视差的点，并没有包含在本文系统构建的地图中，但它们提供了相机旋转的信息[21]。 另一条路是将稀疏地图升级到一个更加稠密、对重建更实用的地图。由于我们关键帧的选择机制，关键帧包括一个紧凑的环境总结与非常高的姿态精度和丰富的共视信息。所以，ORB-SLAM稀疏地图是一个非常优秀的初始估计框架，可以在此基础上构建一个稠密而准确的场景地图。本条路第一个尝试工作在[47]中展示。 附录：非线性优化 略 参考文献 略 PDF原文 参考链接： https://blog.csdn.net/weixin_42905141/article/details/102857958 https://zhehangt.github.io/2017/04/20/SLAM/ORBSLAM/ORBSLAMPaper/","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"paper","slug":"robot/paper","permalink":"https://silencht.github.io/categories/robot/paper/"}]},{"title":"orbslam2-translation","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/paper/orbslam2-translation/","text":"摘要 本文提出了ORB-SLAM2，它是基于单目、双目和RGB-D相机的一个完整的SLAM系统，该系统包括地图复用、回环检测和重定位功能。这个系统可以适用于多种环境，无论是室内小型手持设备，还是工厂环境中飞行的无人机和城市中行驶的车辆，其都可以在标准CPU上实时运行。该系统的后端使用基于单目和双目观测的光束法平差法（bundle adjustment），这使得其可以精确估计轨迹的尺度。该系统包含一个轻量级的定位模式，它使用视觉里程计追踪未建图区域并匹配地图点，实现零漂移定位。在29个常用公开数据集上的实验评估显示本文方法在大多数情况下是精度最高的SLAM解决方案。我们公开了该系统的源代码，不仅是为了造福SLAM社区，同时也给其他领域的研究者提供一套能够开箱即用的SLAM解决方案。 I. 引言 同时定位建图（SLAM）在过去二十年中一直是计算机视觉和机器人领域的研究热点，最近它也吸引了高科技企业的关注。SLAM技术对未知环境进行建图，同时实时地在地图中定位传感器的位置。在不同传感器中，相机相对便宜，同时能够提供鲁棒准确的位置识别所需的丰富的环境信息，所以以摄像头为主要传感器的视觉SLAM解决方案，是当前最受青睐的研究热点。位置识别是SLAM系统中实现回环检测（当检测到传感器回到已建图区域时，修正探索过程中的累积误差）的关键模块，它能够在因遮挡或剧烈运动导致追踪失败后以及系统重新初始化时，重定位相机的位置。 视觉SLAM只需一个单目相机即可实现，这是最便宜也是最小的传感器设备。但是，仅靠一个单目相机无法观测到深度信息，所以地图和估计轨迹的尺度是未知的。另外，由于单目视觉SLAM系统无法仅根据第一帧图像进行三角化测量（triangulate），所以系统启动时需要多个视角或者滤波技术来生成一个初始地图。同时，单目SLAM会造成尺度漂移，在纯旋转的探索过程中可能会失败。不过，通过使用双目或者RGB-D相机，这些问题都可以被解决，从而实现更可靠的视觉SLAM解决方案。 本文中，在我们之前提出的单目ORB-SLAM的基础上，我们进一步提出了ORB-SLAM2，它有以下贡献： 第一个开源的基于单目、双目、RGB-D相机的SLAM系统，其中包括回环检测、重定位、以及地图重用功能。 我们的RGB-D结果显示，相比较目前最好的基于迭代最近点法（ICP）或广度和深度误差最小法，我们通过使用光束法平差法（BA），可以达到更高的精度。 通过使用远近匹配双目点和单目观测，我们的双目结果比目前最好的直接双目SLAM的精度更高。 提出了一个轻量级的重定位模式，它可以在无法建图时，有效地重新使用地图。 图a 图b 图 1 ORB-SLAM2 对双目和RGB-D输入进行处理，估计相机轨迹，并建立环境的地图。该系统能够该系统能够实时地在标准CPU上进行闭合回环，重定位，重用地图，并具有高精度和高鲁棒性。 图 1 展示了双目和RGB-D输入下ORB-SLAM2系统的输出。其中双目的例子展示了KITTI数据集 00序列的最终估计轨迹和稀疏重建结果。这是一个具有多个回环闭合的城市场景数据序列，ORB-SLAM2系统成功检测到了这些回环。RGB-D的例子展示了TUM RGB-D数据集中的frl-room序列的关键帧位姿估计结果及所得到的稠密点云，其中稠密点云是根据关键帧位姿，将传感器深度图反向投影所得到的。需要注意的是，ORB-SLAM2系统并没有像KinectFusion之类的系统一样进行任何融合，但是却能够精确地估计关键帧位姿。附件视频中将会展示更多的例子。 本文余下章节中，我们将会在第2节中讨论相关工作，在第3节中介绍我们的系统，在第4节中给出实验评估结果，最后在第5节中进行总结。 II. 相关工作 在本节中，我们将会讨论双目和RGB-D SLAM的相关工作。本节中的讨论和第四节中的评估只针对SLAM方法。 A、双目SLAM Paz等人曾做出了一个早期的卓越的双目SLAM系统[5]，他们基于条件独立分治的扩展卡尔曼滤波SLAM（EKF-SLAM），使该系统在那个年代相比较其他方式可以在更大的场景中运行。最重要的是，它是第一个同时使用近特征点和远特征点（由于该点在双目相机中的视差较小，使其深度无法得到可靠估计），并对后者使用逆深度参数估计[6]。他们经验性地指出，当特征点的深度小于双目相机基线长度的40倍时，特征点可以被可靠地三角化。本文工作中我们延续了这种用不同方式处理近特征点和远特征点的策略，这部分内容将在3.1节中进行解释。 大多数现代的双目SLAM系统是基于关键帧[7]和局部BA优化来实现可伸缩性（scalability）。Strasdat等人的工作[8]在关键帧窗内采用BA优化（点-位姿约束），在关键帧窗外采用位姿图优化（位姿-位姿优化）。通过限制窗的大小，该方法可以实现恒定的时间复杂度，但无法保证全局一致性。Mei等人提出了RSLAM方法[9]，其使用了地标和位姿的相对位置表示法，并在限制时间复杂度的条件下，在激活区域内采用相对BA。RSLAM可以实现回环的闭合，这可以扩展回环两端的激活区域，但并不能增强全局一致性。最近Pire等人提出的S-PTAM [10]采用了局部BA，但它缺少闭合大回环的功能。与这些方法类似，我们也在局部关键帧集合中采用了BA，因此该方法的复杂度不受地图尺寸影响，我们可以在大场景中实施该方法。但是，我们的目标是建立一个全局一致的地图。与RSLAM类似，当闭合一个回环时，我们的系统会首先将两端对齐，因此追踪模块可以使用旧地图继续定位，之后采用位姿图优化来最小化回环中的累积漂移，再之后进行全局BA。 最近Engel等人提出的双目LSD-SLAM [11]是一种半稠密的方法，它最小化图像梯度较大区域的光度误差。该方法希望在不依赖特征的条件下，在运动模糊或纹理较弱的环境下获得更好的鲁棒性。但是，作为直接法，该方法的性能会由于未建模因素而显著下降，例如卷帘快门或非朗伯反射。 B、RGB-D SLAM Newcombe等人提出的KinectFusion [4]是最早也是最著名的RGB-D SLAM系统之一。该方法将传感器得到的所有深度数据融合至一个稠密的体积模型，并使用ICP来追踪相机位姿。由于该系统使用体积表示形式并且缺少回环检测，它只能应用于小规模的工作空间。Whelan等人提出的Kintinuous [12]使用了一个滚动循环缓冲区，并且包括了一个使用位置识别和位姿图优化的回环检测模块，从而能够在大规模场景运行。 Endres等人提出的RGB-D SLAM [13]可能是最早流行的开源系统。它是一个基于特征的系统，它的前端通过特征匹配和ICP来计算帧间的运动，它的后端使用位姿图优化，其回环检测约束条件由启发式搜索得到。与之相似，Kerl等人提出的DVO-SLAM [14]的后端也采用位姿图优化，其中关键帧之间的约束是由一个最小化光度和深度误差的视觉里程计计算得到。同时，DVO-SLAM在以往所有帧中启发式地搜索回环的候选者，而不依赖于位置识别。 最近Whelan等人提出的ElasticFusion [15]建立了环境的surfel地图，这是一种忽略位姿，而以地图为核心的方法，它采用对地图进行非刚性变形的方式来实现回环闭合，而不是采用位姿图优化的方法。该系统细节重建和定位精度是非常优秀的，但是由于地图中面元数量所带来的复杂度，目前它仍局限于建立房间大小的地图。 我们的ORB-SLAM2系统使用了一种Strasdat等人提出的方法[8]，该方法使用深度信息来为图像中提取的特征合成立体坐标。通过这种方法，我们的系统可以处理来自双目或者RGB-D的输入。与上述所有方法不同的是，我们方法的后端基于BA，并且能够得到一个全局一致的稀疏重建。因此我们的方法是轻量级的，可以在标准CPU上运行。我们的目标是实现长期并且全局一致的定位，而不是进行具有更多细节的稠密重建。但是，我们的方法也可以通过精度很高的关键帧位姿，进行深度图融合来实时地对局部环境进行准确重建，或者在全局BA后对所有关键帧的深度图进行处理从而得到整个场景的精准三维模型。 III. ORB-SLAM2 基于双目和RGB-D相机的ORB-SLAM2是建立在我们的基于特征的单目ORB-SLAM [1]的基础上的。为读者方便，我们在这里总结一下单目ORB-SLAM的基本组成部分。总体概述了该系统基于双目和RGB-D相机的ORB-SLAM2是建立在我们的基于特征的单目ORB-SLAM的基础上的。为读者方便，我们在这里总结一下单目ORB-SLAM的基本组成部分。图 2 ORB-SLAM2由三个主要的并行线程组成：追踪、局部建图和回环检测。在回环检测后会执行第四个线程，进行全局BA。追踪线程会对双目和RGB-D输入进行预处理，从而使得系统其它部分可以独立于输入传感器运行。虽然这张图没有展示，但ORB-SLAM2也可以基于单目输入运行。图 2总体概览了该系统。该系统具有三个主要的并行线程：1）追踪线程是用来在每一帧中定位相机的位置，通过匹配特征和局部地图并且进行运动BA（motion-only BA）最小化重投影误差；2）局部建图线程是用来管理和优化局部地图；3）回环检测线程是用来检测大回环，并通过执行位姿图优化来修正累积误差。该线程在位姿图优化后会启动第四个线程来执行全局BA，计算最优的结构和运动结果。 图 2 ORB-SLAM2由三个主要的并行线程组成：追踪、局部建图和回环检测。在回环检测后会执行第四个线程，进行全局BA。追踪线程会对双目和RGB-D输入进行预处理，从而使得系统其它部分可以独立于输入传感器运行。虽然这张图没有展示，但ORB-SLAM2也可以基于单目输入运行[1]。(a)系统的线程和模块 (b)输入的预处理 该系统嵌入了一个基于DBoW2 [16]的位置识别模块，在发生追踪失败（例如：碰撞）或者在建好图的场景中重新初始化时用来进行重定位，以及用来进行回环检测。该系统维护了一个关联可见地图（convisible map）[8]，此地图将每两个观察到相同地图点的关键帧连接到一起；同时该系统也维护了一个最小生成树，它连接了所有的关键帧。这种地图结构实现了对于关键帧局部窗的检索，因此追踪线程和局部建图线程可以局部地运行，使其可以在大场景中工作；同时该结构在回环闭合进行位姿图优化时，也可作为优化的图结构。 该系统在追踪、建图和位置识别任务中，都使用相同的ORB特征[17]。这些特征对于旋转和尺度变化具有很好的鲁棒性，同时对于相机的自动增益、自动曝光和光线变化也具有不变性。另外，提取和匹配ORB特征的速度很快，使其可以实时运行，并且在词袋模型位置识别任务上表现出良好的查准率/查重率（precision/recall）[18]。 在本节的余下部分中，我们会展示如何使用双目/深度信息，以及系统的哪些部分将会被影响。关于该系统每一部分更详尽的描述，请参考我们的单目ORB-SLAM论文[1]。 A、单目、近处立体和远处立体关键点 作为一种基于特征的方法，ORB-SLAM2会对输入进行预处理，在显著关键点位置提取特征，如图 2b所示。接下来，输入的图片会被丢弃，系统的全部运算会基于这些特征，因此无论是双目还是RGB-D输入，本系统都可以工作。我们的系统会处理单目和双目的关键点，这些点又会被分为近处点和远处点。 立体（双目）关键点通过三维坐标 \\(x_s=(u_L,v_L,u_R )\\) 来定义，\\((u_L,v_L )\\) 是关键点在左图的坐标，\\(u_R\\) 是关键点在右图的水平坐标。对于双目相机，我们在左右两张图片中同时提取ORB特征。对于左图中的每个ORB特征，我们在右图中搜索一个相应的匹配。对于校正后的双目图像来说，极线是水平的，所以上述任务可以很高效地完成。之后我们根据左图ORB特征坐标和右图相匹配的特征水平坐标来生成立体关键点。对于RGB-D相机，正如Strasdat等人所言[8]，我们在RGB图像上提取ORB特征，对于每个坐标为\\((u_L,v_L )\\)的特征，我们根据它的深度值 \\(d\\) 计算出一个虚拟的右图坐标： \\[ u_R=u_L-(f_x b)/d \\] 其中 \\(f_x\\) 是水平焦距；\\(b\\) 是结果光投影机和红外相机之间的基线长度，在Kinect和Asus Xtion相机中我们将其大概设定为8厘米。深度传感器的不确定性由虚拟的右坐标表示。通过这种方式，系统余下部分可以以相同的方法处理来自双目或者RGB-D输入的特征。 正如文献[5]所述，如果一个立体关键点的深度值小于双目/RGB-D的基线长度的40倍，则认为它是近处点，否则认为它是远处点。近处关键点可以被安全地三角化，因为它的深度可被精确估计，且提供了尺度、平移和旋转的信息。另一方面，远处关键点虽然提供了精确的旋转信息，但不能提供精确的尺度和平移信息。所以当远处关键点在多个视图中存在时，我们才对其进行三角化。 单目关键点通过左图中的二维坐标 \\(x_m=(u_L,v_L)\\) 定义，若ORB特征的双目匹配失效或者RGB-D相机无法得到其有效深度值，则采用此方式。这些点只会在多视图时进行三角化，且不会提供尺度信息，但它们可用于旋转和平移估计。 B、系统启动 使用双目或者RGB-D相机的最主要的好处之一是，我们可以直接获得单帧图像的深度信息，不用像在单目SLAM中一样需要使用特定的SFM（structure from motion）初始化。在系统启动时，我们将第一帧设为关键帧，将其位姿设置为初始位姿，并且根据所有的立体关键点来建立一个初始地图。 C、单目和双目约束下的光束优化法（BA） 我们的系统在追踪线程中使用BA来优化相机位姿（纯运动BA），在局部建图线程中优化关键帧和点的局部窗（局部BA），在回环检测后优化所有的关键帧和点（全局BA）。我们使用g2o [19]中的实现的Levenberg-Marquardt方法来进行优化。 纯运动BA（motion-only BA）优化相机的旋转矩阵 \\(\\mathbf{R} \\in S O(3)\\) 和位置 \\(\\mathbf{t} \\in \\mathbb{R}^{3}\\) ，最小化相匹配的世界坐标系下的三维点 \\(\\mathbf{X}^{i} \\in \\mathbb{R}^{3}\\) 和关键点 \\(\\mathbf{x}_{(\\cdot)}^{i}\\) 之间的重投影误差（单目点 \\(\\mathbf{x}_{\\mathrm{m}}^{i} \\in \\mathbb{R}^{2}\\) 或者双目点 \\(\\mathbf{x}_{\\mathrm{s}}^{i} \\in \\mathbb{R}^{3}\\)，对于所有匹配对 \\(i \\in \\mathcal{X}\\) ）： \\[ \\{\\mathbf{R}, \\mathbf{t}\\}=\\underset{\\mathbf{R}, \\mathbf{t}}{\\operatorname{argmin}} \\sum_{i \\in \\mathcal{X}} \\rho\\left(\\left\\|\\mathbf{x}_{(\\cdot)}^{i}-\\pi_{(\\cdot)}\\left(\\mathbf{R} \\mathbf{X}^{i}+\\mathbf{t}\\right)\\right\\|_{\\Sigma}^{2}\\right) \\] 其中 \\(ρ\\) 是鲁棒Huber代价函数， \\(\\sum\\) 是关键点尺度的协方差矩阵。其中投影函数 \\(\\pi_{(\\cdot)}\\) ，单目投影函数 \\(\\pi_{(m)}\\) ，校正双目投影函数 \\(\\pi_{(s)}\\) 如下定义： \\[ \\pi_{\\mathrm{m}}\\left(\\left[\\begin{array}{l} X \\\\ Y \\\\ Z \\end{array}\\right]\\right)=\\left[\\begin{array}{l} f_{x} \\frac{X}{Z}+c_{x} \\\\ f_{y} \\frac{Y}{Z}+c_{y} \\end{array}\\right], \\pi_{\\mathrm{s}}\\left(\\left[\\begin{array}{l} X \\\\ Y \\\\ Z \\end{array}\\right]\\right)=\\left[\\begin{array}{c} f_{x} \\frac{X}{Z}+c_{x} \\\\ f_{y} \\frac{Y}{Z}+c_{y} \\\\ f_{x} \\frac{X-b}{Z}+c_{x} \\end{array}\\right] \\] 其中 \\(\\left(f_x,f_y\\right)\\) 是焦距，\\(\\left(c_x,c_y\\right)\\) 是光心点，\\(b\\) 是基线长度，这些值都通过标定得到。 全局BA是局部BA的一种特殊情况，在全局BA中，除了初始关键帧因用来消除计算自由度而被固定之外，所有关键帧和地图点都会被优化。 局部BA对一个关联可见的关键帧 \\(\\mathcal{K}_L\\) 集合和这些关键帧中所有可见的点 \\(\\mathcal{P}_L\\) 。所有不在 \\(\\mathcal{K}_L\\) 中，但也观测到 \\(\\mathcal{P}_L\\) 中的点的其它关键帧 \\(\\mathcal{K}_F\\) ，也会参与到代价函数的计算中，但是不会被优化。我们将 \\(\\mathcal{P}_L\\) 中的点与关键帧k中的关键点之间的匹配对的集合定义为 \\(\\mathcal{X}_k\\) ，将优化问题进行如下定义： \\[ \\begin{array}{c} \\left\\{\\mathbf{X}^{i}, \\mathbf{R}_{l}, \\mathbf{t}_{l} | i \\in \\mathcal{P}_{L}, l \\in \\mathcal{K}_{L}\\right\\}=\\underset{\\mathbf{X}^{i}, \\mathbf{R}_{l}, \\mathbf{t}_{l}}{\\operatorname{argmin}} \\sum_{k \\in \\mathcal{K}_{L} \\cup \\mathcal{K}_{F}} \\sum_{j \\in \\mathcal{X}_{k}} \\rho\\left(E_{k j}\\right) \\\\ E_{k j}=\\left\\|\\mathbf{x}_{(\\cdot)}^{j}-\\pi_{(\\cdot)}\\left(\\mathbf{R}_{k} \\mathbf{X}^{j}+\\mathbf{t}_{k}\\right)\\right\\|_{\\Sigma}^{2} \\end{array} \\] 全局BA是局部BA的一种特殊情况，在全局BA中，除了初始关键帧因用来消除计算自由度而被固定之外，所有关键帧和地图点都会被优化。 D、回环检测和全局BA 回环检测分两步进行：第一步是检测和确认回环，第二步是通过优化位姿图来修正回环。相较于单目ORB-SLAM可能会发生尺度漂移[20]，双目/深度信息会使尺度变得可以观测，所以几何验证和位姿图优化不再需要处理尺度漂移；同时它是基于刚体变换，而不是基于相似性。 在ORB-SLAM2中，我们在位姿图优化后，采用全局BA优化来得到最优解。这个优化过程可能开销会很大，所以我们将其放在一个独立的线程中，从而使得系统可以持续建立地图、检测回环。但这样的话，将BA输出与当前地图状态之间进行融合就会产生困难。如果在优化运行的同时发现了新的回环，那么我们就停止优化，转而去闭合回环，这将再次启动全局BA优化。当全局BA完成时，就需要将全局BA优化更新后的关键帧和点的集合，与在优化过程中插入的未更新的关键帧和点，进行融合。这通过将更新的关键帧的修正（未优化位姿至优化位姿的变换）沿生成树传递至未更新的关键帧来完成。未更新的点依据它们的参考帧的修正来进行变换。 E、关键帧的插入 ORB-SLAM2沿用了单目ORB-SLAM中介绍的策略：频繁插入关键帧，之后再剔除冗余的关键帧。近处立体点和远处立体点之间的区别使我们在插入关键帧时可以引入一个新的条件，当环境中存在很大一块场景远离双目传感器时，这是非常重要的，如图 3所示。在这样的环境中，我们需要有足够多的的近处点来精确地估计平移量，因此，当追踪的近处点数目低于 \\(\\tau_{t}\\) 并且此帧能够创建至少 \\(\\tau_{c}\\) 个新的近处立体点时，系统就会插将此帧作为一个新的关键帧插入。根据经验，根据经验，在我们的实验中， \\(\\tau_{t}=100 ,\\tau_{c}=70\\) 的效果较好。 图 3 KITTI 01中的追踪点。绿色点表示深度值小于40倍双目基线长度的点，蓝色点表示更远的点。在这种视频序列中，需要频繁地插入关键帧，使近处点的总数满足精确估计平移量的要求。远处点可用于估计旋转量，但对于估计平移量和尺度帮助不大。 F、定位模式 我们的系统包括了一个定位模式，只要环境没有大的变化，该模式就可以在建图良好的区域中有效地进行轻量级的长期定位。在此模式中，局部建图线程和回环检测线程是停用的，如果需要的话，相机会持续通过追踪线程的重定位功能进行定位。在此模式中，追踪线程会使用视觉里程计中的匹配对，并将其与地图点进行匹配。视觉里程计中的匹配对是指当前帧中的ORB特征和之前帧根据双目/深度信息所创建的三维点之间的匹配对。这些匹配对使得定位功能在未建图区域更加鲁棒，但是会产生累积漂移。与地图点的匹配保证了在已建图区域的定位是零漂移的。此模式会在附带的视频中进行展示说明。 IV. 评估 略 V. 结论 我们提出了一个完整地基于单目、双目或RGB-D传感器的SLAM系统，其可以在标准CPU上实时实现重定位、回环检测和重用地图。我们的重点在于建立全局一致的地图，用于在实验中所介绍的大规模环境中进行长期定位。我们提出的包含重定位功能的定位模式，是一种可以在已知环境中进行鲁棒的、零漂移的、轻量级的定位方法。该模式可适用于特定应用，例如在环境建图良好的虚拟现实中追踪使用者的视点。 与当前最好的SLAM系统的对比，ORB在大多数情况下达到了最高的精度。在KITTI视觉里程计基准测试中，ORB-SLAM2是目前最好的双目SLAM解决方案。很重要的是，与最近流行的双目视觉里程计方法相比，ORB-SLAM2实现了在已建图区域的零漂移定位。 令人惊讶的是，我们的RGB-D结果显示，如果需要精度最高的相机定位，那么BA的表现比直接法或ICP更好，另外它的计算量也更小，不需要依赖GPU就可以实时运行。 我们发布了系统源代码、例子和使用说明，因此其他研究者可以很方便地使用本系统。据我们所知，ORB-SLAM2是第一个在单目、双目或RGB-D输入下都可以工作的开源视觉SLAM系统。另外，我们的源代码包括了一个增强现实的应用例子，其使用单目相机，用于展示我们的解决方案的可能性。 未来的研究方向可能包括：非重叠多幅相机、鱼眼相机、全景相机支持，大规模稠密融合、协作建图以及增强运动模糊的鲁棒性。 PDF原文 参考链接： https://www.cnblogs.com/MingruiYu/p/12991119.html https://zhehangt.github.io/2017/04/24/SLAM/ORBSLAM/ORBSLAM2Paper/","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"paper","slug":"robot/paper","permalink":"https://silencht.github.io/categories/robot/paper/"}]},{"title":"ros error solve","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/ros/ros-error-solve/","text":"1. Failed to load library libgrid_map_rviz_plugin.so grid_map 的 rviz 插件出现错误，导致无法显示GridMap类型的地图. 错误信息如下： GridMap The class required for this display, 'grid_map_rviz_plugin/GridMap', could not be loaded. Error: Failed to load library /opt/ros/noetic/lib//libgrid_map_rviz_plugin.so. Make sure that you are calling the PLUGINLIB_EXPORT_CLASS macro in the library code, and that names are consistent between this macro and your XML. Error string: Could not load library (Poco exception = libgrid_map_core.so: cannot open shared object file: No such file or directory) 解决方法 123456789101112131415161718192021222324252627cd /opt/ros/noetic/libls | grep gridchanghe@changhe:/opt/ros/noetic/lib$ ls | grep gridgrid_map_demosgrid_map_loadergrid_map_visualizationlibgrid_map_cv.solibgrid_map_octomap.solibgrid_map_ros.solibgrid_map_rviz_plugin.solibvoxel_grid.so#发现是有libgrid_map_rviz_plugin.so库的，继续查看该库的依赖信息changhe@changhe:/opt/ros/noetic/lib$ ldd libgrid_map_rviz_plugin.so linux-vdso.so.1 (0x00007ffe6f79e000) librviz.so =&gt; /opt/ros/noetic/lib/librviz.so (0x00007ff49eeaf000) libOgreMain.so.1.9.0 =&gt; /lib/x86_64-linux-gnu/libOgreMain.so.1.9.0 (0x00007ff49e8da000) libgrid_map_ros.so =&gt; /opt/ros/noetic/lib/libgrid_map_ros.so (0x00007ff49e887000) libgrid_map_core.so =&gt; not found libclass_loader.so =&gt; /opt/ros/noetic/lib/libclass_loader.so (0x00007ff49e85a000) libmessage_filters.so =&gt; /opt/ros/noetic/lib/libmessage_filters.so (0x00007ff49e850000)……略#果然，其中有一个依赖libgrid_map_core.so =&gt; not found找不到。原因是几天前手动将该库删除过。现在将grid_map源码编译后的库复制过来即可changhe@changhe:/opt/ros/noetic/lib$ cd ~/grid_map_core/lib/changhe@changhe:~/grid_map_core/lib$ lslibgrid_map_core.sochanghe@changhe:~/grid_map_core/lib$ sudo cp libgrid_map_core.so /opt/ros/noetic/lib/#再次打开rviz，add GridMap类型，发现错误果然消失了","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"ros","slug":"robot/ros","permalink":"https://silencht.github.io/categories/robot/ros/"}]},{"title":"ros1","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/ros/ros1/","text":"零、参考链接 https://www.bilibili.com/video/BV1zt411G7Vn http://wiki.ros.org/cn/ROS/Tutorials/ 一、ROS安装 1.1 参考网址 http://wiki.ros.org/melodic/Installation/Ubuntu 1.2 安装步骤 1.2.1 Setup your sources.list 软件源镜像版参考页面：http://wiki.ros.org/ROS/Installation/UbuntuMirrors 123sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;#下面这个是清华镜像版，推荐sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 1.2.2 Set up your keys 1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 1.2.3 Installation ROS First, make sure your Debian package index is up-to-date: 1sudo apt update Desktop-Full Install: (Recommended) : ROS, rqt, rviz, robot-generic libraries, 2D/3D simulators and 2D/3D perception 1sudo apt install ros-melodic-desktop-full 1.2.4 Environment setup It's convenient if the ROS environment variables are automatically added to your bash session every time a new shell is launched: 12echo &quot;source /opt/ros/melodic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 1.2.5 Dependencies for building packages Up to now you have installed what you need to run the core ROS packages. To create and manage your own ROS workspaces, there are various tools and requirements that are distributed separately. For example, rosinstall is a frequently used command-line tool that enables you to easily download many source trees for ROS packages with one command. To install this tool and other dependencies for building ROS packages, run: 1sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential 1.2.6 Initialize rosdep（optional） Before you can use many ROS tools, you will need to initialize rosdep. rosdep enables you to easily install system dependencies for source you want to compile and is required to run some core components in ROS. If you have not yet installed rosdep, do so as follows. 1sudo apt install python-rosdep With the following, you can initialize rosdep. 123# 若因网络问题执行不通，利用rosdep_update.md文件解决sudo rosdep initrosdep update 1.3 测试安装 启动ROS Master，输出如下图 1roscore 启动小海龟仿真器 1rosrun turtlesim turtlesim_node 启动海龟控制节点 1rosrun turtlesim turtle_teleop_key 二、ROS概念 2.1 节点 2.1.1 Node——执行单元 节点实际上只不过是ROS软件包中的一个可执行文件。ROS节点使用ROS客户端库与其他节点通信。节点可以发布或订阅话题，也可以提供或使用服务。 执行具体任务的进程、独立运行的可执行文件 不同节点可使用不同编程语言，可分布式运行在不同主机 节点在系统中命名必须唯一 2.1.2 ROS Master——控制中心 为节点提供命名和注册服务 跟踪和记录话题/服务通信，辅助节点相互查找、建立连接 提供参数服务器，节点使用此服务器存储和检索运行时的参数 2.2 通信 2.2.1 话题通信 1、 话题Topic——异步通信 节点间用来传输数据的重要总线 使用 发布publish/订阅subscribe模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以不唯一 2、 消息Message——话题数据 具有一定的类型和数据结构，包括ROS提供的标准类型和用户自定义类型 使用编程语言无关的.msg文件定义，编译过程中产生对应的代码文件 2.2.2 服务通信 服务Service——同步通信 使用客户端/服务器模型，客户端发送请求数据，服务器完成处理后返回应答数据 使用编程语言无关的.srv文件定义请求和应答数据结构，编译过程中生成对应的代码文件 2.2.3 话题 vs 服务 topic service 同步性 异步 同步 通信模型 发布/订阅 服务器/客户端 底层协议 ROSTCP/ROSUDP ROSTCP/ROSUDP 反馈机制 无 有 缓冲区 有 无 实时性 弱 强 节点关系 多对多 一对多（一个service） 适用场景 数据传输 逻辑处理 2.2.4 参数 参数Parameter——全局共享字典 可通过网络访问的共享、多变量字典 节点使用此服务器来存储和检索运行时的参数 适合存储静态、非二进制的配置参数，不适合存储动态配置的数据 2.3 文件系统 功能包Package ROS软件中的基本单元，包含节点源码、配置文件、数据定义等 清单Manifest 对软件包的描述，记录功能包的基本信息：作者信息、许可信息、依赖选项、编译标志等 元功能包Meta Package 组织多个用于同一目的的功能包 2.4 主要命令 以海龟仿真器为例： 12345678910111213141516171819202122232425262728293031323334#运行,其中rosrun usage:rosrun &lt;package&gt; &lt;executable&gt;roscorerosrun turtlesim turtlesim_noderosrun turtlesim turtle_teleop_key#查看系统中运行的计算图rtq_graph#查看节点列表rosnode list#查看/turtlesim节点信息rosnode info /turtlesim #查看话题列表rostopic list#发布/turtle1/cmd_vel话题关于坐标的消息，消息频率为10次/秒 (geo开始的内容使用tab补全)rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist &quot;linear: x:1.0 y:0.0 z:0.0angular: x:0.0 y:0.0 z:0.0&quot;#查看话题的消息结构rosmsg show geometry_msgs/Twist#查看服务列表rosservice list#发布某服务请求,在（5.0,5.0）坐标位置产生一个初试角度为0的新海龟rosservice call /spawn &quot;x:5.0y:5.0theta:0.0name:&#x27;turtle2&#x27;&quot;#话题记录,-all全部记录,-O压缩包rosbag record -a -O cmd_record#话题复现rosbag play cmd_record.bag 12345678910111213141516171819#寻找软件包位置命令rospack find [package_name]#示例rospack find roscpp#输出/opt/ros/&lt;distro&gt;/share/roscpp#roscd是rosbash命令集的一部分，它允许你直接切换目录（cd）到某个软件包或者软件包集当中roscd [locationname[/subdir]]#示例roscd roscpppwd#输出YOUR_INSTALL_PATH/share/roscpp#roscd只能切换到那些路径已经包含在ROS_PACKAGE_PATH环境变量中的软件包#如此种种，你也许已经注意到了ROS命令工具的的命名方式：rospack = ros + pack(age)roscd = ros + cdrosls = ros + ls 三、话题应用 3.1 创建工作空间和功能包 工作目录结构 工作空间workspace：一个存放工程开发相关文件的文件夹。 工作空间下共有四个主要文件夹： src：代码空间，放功能包的源码等 build：编译空间，编译过程中的中间二进制文件等 devel：开发空间，开发过程中生成的可执行文件和库等，与install功能类似 install：安装空间，开发结束后生成的可执行文件等 123456789101112131415161718192021222324252627#创建一个名为catkin_ws(自己命名)的工作空间，参数-p 确保目录名称存在，不存在的就新建一个。mkdir -p ~/catkin_ws/srccd ~/catkin_ws/srccatkin_init_workspace #将该目录初始化为ros工作空间#编译工作空间，你可以认为catkin_make是在标准CMake工作流程中依次调用了cmake和makecd ~/catkin_ws/catkin_make#编译安装命令catkin_make install#创建功能包：catkin_create_pkg &lt;package_name&gt; [depend1][depend2]···#功能包需要用到c++、python语言所以需要roscpp和rospy依赖，std_msgs是ros官方提供的标准消息结构cd ~/catkin_ws/srccatkin_create_pkg test_pkg std_msgs rospy roscpp#编译构建功能包cd ~/catkin_wscatkin_make#设置工作空间的环境变量source ~/catkin_ws/devel/setup.bash#检查环境变量echo $ROS_PACKAGE_PATH#输出示例/home/&lt;username&gt;/catkin_ws/src:/opt/ros/&lt;distro&gt;/share#注：ROS_PACKAGE_PATH环境变量应该包含那些保存有ROS软件包的路径，并且每个路径之间用冒号（:）分隔开来export ROS_PACKAGE_PATH=/home/user/ros/ros-pkg:/another/path#注：在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。若要每次启动可用，可将之加入~/.bashrc文件 3.2 Publisher实现 123#创建名为learning_topic的功能包cd ~/catkin_ws/srccatkin_create_pkg learning_topic std_msgs rospy roscpp geometry_msgs turtlesim 3.2.1 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142// ~/catkin_ws/src/learning_topic/src/velocity_publisher.cpp代码如下/* * 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist */ #include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;velocity_publisher&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Publisher对象，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 ros::Publisher turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;, 10); // 设置循环的频率，类似2.4节中的 -r 10 ros::Rate loop_rate(10); int count = 0; while (ros::ok()) &#123; // 初始化geometry_msgs::Twist类型的消息 geometry_msgs::Twist vel_msg; vel_msg.linear.x = 0.5; vel_msg.angular.z = 0.2; // 发布消息 turtle_vel_pub.publish(vel_msg); ROS_INFO(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z); // 按照循环频率延时 loop_rate.sleep(); &#125; return 0;&#125; 123# ~/catkin_ws/src/learning_topic/src/CMakeLists.txt 加入下面的编译选项内容add_executable(velocity_publisher src/velocity_publisher.cpp)target_link_libraries(velocity_publisher $&#123;catkin_LIBRARIES&#125;) 1234567#进入working space根目录编译，并运行publishercd ~/catkin_wscatkin_makesource devel/setup.bash #不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行roscorerosrun turtlesim turtlesim_noderosrun learning_topic velocity_publisher 3.2.2 python版 ~/catkin_ws/src/learning_topic/scripts/velocity_publisher.py代码如下 第三行代码的python解释器由于版本问题可能要写为python3 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twistimport rospyfrom geometry_msgs.msg import Twistdef velocity_publisher(): # ROS节点初始化 rospy.init_node(&#x27;velocity_publisher&#x27;, anonymous=True) # 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10) #设置循环的频率 rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化geometry_msgs::Twist类型的消息 vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 # 发布消息 turtle_vel_pub.publish(vel_msg) rospy.loginfo(&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;, vel_msg.linear.x, vel_msg.angular.z) # 按照循环频率延时 rate.sleep()if __name__ == &#x27;__main__&#x27;: try: velocity_publisher() except rospy.ROSInterruptException: pass 1234567#给.py文件添加执行权限,编译过程等暂时存疑cd ~/catkin_ws/src/learning_topic/scripts/sudo chmod 777 velocity_publisher.pysource devel/setup.bash #不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行roscorerosrun turtlesim turtlesim_noderosrun learning_topic velocity_publisher.py 3.3 Subscriber实现 3.3.1 C++版 1234567891011121314151617181920212223242526272829303132// ~/catkin_ws/src/learning_topic/src/pose_subscriber.cpp代码如下/* * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose */ #include &lt;ros/ros.h&gt;#include &quot;turtlesim/Pose.h&quot;// 接收到订阅的消息后，会进入消息回调函数void poseCallback(const turtlesim::Pose::ConstPtr&amp; msg)&#123; // 将接收到的消息打印出来 ROS_INFO(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg-&gt;x, msg-&gt;y);&#125;int main(int argc, char **argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;pose_subscriber&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback ros::Subscriber pose_sub = n.subscribe(&quot;/turtle1/pose&quot;, 10, poseCallback); // 循环等待回调函数 ros::spin(); return 0;&#125; 123# ~/catkin_ws/src/learning_topic/src/CMakeLists.txt 加入下面的编译选项内容add_executable(pose_subscriber src/pose_subscriber.cpp)target_link_libraries(pose_subscriber $&#123;catkin_LIBRARIES&#125;) 12345678#进入working space根目录编译，并运行subscribercd ~/catkin_wscatkin_makesource devel/setup.bash #不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行roscorerosrun turtlesim turtlesim_noderosrun learning_topic velocity_publisherrosrun learning_topic pose_subscriber #开启订阅者 3.3.2 python版 ~/catkin_ws/src/learning_topic/scripts/pose_subscriber.py代码如下 12345678910111213141516171819202122#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Poseimport rospyfrom turtlesim.msg import Posedef poseCallback(msg): rospy.loginfo(&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;, msg.x, msg.y)def pose_subscriber(): # ROS节点初始化 rospy.init_node(&#x27;pose_subscriber&#x27;, anonymous=True) # 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback rospy.Subscriber(&quot;/turtle1/pose&quot;, Pose, poseCallback) # 循环等待回调函数 rospy.spin()if __name__ == &#x27;__main__&#x27;: pose_subscriber() 12345678#给.py文件添加执行权限,编译过程等暂时存疑cd ~/catkin_ws/src/learning_topic/scripts/sudo chmod 755 pose_subscriber.pysource devel/setup.bash #不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行roscorerosrun turtlesim turtlesim_noderosrun turtlesim turtle_teleop_keyrosrun learning_topic pose_subscriber.py 3.4 话题消息自定义 3.4.1 定义msg文件 123456789101112cd ~/catkin_ws/src/learning_topic/mkdir msgcd msgtouch Person.msg#在Person.msg文件中输入以下内容并保存：string nameuint8 ageuint8 sexuint8 unknown = 0uint8 male = 1uint8 female = 2 3.4.2 在package.xml添加功能包依赖 1234cd ~/catkin_ws/src/learning_topic/#打开package.xml文件，在文件下方依赖位置，输入以下内容并保存：&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 3.4.3 在CMakeLists.txt添加编译内容 123456789101112131415161718192021cd ~/catkin_ws/src/learning_topic/#打开CMakeLists.txt，在适当位置，输入以下内容并保存：find_package(catkin REQUIRED COMPONENTS geometry_msgs roscpp rospy std_msgs turtlesim message_generation)add_message_files( FILES Person.msg)generate_messages( DEPENDENCIES std_msgs)catkin_package(CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime) 3.4.4 编译生成语言相关文件 123cd ~/catkin_wscatkin_make#编译结果：路径~/catkin_ws/devel/include/learning_topic下生成Person.h头文件 3.4.5 自定义话题消息的使用 1、publisher（c++） 12345678910111213141516171819202122232425262728293031323334353637383940414243// ~/catkin_ws/src/learning_topic/src/person_publisher.cpp代码如下/* * 该例程将发布/person_info话题，自定义消息类型learning_topic::Person */ #include &lt;ros/ros.h&gt;#include &quot;learning_topic/Person.h&quot;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;person_publisher&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10 ros::Publisher person_info_pub = n.advertise&lt;learning_topic::Person&gt;(&quot;/person_info&quot;, 10); // 设置循环的频率 ros::Rate loop_rate(1); int count = 0; while (ros::ok()) &#123; // 初始化learning_topic::Person类型的消息 learning_topic::Person person_msg; person_msg.name = &quot;Tom&quot;; person_msg.age = 18; person_msg.sex = learning_topic::Person::male; // 发布消息 person_info_pub.publish(person_msg); ROS_INFO(&quot;Publish Person Info: name:%s age:%d sex:%d&quot;, person_msg.name.c_str(), person_msg.age, person_msg.sex); // 按照循环频率延时 loop_rate.sleep(); &#125; return 0;&#125; 2、subscriber（c++） 1234567891011121314151617181920212223242526272829303132// ~/catkin_ws/src/learning_topic/src/person_subscriber.cpp代码如下/* * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person */ #include &lt;ros/ros.h&gt;#include &quot;learning_topic/Person.h&quot;// 接收到订阅的消息后，会进入消息回调函数void personInfoCallback(const learning_topic::Person::ConstPtr&amp; msg)&#123; // 将接收到的消息打印出来 ROS_INFO(&quot;Subcribe Person Info: name:%s age:%d sex:%d&quot;, msg-&gt;name.c_str(), msg-&gt;age, msg-&gt;sex);&#125;int main(int argc, char **argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;person_subscriber&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback ros::Subscriber person_info_sub = n.subscribe(&quot;/person_info&quot;, 10, personInfoCallback); // 循环等待回调函数 ros::spin(); return 0;&#125; 3、在CMakeLists.txt添加编译内容 123456789cd ~/catkin_ws/src/learning_topic/#打开CMakeLists.txt，在适当位置，输入以下内容并保存：add_executable(person_publisher src/person_publisher.cpp)target_link_libraries(person_publisher $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_publisher $&#123;PROJECT_NAME&#125;_generate_messages_cpp)add_executable(person_subscriber src/person_subscriber.cpp)target_link_libraries(person_subscriber $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_subscriber $&#123;PROJECT_NAME&#125;_generate_messages_cpp) 4、编译与运行 1234567cd ~/catkin_wscatkin_makeroscorerosrun learning_topic person_subscriberrosrun learning_topic person_publisher#一旦pub和sub建立连接,就算关闭roscore,也不会影响两者的连接#因为roscore只负责两者前期的“牵手&quot;,相当于一个”婚介所“,一旦连接之后,就与roscore就无关了 5、publisher（python） ~/catkin_ws/src/learning_topic/scripts/person_publisher.py 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将发布/person_info话题，自定义消息类型learning_topic::Personimport rospyfrom learning_topic.msg import Persondef velocity_publisher(): # ROS节点初始化 rospy.init_node(&#x27;person_publisher&#x27;, anonymous=True) # 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10 person_info_pub = rospy.Publisher(&#x27;/person_info&#x27;, Person, queue_size=10) #设置循环的频率 rate = rospy.Rate(10) while not rospy.is_shutdown(): # 初始化learning_topic::Person类型的消息 person_msg = Person() person_msg.name = &quot;Tom&quot;; person_msg.age = 18; person_msg.sex = Person.male; # 发布消息 person_info_pub.publish(person_msg) rospy.loginfo(&quot;Publsh person message[%s, %d, %d]&quot;, person_msg.name, person_msg.age, person_msg.sex) # 按照循环频率延时 rate.sleep()if __name__ == &#x27;__main__&#x27;: try: velocity_publisher() except rospy.ROSInterruptException: pass 6、subscriber（python） ~/catkin_ws/src/learning_topic/scripts/person_subscriber.py 1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将订阅/person_info话题，自定义消息类型learning_topic::Personimport rospyfrom learning_topic.msg import Persondef personInfoCallback(msg): rospy.loginfo(&quot;Subcribe Person Info: name:%s age:%d sex:%d&quot;, msg.name, msg.age, msg.sex)def person_subscriber(): # ROS节点初始化 rospy.init_node(&#x27;person_subscriber&#x27;, anonymous=True) # 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback rospy.Subscriber(&quot;/person_info&quot;, Person, personInfoCallback) # 循环等待回调函数 rospy.spin()if __name__ == &#x27;__main__&#x27;: person_subscriber() 四、服务应用 4.1 创建功能包 12cd ~/catkin_ws/srccatkin_create_pkg learning_service roscpp rospy std_msgs geometry_msgs turtlesim 4.2 Client实现 4.2.1 C++版 12345678910111213141516171819202122232425262728293031323334353637// ~/catkin_ws/src/learning_service/src/turtle_spawn.cpp代码如下/* * 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn */#include &lt;ros/ros.h&gt;#include &lt;turtlesim/Spawn.h&gt;int main(int argc, char** argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;turtle_spawn&quot;); // 创建节点句柄 ros::NodeHandle node; // 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service ros::service::waitForService(&quot;/spawn&quot;); //阻塞型函数 ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;); // 初始化turtlesim::Spawn的请求数据 turtlesim::Spawn srv; srv.request.x = 2.0; srv.request.y = 2.0; srv.request.name = &quot;turtle2&quot;; // 请求服务调用 ROS_INFO(&quot;Call service to spawn turtle[x:%0.6f, y:%0.6f, name:%s]&quot;, srv.request.x, srv.request.y, srv.request.name.c_str()); add_turtle.call(srv); // 显示服务调用结果 ROS_INFO(&quot;Spawn turtle successfully [name:%s]&quot;, srv.response.name.c_str()); return 0;&#125;; 123# ~/catkin_ws/src/learning_service/src/CMakeLists.txt 加入下面的编译选项内容add_executable(turtle_spawn src/turtle_spawn.cpp)target_link_libraries(turtle_spawn $&#123;catkin_LIBRARIES&#125;) 1234567#进入working space根目录编译，生成可执行文件cd ~/catkin_wscatkin_makesource devel/setup.bash #不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行roscorerosrun turtlesim turtlesim_noderosrun learning_service turtle_spawn 4.2.2 python版 ~/catkin_ws/src/learning_service/scripts/turtle_spawn.py内容如下（注意添加执行权限） 1234567891011121314151617181920212223242526#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将请求/spawn服务，服务数据类型turtlesim::Spawnimport sysimport rospyfrom turtlesim.srv import Spawndef turtle_spawn(): # ROS节点初始化 rospy.init_node(&#x27;turtle_spawn&#x27;) # 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/spawn&#x27;) try: add_turtle = rospy.ServiceProxy(&#x27;/spawn&#x27;, Spawn) # 请求服务调用，输入请求数据 response = add_turtle(2.0, 2.0, 0.0, &quot;turtle2&quot;) return response.name except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: #服务调用并显示调用结果 print &quot;Spwan turtle successfully [name:%s]&quot; %(turtle_spawn()) 4.3 Server实现 4.3.1 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// ~/catkin_ws/src/learning_service/src/turtle_command_server.cpp代码如下/* * 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger */ #include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;std_srvs/Trigger.h&gt;ros::Publisher turtle_vel_pub;bool pubCommand = false;// service回调函数，输入参数req，输出参数resbool commandCallback(std_srvs::Trigger::Request &amp;req, std_srvs::Trigger::Response &amp;res)&#123; pubCommand = !pubCommand; // 显示请求数据 ROS_INFO(&quot;Publish turtle velocity command [%s]&quot;, pubCommand==true?&quot;Yes&quot;:&quot;No&quot;); // 设置反馈数据 res.success = true; res.message = &quot;Change turtle command state!&quot;; return true;&#125;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;turtle_command_server&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个名为/turtle_command的server，注册回调函数commandCallback ros::ServiceServer command_service = n.advertiseService(&quot;/turtle_command&quot;, commandCallback); // 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle1/cmd_vel&quot;, 10); // 循环等待回调函数 ROS_INFO(&quot;Ready to receive turtle command.&quot;); // 设置循环的频率，类似2.4节中的 -r 10 ros::Rate loop_rate(10); while(ros::ok()) &#123; // 查看一次回调函数队列 ros::spinOnce(); // 如果标志为true，则发布速度指令 if(pubCommand) &#123; geometry_msgs::Twist vel_msg; vel_msg.linear.x = 0.5; vel_msg.angular.z = 0.2; turtle_vel_pub.publish(vel_msg); &#125; //按照循环频率延时 loop_rate.sleep(); &#125; return 0;&#125; 123# ~/catkin_ws/src/learning_service/src/CMakeLists.txt 加入下面的编译选项内容add_executable(turtle_command_server src/turtle_command_server.cpp)target_link_libraries(turtle_command_server $&#123;catkin_LIBRARIES&#125;) 12345678#进入working space根目录编译，生成可执行文件cd ~/catkin_wscatkin_makesource devel/setup.bash #不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行roscorerosrun turtlesim turtlesim_noderosrun learning_service turtle_command_serverrosservice call /turtle_command &quot;&#123;&#125;&quot; 4.3.2 python版 ~/catkin_ws/src/learning_service/scripts/turtle_command_server.py内容如下（注意添加执行权限） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将执行/turtle_command服务，服务数据类型std_srvs/Triggerimport rospyimport thread,timefrom geometry_msgs.msg import Twistfrom std_srvs.srv import Trigger, TriggerResponsepubCommand = False;turtle_vel_pub = rospy.Publisher(&#x27;/turtle1/cmd_vel&#x27;, Twist, queue_size=10)def command_thread(): while True: if pubCommand: vel_msg = Twist() vel_msg.linear.x = 0.5 vel_msg.angular.z = 0.2 turtle_vel_pub.publish(vel_msg) time.sleep(0.1)def commandCallback(req): global pubCommand pubCommand = bool(1-pubCommand) # 显示请求数据 rospy.loginfo(&quot;Publish turtle velocity command![%d]&quot;, pubCommand) # 反馈数据 return TriggerResponse(1, &quot;Change turtle command state!&quot;)def turtle_command_server(): # ROS节点初始化 rospy.init_node(&#x27;turtle_command_server&#x27;) # 创建一个名为/turtle_command的server，注册回调函数commandCallback s = rospy.Service(&#x27;/turtle_command&#x27;, Trigger, commandCallback) # 循环等待回调函数 print &quot;Ready to receive turtle command.&quot; thread.start_new_thread(command_thread, ()) rospy.spin()if __name__ == &quot;__main__&quot;: turtle_command_server() 4.4 服务数据自定义 4.4.1 定义srv文件 12345678910111213141516cd ~/catkin_ws/src/learning_service/mkdir srvcd srvtouch Person.srv#在Person.srv文件中输入以下内容并保存：#---上方是request数据，下方是response数据string nameuint8 ageuint8 sexuint8 unknown = 0uint8 male = 1uint8 female = 2---string result 4.4.2 在package.xml添加功能包依赖 1234cd ~/catkin_ws/src/learning_service/#打开package.xml文件，在文件下方依赖位置，输入以下内容并保存：&lt;build_depend&gt;message_generation&lt;/build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 4.4.3 在CMakeLists.txt添加编译内容 123456789101112131415161718192021cd ~/catkin_ws/src/learning_service/#打开CMakeLists.txt，在适当位置，输入以下内容并保存：find_package(catkin REQUIRED COMPONENTS geometry_msgs roscpp rospy std_msgs turtlesim message_generation)add_service_files( FILES Person.srv)generate_messages( DEPENDENCIES std_msgs)catkin_package(CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime) 4.4.4 编译生成语言相关文件 123cd ~/catkin_wscatkin_make#编译结果：路径~/catkin_ws/devel/include/learning_service下生成PersonRequest.h和PersonResponse.h头文件 4.4.5 自定义服务数据的使用 1、server（c++） 1234567891011121314151617181920212223242526272829303132333435363738// ~/catkin_ws/src/learning_service/src/person_server.cpp代码如下/* * 该例程将执行/show_person服务，服务数据类型learning_service::Person */ #include &lt;ros/ros.h&gt;#include &quot;learning_service/Person.h&quot;// service回调函数，输入参数req，输出参数resbool personCallback(learning_service::Person::Request &amp;req, learning_service::Person::Response &amp;res)&#123; // 显示请求数据 ROS_INFO(&quot;Person: name:%s age:%d sex:%d&quot;, req.name.c_str(), req.age, req.sex); // 设置反馈数据 res.result = &quot;OK&quot;; return true;&#125;int main(int argc, char **argv)&#123; // ROS节点初始化 ros::init(argc, argv, &quot;person_server&quot;); // 创建节点句柄 ros::NodeHandle n; // 创建一个名为/show_person的server，注册回调函数personCallback ros::ServiceServer person_service = n.advertiseService(&quot;/show_person&quot;, personCallback); // 循环等待回调函数 ROS_INFO(&quot;Ready to show person informtion.&quot;); ros::spin(); return 0;&#125; 2、client（c++） 12345678910111213141516171819202122232425262728293031323334353637// ~/catkin_ws/src/learning_service/src/person_client.cpp代码如下/* * 该例程将请求/show_person服务，服务数据类型learning_service::Person */#include &lt;ros/ros.h&gt;#include &quot;learning_service/Person.h&quot;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;person_client&quot;); // 创建节点句柄 ros::NodeHandle node; // 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service ros::service::waitForService(&quot;/show_person&quot;); ros::ServiceClient person_client = node.serviceClient&lt;learning_service::Person&gt;(&quot;/show_person&quot;); // 初始化learning_service::Person的请求数据 learning_service::Person srv; srv.request.name = &quot;Tom&quot;; srv.request.age = 20; srv.request.sex = learning_service::Person::Request::male; // 请求服务调用 ROS_INFO(&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;, srv.request.name.c_str(), srv.request.age, srv.request.sex); person_client.call(srv); // 显示服务调用结果 ROS_INFO(&quot;Show person result : %s&quot;, srv.response.result.c_str()); return 0;&#125;; 3、在CMakeLists.txt添加编译内容 123456789cd ~/catkin_ws/src/learning_service/#打开CMakeLists.txt，在适当位置，输入以下内容并保存：add_executable(person_server src/person_server.cpp)target_link_libraries(person_server $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_server $&#123;PROJECT_NAME&#125;_gencpp)add_executable(person_client src/person_client.cpp)target_link_libraries(person_client $&#123;catkin_LIBRARIES&#125;)add_dependencies(person_client $&#123;PROJECT_NAME&#125;_gencpp) 4、编译与运行 123456cd ~/catkin_wscatkin_makesource devel/setup.bashroscorerosrun learning_service person_serverrosrun learning_service person_client 5、server（python） 123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将执行/show_person服务，服务数据类型learning_service::Personimport rospyfrom learning_service.srv import Person, PersonResponsedef personCallback(req): # 显示请求数据 rospy.loginfo(&quot;Person: name:%s age:%d sex:%d&quot;, req.name, req.age, req.sex) # 反馈数据 return PersonResponse(&quot;OK&quot;)def person_server(): # ROS节点初始化 rospy.init_node(&#x27;person_server&#x27;) # 创建一个名为/show_person的server，注册回调函数personCallback s = rospy.Service(&#x27;/show_person&#x27;, Person, personCallback) # 循环等待回调函数 print &quot;Ready to show person informtion.&quot; rospy.spin()if __name__ == &quot;__main__&quot;: person_server() 6、client（python） 1234567891011121314151617181920212223242526#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将请求/show_person服务，服务数据类型learning_service::Personimport sysimport rospyfrom learning_service.srv import Person, PersonRequestdef person_client(): # ROS节点初始化 rospy.init_node(&#x27;person_client&#x27;) # 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/show_person&#x27;) try: person_client = rospy.ServiceProxy(&#x27;/show_person&#x27;, Person) # 请求服务调用，输入请求数据 response = person_client(&quot;Tom&quot;, 20, PersonRequest.male) return response.result except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: #服务调用并显示调用结果 print &quot;Show person result : %s&quot; %(person_client()) 五、参数应用 5.1 创建功能包 12cd ~/catkin_ws/srccatkin_create_pkg learning_parameter roscpp rospy std_srvs 5.2 参数命令行使用 123456789101112#列出当前所有参数rosparam list#显示某个参数的值rosparam get param_key#设置某个参数的值rosparam set param_key param_value#保存参数到文件rosparam dump file_name#从文件读取参数rosparam load file_name#删除参数rosparam delete param_key 5.3 实现 5.3.1 C++版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// ~/catkin_ws/src/learning_parameter/src/parameter_config.cpp代码如下/* * 该例程设置/读取海龟例程中的参数 */#include &lt;string&gt;#include &lt;ros/ros.h&gt;#include &lt;std_srvs/Empty.h&gt;int main(int argc, char **argv)&#123; int red, green, blue; // ROS节点初始化 ros::init(argc, argv, &quot;parameter_config&quot;); // 创建节点句柄 ros::NodeHandle node; // 读取背景颜色参数 ros::param::get(&quot;/background_r&quot;, red); ros::param::get(&quot;/background_g&quot;, green); ros::param::get(&quot;/background_b&quot;, blue); ROS_INFO(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue); // 设置背景颜色参数 ros::param::set(&quot;/background_r&quot;, 255); ros::param::set(&quot;/background_g&quot;, 255); ros::param::set(&quot;/background_b&quot;, 255); ROS_INFO(&quot;Set Backgroud Color[255, 255, 255]&quot;); // 读取背景颜色参数 ros::param::get(&quot;/background_r&quot;, red); ros::param::get(&quot;/background_g&quot;, green); ros::param::get(&quot;/background_b&quot;, blue); ROS_INFO(&quot;Re-get Backgroud Color[%d, %d, %d]&quot;, red, green, blue); //发现/clear服务后，创建一个服务客户端，服务数据类型empty调用服务，刷新背景颜色 ros::service::waitForService(&quot;/clear&quot;); ros::ServiceClient clear_background = node.serviceClient&lt;std_srvs::Empty&gt;(&quot;/clear&quot;); std_srvs::Empty srv; clear_background.call(srv); sleep(1); return 0;&#125; 1234cd ~/catkin_ws/src/learning_parameter/#打开CMakeLists.txt，在适当位置，输入以下内容并保存：add_executable(parameter_config src/parameter_config.cpp)target_link_libraries(parameter_config $&#123;catkin_LIBRARIES&#125;) 123456cd ~/catkin_wscatkin_makesource devel/setup.bashroscorerosrun turtlesim turtlesim_noderosrun learning_parameter parameter_config 5.3.2 python版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程设置/读取海龟例程中的参数import sysimport rospyfrom std_srvs.srv import Emptydef parameter_config(): # ROS节点初始化 rospy.init_node(&#x27;parameter_config&#x27;, anonymous=True) # 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue) # 设置背景颜色参数 rospy.set_param(&quot;/background_r&quot;, 255); rospy.set_param(&quot;/background_g&quot;, 255); rospy.set_param(&quot;/background_b&quot;, 255); rospy.loginfo(&quot;Set Backgroud Color[255, 255, 255]&quot;); # 读取背景颜色参数 red = rospy.get_param(&#x27;/background_r&#x27;) green = rospy.get_param(&#x27;/background_g&#x27;) blue = rospy.get_param(&#x27;/background_b&#x27;) rospy.loginfo(&quot;Get Backgroud Color[%d, %d, %d]&quot;, red, green, blue) # 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service(&#x27;/clear&#x27;) try: clear_background = rospy.ServiceProxy(&#x27;/clear&#x27;, Empty) # 请求服务调用，输入请求数据 response = clear_background() return response except rospy.ServiceException, e: print &quot;Service call failed: %s&quot;%eif __name__ == &quot;__main__&quot;: parameter_config() 六、tf坐标系 6.1 创建功能包 123sudo apt-get install ros-melodic-turtle-tfcd ~/catkin_ws/srccatkin_create_pkg learning_tf roscpp rospy tf turtlesim 6.2 实现 6.2.1 broadcaster（c++） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// ~/catkin_ws/src/learning_tf/src/turtle_tf_broadcaster.cpp代码如下/* * 该例程产生tf数据，并计算、发布turtle2的速度指令 */#include &lt;ros/ros.h&gt;#include &lt;tf/transform_broadcaster.h&gt;#include &lt;turtlesim/Pose.h&gt;std::string turtle_name;void poseCallback(const turtlesim::PoseConstPtr&amp; msg)&#123; // 创建tf的广播器 static tf::TransformBroadcaster br; // 初始化tf数据 tf::Transform transform; transform.setOrigin( tf::Vector3(msg-&gt;x, msg-&gt;y, 0.0) ); tf::Quaternion q; q.setRPY(0, 0, msg-&gt;theta); transform.setRotation(q); // 广播world与海龟坐标系之间的tf数据 br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), &quot;world&quot;, turtle_name));&#125;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;my_tf_broadcaster&quot;); // 输入参数作为海龟的名字 if (argc != 2) &#123; ROS_ERROR(&quot;need turtle name as argument&quot;); return -1; &#125; turtle_name = argv[1]; // 订阅海龟的位姿话题 ros::NodeHandle node; ros::Subscriber sub = node.subscribe(turtle_name+&quot;/pose&quot;, 10, &amp;poseCallback); // 循环等待回调函数 ros::spin(); return 0;&#125;; 6.2.2 listener（c++） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ~/catkin_ws/src/learning_tf/src/turtle_tf_listener.cpp代码如下/* * 该例程监听tf数据，并计算、发布turtle2的速度指令 */#include &lt;ros/ros.h&gt;#include &lt;tf/transform_listener.h&gt;#include &lt;geometry_msgs/Twist.h&gt;#include &lt;turtlesim/Spawn.h&gt;int main(int argc, char** argv)&#123; // 初始化ROS节点 ros::init(argc, argv, &quot;my_tf_listener&quot;); // 创建节点句柄 ros::NodeHandle node; // 请求产生turtle2 ros::service::waitForService(&quot;/spawn&quot;); ros::ServiceClient add_turtle = node.serviceClient&lt;turtlesim::Spawn&gt;(&quot;/spawn&quot;); turtlesim::Spawn srv; add_turtle.call(srv); // 创建发布turtle2速度控制指令的发布者 ros::Publisher turtle_vel = node.advertise&lt;geometry_msgs::Twist&gt;(&quot;/turtle2/cmd_vel&quot;, 10); // 创建tf的监听器 tf::TransformListener listener; ros::Rate rate(10.0); while (node.ok()) &#123; // 获取turtle1与turtle2坐标系之间的tf数据 tf::StampedTransform transform; try &#123; listener.waitForTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;, ros::Time(0), ros::Duration(3.0)); listener.lookupTransform(&quot;/turtle2&quot;, &quot;/turtle1&quot;, ros::Time(0), transform); &#125; catch (tf::TransformException &amp;ex) &#123; ROS_ERROR(&quot;%s&quot;,ex.what()); ros::Duration(1.0).sleep(); continue; &#125; // 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令 geometry_msgs::Twist vel_msg; vel_msg.angular.z = 4.0 * atan2(transform.getOrigin().y(), transform.getOrigin().x()); vel_msg.linear.x = 0.5 * sqrt(pow(transform.getOrigin().x(), 2) + pow(transform.getOrigin().y(), 2)); turtle_vel.publish(vel_msg); rate.sleep(); &#125; return 0;&#125;; 6.2.3 在CMakeLists.txt添加编译内容 1234567cd ~/catkin_ws/src/learning_tf/#打开CMakeLists.txt，在适当位置，输入以下内容并保存：add_executable(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)target_link_libraries(turtle_tf_broadcaster $&#123;catkin_LIBRARIES&#125;)add_executable(turtle_tf_listener src/turtle_tf_listener.cpp)target_link_libraries(turtle_tf_listener $&#123;catkin_LIBRARIES&#125;) 6.2.4 编译与运行 123456789101112cd ~/catkin_wscatkin_makesource devel/setup.bashroscorerosrun turtlesim turtlesim_node#最后的/turtle1是main函数中的输入参数，前面(__name:=turtle1_tf_broadcaster)#使用了节点名的重映射，即turtle1_tf_broadcaster会代替6.2.1节中节点初始化名#my_tf_broadcaster，这就方便了相同程序同时（使用不同节点名）重复运行rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2rosrun learning_tf turtle_tf_listenerrosrun turtlesim turtle_teleop_key 6.2.5 broadcaster（python） 123456789101112131415161718192021222324252627#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将请求/show_person服务，服务数据类型learning_service::Personimport roslibroslib.load_manifest(&#x27;learning_tf&#x27;)import rospyimport tfimport turtlesim.msgdef handle_turtle_pose(msg, turtlename): br = tf.TransformBroadcaster() br.sendTransform((msg.x, msg.y, 0), tf.transformations.quaternion_from_euler(0, 0, msg.theta), rospy.Time.now(), turtlename, &quot;world&quot;)if __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;turtle_tf_broadcaster&#x27;) turtlename = rospy.get_param(&#x27;~turtle&#x27;) rospy.Subscriber(&#x27;/%s/pose&#x27; % turtlename, turtlesim.msg.Pose, handle_turtle_pose, turtlename) rospy.spin() 6.2.6 listener（python） 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python# -*- coding: utf-8 -*-# 该例程将请求/show_person服务，服务数据类型learning_service::Personimport roslibroslib.load_manifest(&#x27;learning_tf&#x27;)import rospyimport mathimport tfimport geometry_msgs.msgimport turtlesim.srvif __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;turtle_tf_listener&#x27;) listener = tf.TransformListener() rospy.wait_for_service(&#x27;spawn&#x27;) spawner = rospy.ServiceProxy(&#x27;spawn&#x27;, turtlesim.srv.Spawn) spawner(4, 2, 0, &#x27;turtle2&#x27;) turtle_vel = rospy.Publisher(&#x27;turtle2/cmd_vel&#x27;, geometry_msgs.msg.Twist,queue_size=1) rate = rospy.Rate(10.0) while not rospy.is_shutdown(): try: (trans,rot) = listener.lookupTransform(&#x27;/turtle2&#x27;, &#x27;/turtle1&#x27;, rospy.Time(0)) except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException): continue angular = 4 * math.atan2(trans[1], trans[0]) linear = 0.5 * math.sqrt(trans[0] ** 2 + trans[1] ** 2) cmd = geometry_msgs.msg.Twist() cmd.linear.x = linear cmd.angular.z = angular turtle_vel.publish(cmd) rate.sleep() 6.2.7 运行 1rosrun learning_tf turtle_tf_broadcaster.py __name:=turtle1_tf_broadcaster _turtle:=/turtle1 七、launch启动文件 7.1 简单启动文件 12345678cd ~/catkin_ws/srccatkin_create_pkg learning_launchcd learning_launchmkdir launchcd launchtouch simple.launchsudo vim simple.launch#输入以下内容 1234&lt;launch&gt; &lt;node pkg=&quot;learning_topic&quot; type=&quot;person_subscriber&quot; name=&quot;talker&quot; /&gt; &lt;node pkg=&quot;learning_topic&quot; type=&quot;person_publisher&quot; name=&quot;listener&quot; /&gt; &lt;/launch&gt; 1234cd ~/catkin_wscatkin_make#命令：roslaunch [package] [filename.launch]roslaunch learning_launch simple.launch 7.2 官方参考网址 https://wiki.ros.org/roslaunch/XML 7.3 常用标签注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!--launch文件中的根元素用该标签定义，只作为其他自标签容器--&gt;&lt;launch&gt; &lt;!--node启动节点;pkg:节点所在功能包名;type:可执行文件名称;name:重定义节点名 【注：name会替换掉程序初始化时的节点名】 【可选:output(日志输出到屏幕，若不设置，将写入日志文件) respawn(节点失效是否重启) required(节点失效关闭整个launch文件) ns(在命名空间中运行此节点) args(给节点输入参数)】 模板： &lt;node pkg=&quot;package_name&quot; type=&quot;executable|python&quot; name=&quot;node_name&quot; /&gt; --&gt; &lt;node name=&quot;bar1&quot; pkg=&quot;foo_pkg&quot; type=&quot;bar&quot; args=&quot;--test&quot; respawn=&quot;true&quot; output=&quot;sceen&quot;/&gt; &lt;!--若干个节点划分进同一个命名空间 --&gt; &lt;group ns=&quot;namespace&quot;&gt; &lt;node pkg=&quot;pkg_name1&quot; .../&gt; &lt;node pkg=&quot;pkg_name2&quot; .../&gt; ... &lt;/group&gt; &lt;!--条件判断执行 --&gt; &lt;group if=&quot;$(arg foo1)&quot;&gt; &lt;node pkg=&quot;pkg_name1&quot; .../&gt; &lt;/group&gt; &lt;group unless=&quot;$(arg foo2)&quot;&gt; &lt;node pkg=&quot;pkg_name2&quot; .../&gt; &lt;/group&gt; &lt;!--重命名，from 原始名称 to 新名称 可以这样理解这个替换标签（存疑）：你有一个节点订阅了「chatter」话题，但是你只有一个节点发布 「hello」话题，而「hello」和「chatter」的类型相同，所以我们可以将「chatter」简单地替换为「hello」，从而实现订阅「hello」话题 --&gt; &lt;remap from = &quot;/different_topic&quot; to = &quot;/needed_topic&quot; /&gt; &lt;!--定义节点所运行的机器信息，如果只在本地运行则不需要配置，它主要使用在SSH和远程机器 【参数:name：机器名称 address：机器的网络地址 env-loader：设置机器的环境变量，必须是一个设置了所有要求变量的 shell 脚本 user：用户名称】 --&gt; &lt;machine name=&quot;foo&quot; address=&quot;foo-address&quot; env-loader=&quot;/opt/ros/kinetic/env.sh&quot; user=&quot;someone&quot;&gt; &lt;!--可以在启动的节点上设置环境变量，这个标签基本只会使用在 launch、include、node、machine 这 4 个标签内部，当使用在 launch 内部时，env 设置的环境标量会应用到内部定义的节点。 【参数:name：环境变量名称 value：环境变量值 --&gt; &lt;env name=&quot;ENV_EXAMPLE&quot; value=&quot;some value&quot; /&gt; &lt;!--设置全局参数，存储在参数服务器中:name(参数名)type(参数类型)value(参数值) param 标签也可以为一组 group 节点同时设置参数。--&gt; &lt;param name=&quot;publish_frequency&quot; type=&quot;double&quot; value=&quot;10.0&quot;/&gt; &lt;!--允许节点从参数服务器上增删改YAML文件，也可以使用在远程机器上，需要注意的是 delete 必须在 load 或者 dump 之后进行导入之后进行 【参数:command：load，dump，delete file：参数文件的路径 --&gt; &lt;rosparam file=&quot;params.yaml&quot; command=&quot;load&quot; ns=&quot;params&quot;/&gt; &lt;!--设置launch文件内部的局部参数:name(参数名)value(参数值)--&gt; &lt;arg name=&quot;arg-name&quot; default=&quot;arg-value&quot;/&gt; &lt;!--两个调用arg的例子--&gt; &lt;param name=&quot;foo&quot; value=&quot;$(arg arg-name)&quot;/&gt; &lt;node name=&quot;node&quot; pkg=&quot;package&quot; type=&quot;type&quot; args=&quot;$(arg arg-name)&quot;/&gt; &lt;!--包含其他launch文件，类似C语言的头文件包含:file是路径--&gt; &lt;include file=&quot;$(dirname)/other.launch&quot;/&gt;&lt;/launch&gt; 八、可视化工具 1234567891011121314#工具集合rqt#日志输出rqt_console#计算图可视化rqt_graph#数据绘图rqt_plot#图像渲染工具rqt_image_view#三维可视化工具（数据显示）rviz#三维物理仿真平台roslaunch gazebo_ros + tab补全","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"ros","slug":"robot/ros","permalink":"https://silencht.github.io/categories/robot/ros/"}]},{"title":"conda","date":"2023-11-29T02:08:16.537Z","path":"wiki/cs/python/conda/conda/","text":"0.官方源文档链接 1.管理conda 验证conda是否安装成功，在Windows : anaconda prompt终端或 Linux/Unix/Mac 的终端下输入: 1conda --version conda显示你安装的版本号. 举例: conda 4.7.12 更新当前conda版本. 输入以下命令: 1conda update conda conda比较版本，然后显示出可以安装的版本。如果有新版本conda可用，输入 y 来更新: 1Proceed ([y]/n)? y 2.管理环境 conda允许你创建一个不会与其他环境有关的，包含文件、包和它们的依赖的分离式环境。 当你开始使用conda时，你已经有了一个名为base的默认环境。但是，当你不想要将程序放入你的基环境的话，可以创建一个使你的程序与其他程序相隔离的分离式环境。 创建新环境并给它安装一个包。 我们将创建一个名为snwflakes的新环境，然后安装BioPython包。在终端输入以下命令： 1conda create --name snowflakes biopython Conda检查查看BioPython需要哪些其他软件包（“依赖项”）,然后询问你是否继续: 1Proceed ([y]/n)? y 键入y和回车继续 为了激活和使用刚才安装的新环境, 输入以下内容: Windows、macOS and Linux，Conda 4.6以上版本: 1conda activate snowflakes NOTE: conda activate only works on conda 4.6 and later versions. 现在你就处于 snowflakes 环境中了,任何你键入的conda命令都将作用于这个环境，直到你切换到其他环境（即deactivated snowflakes） 为了看到你所有的环境列表，键入: 1conda info --envs 环境列表与下方所列相似（3、4行 为不同系统所示）: 12345# conda environments:#base /home/username/Anaconda3snowflakes * /home/username/Anaconda3/envs/snowflakes （Linux）snowflakes * D:\\anaconda\\envs\\snowflakes （Winodws） Tip：当前活跃环境是环境列表中带有*的 关闭当前环境，切换至默认环境 (即base)，键入: conda activate 删除环境 如果当前位于snowflakes环境内，则先退出环境，输入： 1conda deactivate 回到base环境后，输入删除snowflakes环境的命令： 1conda env remove -n snowflakes 安装conda后取消命令行前出现的base，取消每次启动终端后自动激活conda的base环境 方法一： 每次手动在命令行通过 conda deactivate 退出base环境，回到系统自动的环境 方法二： 通过将auto_activate_base参数设置为false实现： 1conda config --set auto_activate_base false 要进入base环境的话通过 conda activate base 命令 若以后还是希望base保持自动激活，通过 conda config --set auto_activate_base true 来恢复 3.管理Python 当你创建一个新环境时，conda安装的Python版本与你安装的anaconda软件的默认Python版本相同。如果你想要使用一个不同的Python版本，比如Python 3.5, 你可以在创建一个新的环境时，指定你想要的Python版本。 创建一个名为 \"snakes\"且包含Python 3.5的新环境: 1conda create --name snakes python=3.5 当conda询问你是否继续时,键入 \"y\" 然后按回车键. 激活新环境: Windows、macOS and Linux，Conda 4.6以上版本: 1conda activate snakes 核实snakes环境已经被添加和激活: 1conda info --envs Conda 显示了所有的环境列表，然后在当前激活的环境前加了*号: 12345# conda environments:#base /home/username/anaconda3snakes * /home/username/anaconda3/envs/snakessnowflakes /home/username/anaconda3/envs/snowflakes 当前激活的环境名称同样在你的终端命令行的$符号前用()括起来显示，像下面这样: 1(snakes) $ 确定你当前环境安装的Python版本: 1python --version 关闭当前环境，回到默认环境 (即base): conda activate 4.管理包 在这一节，你可以检查你安装了哪些包、核实哪些是能用的、寻找确定的包然后安装它。 为了寻找一个你已经安装的包，首先激活你要寻找这个包的环境. 如： 1conda activate snakes 检查当前环境下有哪些包可用： 1conda list 添加一些软件源（国外服务器网速太慢，使用一些国内镜像源，如：下面添加了两个源） 12conda config --add channels https://conda.anaconda.org/menpoconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ 查看当前源有哪些: 1conda config --show channels 若要删除某些源： 1conda config --remove channels https://pypi.doubanio.com/simple/ 检查是否可以从Anaconda存储库中获得尚未安装的名为“opencv”的软件包（必须连接到Internet）: 1conda search opencv Conda在Anaconda存储库中显示具有该名称的所有软件包的列表，因此我们知道它可用。 向当前环境中安装新包: 1conda install opencv 在已安装的包列表里检查是否包安装成功: 1conda list","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"python","slug":"cs/python","permalink":"https://silencht.github.io/categories/cs/python/"},{"name":"conda","slug":"cs/python/conda","permalink":"https://silencht.github.io/categories/cs/python/conda/"}]},{"title":"rosdep-update","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/ros/rosdep-update/","text":"ROS rosdep update报错解决方法 一、问题描述 操作系统：Ubuntu18.04 ROS版本：melodic 错误描述： rosdep init 和 rosdep update命令因网络原因无法正确执行，错误信息可能如下： 123456789[rosdep init]ERROR: cannot download default sources list from:https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.listWebsite may be down.[rosdep update]reading in sources list data from /etc/ros/rosdep/sources.list.dERROR: unable to process source [https://raw.github.com/ros/rosdistro/master/rosdep/osx-homebrew.yaml]: &lt;urlopen error [Errno 111] Connection refused&gt;…… 二、解决方法 放弃从网络自动下载文件，手动下载所需文件到本地，然后在本地执行脚本即可。 步骤如下： 2.1 下载文件到本地 1234# 假设你的用户名为 usernamecd ~git clone https://github.com/ros/rosdistro.git# 此时主文件夹目录下出现rosdistro文件夹，路径为/home/username/rosdistro 2.2 创建20-default.list文件 12345678910111213141516# 手动创建脚本所需的文件sudo mkdir -p /etc/ros/rosdep/sources.list.dcd /etc/ros/rosdep/sources.list.dsudo gedit 20-default.list# 输入以下内容并保存：# os-specific listings firstyaml file:///home/username/rosdistro/rosdep/osx-homebrew.yaml osx# genericyaml file:///home/username/rosdistro/rosdep/base.yamlyaml file:///home/username/rosdistro/rosdep/python.yamlyaml file:///home/username/rosdistro/rosdep/ruby.yamlgbpdistro file:///home/username/rosdistro/releases/fuerte.yaml fuerte# newer distributions (Groovy, Hydro, ...) must not be listed anymore, they are being fetched from the rosdistro index.yaml instead 2.3 修改脚本URL为本地路径 1234cd /usr/lib/python2.7/dist-packages/rosdep2/sudo gedit gbpdistro_support.py# 将 FUERTE_GBPDISTRO_URL 后面路径改为如下，并保存FUERTE_GBPDISTRO_URL = &#x27;file:///home/username/rosdistro/releases/fuerte.yaml&#x27; 1234cd /usr/lib/python2.7/dist-packages/rosdep2/sudo gedit rep3.py# 将 REP3_TARGETS_URL 后面路径改为如下，并保存REP3_TARGETS_URL = &#x27;file:///home/username/rosdistro/releases/targets.yaml&#x27; 1234cd /usr/lib/python2.7/dist-packages/rosdistro/sudo gedit __init__.py# 将 DEFAULT_INDEX_URL 后面路径改为如下，并保存DEFAULT_INDEX_URL = &#x27;file:///home/username/rosdistro/index-v4.yaml&#x27; 2.4 启动更新命令 1234567891011121314151617181920212223242526rosdep update# 输出如下：reading in sources list data from /etc/ros/rosdep/sources.list.dHit file:///home/silencht/rosdistro/rosdep/osx-homebrew.yamlHit file:///home/silencht/rosdistro/rosdep/base.yamlHit file:///home/silencht/rosdistro/rosdep/python.yamlHit file:///home/silencht/rosdistro/rosdep/ruby.yamlHit file:///home/silencht/rosdistro/releases/fuerte.yamlQuery rosdistro index file:///home/silencht/rosdistro/index-v4.yamlSkip end-of-life distro &quot;ardent&quot;Skip end-of-life distro &quot;bouncy&quot;Skip end-of-life distro &quot;crystal&quot;Skip end-of-life distro &quot;dashing&quot;Skip end-of-life distro &quot;eloquent&quot;Add distro &quot;foxy&quot;Add distro &quot;galactic&quot;Skip end-of-life distro &quot;groovy&quot;Skip end-of-life distro &quot;hydro&quot;Skip end-of-life distro &quot;indigo&quot;Skip end-of-life distro &quot;jade&quot;Skip end-of-life distro &quot;kinetic&quot;Skip end-of-life distro &quot;lunar&quot;Add distro &quot;melodic&quot;Add distro &quot;noetic&quot;Add distro &quot;rolling&quot;updated cache in /home/silencht/.ros/rosdep/sources.cache","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"ros","slug":"robot/ros","permalink":"https://silencht.github.io/categories/robot/ros/"}]},{"title":"init-ubuntu","date":"2023-11-29T02:08:16.537Z","path":"wiki/cs/system/Unix&Linux/init-ubuntu/","text":"1、安装常用软件 搜狗输入法（搜狗输入法官网） 注：搜狗输入法不支持Nvidia开发板的ARM64架构，所以输入法参见nvidia_jetson_agx_xavier文件 typora（typora官网） 注：typora不支持ARM64架构。所以Markdown阅读器参见nvidia_jetson_agx_xavier文件 visual studio code（visual studio code官网） 注：英伟达板子应该下载Linux，Arm64版本的 chrome（谷歌浏览器官网） 注：英伟达板子自带chromium 2、换源 普通电脑换源 123456789101112131415161718# 首先备份源列表sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup# 打开sources.list文件sudo gedit /etc/apt/sources.list#编辑/etc/apt/sources.list文件, 删除原文内容，复制添加下列镜像源# 清华源deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse#更新软件列表sudo apt-get update NVIDIA Jetson AGX Xavier开发板ARM架构CPU系统换源 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb [arch=arm64] https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiversedeb [arch=arm64] https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiversedeb [arch=arm64] https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiversedeb [arch=arm64] https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse 一定要指明架构：[arch=arm64] ，不然 apt-get update 会陷入 amd等架构目录的获取。 3、安装基础工具 123456789101112131415161718192021222324252627282930313233343536373839#安装C/C++等软件依赖sudo apt-get install build-essential#安装vimsudo apt install vim#测试vim #进入后输入:q按回车退出#安装gitsudo apt install git-all#测试git --version#安装miniconda#下载网址https://docs.conda.io/en/latest/miniconda.html ，根据系统和版本自行选择#下载好一个后缀为*.sh文件，添加权限并运行，输入命令（无权限的话，加上sudo提升权限）chmod 777 *.sh #*为你刚下载的路径+文件名bash *.sh#根据脚本提示输入enter、yes等回答#测试是否安装成功，若有conda信息说明成功conda#若显示conda命令不存在，先重启环境变量，然后继续测试conda命令source ~/.bashrcconda#若还是显示conda命令不存在，则自行修改环境变量，具体方法使用搜索引擎.#conda使用教程见 ./SilenchtNote/Conda/Conda.md#下载密码管理器enpass# For Ubuntu and Debian based systems，To install Enpass, add a new repository to /etc/apt/sources.list:sudo -iecho &quot;deb https://apt.enpass.io/ stable main&quot; &gt; /etc/apt/sources.list.d/enpass.list# And import key that is used to sign the release:wget -O - https://apt.enpass.io/keys/enpass-linux.key | apt-key add -# After that, you can install Enpass as any other software package:apt-get updateapt-get install enpassexit# Seclect WebDav and input URL: https://dav.jianguoyun.com/dav/# input username and password","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"system","slug":"cs/system","permalink":"https://silencht.github.io/categories/cs/system/"},{"name":"Unix&Linux","slug":"cs/system/Unix-Linux","permalink":"https://silencht.github.io/categories/cs/system/Unix-Linux/"}]},{"title":"gtk2-symbols-debug","date":"2023-11-29T02:08:16.537Z","path":"wiki/cs/system/bug/gtk2-symbols-debug/","text":"GTK+ 2.x symbols detected. Using GTK+ 2.x and GTK+ 3 in the same process is not supported 1、环境描述 操作系统：ubuntu18.04.5 LTS （AMD64） 相关软件：ORB-SLAM2、ROS-melodic（OpenCV：3.2.0 installed）、OpenCV：3.4.15（手动编译，编译时CMake添加参数：-DWITH_GTK_2_X=ON） ROS使用包（与错误相关）：opencv_bridge、image_geometry 编译指令：catkin_make 注：实际这里的orbslam2是经过修改且加了很多其他功能的 2、命令行错误信息 123456/usr/bin/ld: warning: libopencv_calib3d.so.3.2, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_calib3d.so.3.4/usr/bin/ld: warning: libopencv_features2d.so.3.2, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_features2d.so.3.4/usr/bin/ld: warning: libopencv_highgui.so.3.2, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_highgui.so.3.4/usr/bin/ld: warning: libopencv_core.so.3.2, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_core.so.3.4/usr/bin/ld: warning: libopencv_ml.so.3.4, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_ml.so.3.2/usr/bin/ld: warning: libopencv_imgcodecs.so.3.2, needed by /usr/lib/x86_64-linux-gnu/libopencv_highgui.so.3.2.0, may conflict with libopencv_imgcodecs.so.3.4 1(Display:1072): Gtk-ERROR **: 18:03:31.545: GTK+ 2.x symbols detected. Using GTK+ 2.x and GTK+ 3 in the same process is not supported 3、排查过程 该问题陆续困扰我很久，简要说一下正确解决路线： 3.1、stackoverflow相关问题 通过回答可得知，程序中有多个库用了不同版本的GTK库，因此造成了冲突。因此，首先要排查到底是哪些库的使用与GTK相关。 回答介绍了一个查看动态库依赖的命令：ldd （list dynamic dependencies） 作用：列出程序或动态库的依赖关系。 例如 查看 test 程序运行所依赖的库: 123456789/opt/app/todeav1/test$ldd testlibstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003996400000)libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00000039a5600000)libc.so.6 =&gt; not found#第一列：程序需要依赖什么库#第二列: 程序所需库在系统中的路径位置#第三列：即括号中的数，为库加载的开始地址#如果需要某个库，但程序在系统找不到对应的库，会出现第5行的not found信息 3.2、利用ldd命令排查 1、GTK库 通过查阅GTK官网得知，GTK 是一款跨平台的为创造图形化用户界面而设计的工具库。 Offering a complete set of UI elements, GTK is suitable for projects ranging from small one-off tools to complete application suites. 2、使用ldd命令排查库依赖 orbslam本身用的库： orbslam2/lib/liborbslam2.so orbslam2/Thirdparty/DBoW2/lib/libDBoW2.so orbslam2/Thirdparty/g2o/lib/libg2o.so opencv库 pangolin、eigen3等orbslam所需的库 ros功能包的相关库等。 首先 通过使用ldd liborbslam2.so | grep gtk命令发现 liborbslam2.so 确实链接了gtk2和gtk3两个版本的库，输出类似如下： 12libgtk-x11-2.0.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgtk-x11-2.0.so.0（0x00*）libgtk-3.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgtk-3.so.0（0x00*） 缩小排查范围，分析：因为GTK是UI工具库，因此较大可能是因为涉及到绘制界面、图形等相关的库依赖出现问题。因此初步推断是opencv、pangolin等库依赖出现问题。 简单排查pangolin库发现没有出现问题。 通过查看orbslam源码中system.h、viewer.h、mapdrawer.h等文件，发现引用了opencv_highgui.h等绘制ui的相关头文件。 定位liborbslam2.so依赖的opencv库，使用命令ldd liborbslam2.so | grep opencv，输出如下： 12345678910111213141516silencht@silencht:~/slam_ws/src/orbslam2/lib$ ldd libslam_semantic_nav_ros.so | grep libopencv libopencv_calib3d.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_calib3d.so.3.2 (0x00007fce94e1c000) libopencv_core.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_core.so.3.2 (0x00007fce949e1000) libopencv_features2d.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_features2d.so.3.2 (0x00007fce9472c000) libopencv_highgui.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_highgui.so.3.2 (0x00007fce94520000) libopencv_imgproc.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_imgproc.so.3.2 (0x00007fce93fcf000) libopencv_video.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_video.so.3.2 (0x00007fce93d6c000) libopencv_text.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_text.so.3.2 (0x00007fce93a4d000) libopencv_core.so.3.4 =&gt; /usr/local/lib/libopencv_core.so.3.4 (0x00007fce8fef8000) libopencv_imgcodecs.so.3.4 =&gt; /usr/local/lib/libopencv_imgcodecs.so.3.4 (0x00007fce8fa9f000) libopencv_ml.so.3.4 =&gt; /usr/local/lib/libopencv_ml.so.3.4 (0x00007fce8f3e6000) libopencv_flann.so.3.4 =&gt; /usr/local/lib/libopencv_flann.so.3.4 (0x00007fce8d785000) libopencv_flann.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_flann.so.3.2 (0x00007fce8c287000) libopencv_imgcodecs.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2 (0x00007fce8a13f000) libopencv_ml.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_ml.so.3.2 (0x00007fce896df000) libopencv_imgproc.so.3.4 =&gt; /usr/local/lib/libopencv_imgproc.so.3.4 (0x00007fce82950000) 发现一个问题，由于ROS系统安装的时候自带了OpenCV 3.2.0 （lib文件安装位置位于 /usr/lib/x86_64-linux-gnu/），而我自用的OpenCV 3.4.15 （安装在/usr/local/lib/）。在编译链接orbslam工程的时候，由于不恰当的配置造成了一部分文件引用了OpenCV 3.2.0，而一部分文件引用了OpenCV 3.4.15 。 那么查看3.2.0版本的 libopencv_highgui.so 依赖（实际上为了稳妥起见，我将所有依赖的OpenCV库文件都排查过一遍）， 12cd /usr/lib/x86_64-linux-gnu/ldd libopencv_highgui.so.3.2 | grep gtk 从输出可发现，确实是3.2.0的libopencv_highgui.so文件依赖了gtk3版本库，而其他文件均依赖gtk2版本库。在绘制界面时，gtk2和3版本同时调用，产生了冲突。 问题转到：查找ROS自带 OpenCV 库与 自行安装 OpenCV 冲突问题。 单纯 修改/opt/ros/kinetic/share/cv_bridge/cmake下*Config.cmake文件版本库，或者更改CmakeLists.txt中的 find_package() 并不能完全解决问题。 经排查，是编译orbslam工程的CmakeLists.txt中使用的ros功能包 opencv_bridge 和 image_geometry 的库依赖了OpenCV 3.2.0 4、解决办法 懒得详细写了。俩方法： 4.1、单独卸载这俩ROS功能包 去github下载相应的包，放到ros工作空间的src文件夹下，配置他们的CmakeLists.txt文件中相应的编译路径，使他们编译的时候使用自己安装的 OpenCV 3.4.15 库。 4.2、直接卸载ros自带的OpenCV（我使用的） 简述： 卸载该 OpenCV（即3.2.0版本） 会使得所有依赖此OpenCV 的ROS功能包全部卸载。卸载完成后，去github下载工程所需要的缺失的功能包（opencv_bridge 和 image_geometry），放到ros工作空间的src文件夹下，配置他们的CmakeLists.txt文件，使他们编译的时候使用自己安装的 OpenCV 库。 步骤： 1、使用 dpkg --get-selections | grep opencv 指令查找所有opencv相关包 输出可能如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142libopencv-calib3d-dev:amd64 installlibopencv-calib3d3.2:amd64 installlibopencv-contrib-dev:amd64 installlibopencv-contrib3.2:amd64 installlibopencv-core-dev:amd64 installlibopencv-core3.2:amd64 installlibopencv-dev installlibopencv-features2d-dev:amd64 installlibopencv-features2d3.2:amd64 installlibopencv-flann-dev:amd64 installlibopencv-flann3.2:amd64 installlibopencv-highgui-dev:amd64 installlibopencv-highgui3.2:amd64 installlibopencv-imgcodecs-dev:amd64 installlibopencv-imgcodecs3.2:amd64 installlibopencv-imgproc-dev:amd64 installlibopencv-imgproc3.2:amd64 installlibopencv-ml-dev:amd64 installlibopencv-ml3.2:amd64 installlibopencv-objdetect-dev:amd64 installlibopencv-objdetect3.2:amd64 installlibopencv-photo-dev:amd64 installlibopencv-photo3.2:amd64 installlibopencv-shape-dev:amd64 installlibopencv-shape3.2:amd64 installlibopencv-stitching-dev:amd64 installlibopencv-stitching3.2:amd64 installlibopencv-superres-dev:amd64 installlibopencv-superres3.2:amd64 installlibopencv-ts-dev:amd64 installlibopencv-video-dev:amd64 installlibopencv-video3.2:amd64 installlibopencv-videoio-dev:amd64 installlibopencv-videoio3.2:amd64 installlibopencv-videostab-dev:amd64 installlibopencv-videostab3.2:amd64 installlibopencv-viz-dev:amd64 installlibopencv-viz3.2:amd64 installlibopencv3.2-java installlibopencv3.2-jni installpython-opencv installros-melodic-vision-opencv install 2、从输出中看到 libopencv-core3.2:amd64 install 使用命令 sudo apt-get remove libopencv-core3.2 卸载opencv3.2.0，注意不要添加 purge 参数 3、输完指令后会出现如下类似输出 123456下列软件包将被【卸载】： libopencv-dev ros-melodic-camera-calibration ros-melodic-compressed-depth-image-transport…………………………………………略 升级了 0 个软件包，新安装了 0 个软件包，要卸载 29 个软件包，有 204 个软件包未被升级。解压缩后将会空出 23.7 MB 的空间。您希望继续执行吗？ [Y/n] 仔细检查上述要卸载的软件包，若没问题输入Y，然后点回车。ROS里依赖OpenCV 的包全都会被卸载。 卸载完成后，新开一个终端，输入roscore，若成功运行，则基本无问题。 4、下载ros对应功能包 网址：https://github.com/ros-perception/vision_opencv 将 opencv_bridge 和 image_geometry ，放到ros工作空间的src文件夹下。 使用pkg-config --modversion opencv 查看当前 OpenCV 版本，输出3.4.15则无问题。 12$ pkg-config --modversion opencv3.4.15 5、后续 删除ROS工作空间之前的build和devel文件，重新编译（catkin_make）整个工程。 6、附 一些相关问题网页链接：1 2 3 4 5","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"system","slug":"cs/system","permalink":"https://silencht.github.io/categories/cs/system/"},{"name":"bug","slug":"cs/system/bug","permalink":"https://silencht.github.io/categories/cs/system/bug/"}]},{"title":"Ceres使用：A Simple Example","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/code/Ceres/A_Simple_Example/","text":"问题 现有曲线： $y = exp(ax^2+bx+c)+w $ \\(a,b,c\\) 为待优化曲线参数， \\(w\\) 为高斯噪声，满足分布： \\(w\\sim(0,\\sigma^2)\\) 现假设有N个已知的关于 \\(x，y\\) 的观测数据点，根据这些点拟合出曲线的参数 $a,b,c $ 。 思路 构建最小二乘问题： \\(min(a,b,c) \\sum_{i=1}^{N} || y_i - exp(a * x_i^2 + b * x_i + c) ||^2\\) 定义残差为 \\(e_i = y_i - exp(a * x_i^2 + b * x_i + c)\\) 求残差对每个待优化变量的导数： \\(de_i/da = - x_i^2 * exp(a * x_i^2 + b * x_i + c)\\) \\(de_i/db = - x_i * exp(a * x_i^2 + b * x_i + c)\\) \\(de_i/dc = - exp(a * x_i^2 + b * x_i + c)\\) 于是，雅可比矩阵为： \\(J_i = [de_i/da, de_i/db, de_i/dc]^T\\) Ceres编写流程 构建 cost funtion 计算模型类，设计残差计算仿函数 通过 cost funtion 构建待求解的最小二乘问题，向问题中添加误差项 配置求解器，开始优化 程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt;#include &lt;ceres/ceres.h&gt;#include &lt;chrono&gt;using namespace std;// 1. 构建代价函数cost funtion的计算模型struct CURVE_FITTING_COST &#123; CURVE_FITTING_COST(double x, double y) : _x(x), _y(y) &#123;&#125; //构造函数，输入为已知的观测值 // 设计残差计算仿函数，使用模板函数 template&lt;typename T&gt; bool operator()(const T *const abc, T *residual) const &#123; // 模型参数，有3维 residual[0] = T(_y) - ceres::exp(abc[0] * T(_x) * T(_x) + abc[1] * T(_x) + abc[2]); // e_i = y_i - exp(a * x_i^2 + b * x_i + c) return true; &#125; const double _x, _y; // x,y数据&#125;;int main(int argc, char **argv) &#123; double ar = 1.0, br = 2.0, cr = 1.0; // 真实参数值 double ae = 2.0, be = -1.0, ce = 5.0; // 估计参数值 int N = 100; // 数据点 double w_sigma = 1.0; // 噪声Sigma值 double inv_sigma = 1.0 / w_sigma; cv::RNG rng; // OpenCV随机数产生器 vector&lt;double&gt; x_data, y_data; // 已知数据存储 for (int i = 0; i &lt; N; i++) &#123; double x = i / 100.0; x_data.push_back(x); y_data.push_back(exp(ar * x * x + br * x + cr) + rng.gaussian(w_sigma * w_sigma)); &#125; double abc[3] = &#123;ae, be, ce&#125;; // 初始化待估计参数 // 2. 构建最小二乘问题 ceres::Problem problem; // 向问题中添加误差项。1. 使用自动求导，模板参数：残差类型，输出维度，输入维度，维数要与前面struct中一致 for (int i = 0; i &lt; N; i++) &#123; problem.AddResidualBlock( new ceres::AutoDiffCostFunction&lt;CURVE_FITTING_COST, 1, 3&gt;(new CURVE_FITTING_COST(x_data[i], y_data[i])), nullptr, // 2. 核函数，这里不使用，为空 abc // 3. 待估计参数 ); &#125; // 3. 配置求解器 ceres::Solver::Options options; // 这里有很多配置项可以填 options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY; // 增量方程如何求解 options.minimizer_progress_to_stdout = true; // 输出到cout ceres::Solver::Summary summary; // 优化信息 chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); ceres::Solve(options, &amp;problem, &amp;summary); // 开始优化 chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); chrono::duration&lt;double&gt; time_used = chrono::duration_cast&lt;chrono::duration&lt;double&gt;&gt;(t2 - t1); cout &lt;&lt; &quot;solve time cost = &quot; &lt;&lt; time_used.count() &lt;&lt; &quot; seconds. &quot; &lt;&lt; endl; // 输出结果 cout &lt;&lt; summary.BriefReport() &lt;&lt; endl; cout &lt;&lt; &quot;estimated a,b,c = &quot;; for (auto a:abc) cout &lt;&lt; a &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; return 0;&#125; 总结自《视觉SLAM十四讲》","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"code","slug":"robot/code","permalink":"https://silencht.github.io/categories/robot/code/"},{"name":"Ceres","slug":"robot/code/Ceres","permalink":"https://silencht.github.io/categories/robot/code/Ceres/"}]},{"title":"ORB-SLAM2提升算法速度的优化手段列举","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/code/ORB-SLAM/ORB-SLAM2提升算法速度的优化手段列举/","text":"Author: [矩阵的秩] Link: [https://zhuanlan.zhihu.com/p/618562057] 1. 跟踪初始化求本质矩阵和单应矩阵时，开双线程进行并行加速 12345678910// 构造线程来计算H矩阵及其得分// thread方法比较特殊，在传递引用的时候，外层需要用ref来进行引用传递，否则就是浅拷贝thread threadH(&amp;Initializer::FindHomography, //该线程的主函数 this, ref(vbMatchesInliersH), ref(SH), ref(H));// 计算fundamental matrix并打分thread threadF(&amp;Initializer::FindFundamental,this,ref(vbMatchesInliersF), ref(SF), ref(F)); 2. 计算关键点灰度质心方向时，利用圆的对称性每次循环求解对称的两组值。最后使用FastAtan2函数加速计算角度 123456789101112131415161718192021222324static float IC_Angle(const Mat&amp; image, Point2f pt, const vector&lt;int&gt; &amp; u_max)&#123;//……部分代码略 for (int v = 1; v &lt;= HALF_PATCH_SIZE; ++v) &#123; int v_sum = 0; int d = u_max[v]; // 在坐标范围内挨个像素遍历，实际是一次遍历2个 // 假设每次处理的两个点坐标，中心线下方为(x,y),中心线上方为(x,-y) // 对于某次待处理的两个点：m_10 = Σ x*I(x,y) = x*I(x,y) + x*I(x,-y) = x*(I(x,y) + I(x,-y)) // 对于某次待处理的两个点：m_01 = Σ y*I(x,y) = y*I(x,y) - y*I(x,-y) = y*(I(x,y) - I(x,-y)) for (int u = -d; u &lt;= d; ++u) &#123; int val_plus = center[u + v*step], val_minus = center[u - v*step]; //在v（y轴）上，2行所有像素灰度值之差 v_sum += (val_plus - val_minus); //u轴（也就是x轴）方向上用u坐标加权和（u坐标也有正负符号），相当于同时计算两行 m_10 += u * (val_plus + val_minus); &#125; m_01 += v * v_sum; &#125; //为了加快速度还使用了fastAtan2()函数，输出为[0,360)角度，精度为0.3° return fastAtan2((float)m_01, (float)m_10);&#125; 3. 通过近邻窗口半径（提取特征时预先分配至网格）、投影后坐标窗口附近、Bow词袋等几种方法加速特征匹配 12345void Frame::AssignFeaturesToGrid()int SearchByBoW()//……//等等 4. 每次先将某些变量的倒数值计算出来存放至inverse变量，减少计算时除法的计算量 123456789101112131415161718192021//例如：1mvInvScaleFactors = mpORBextractorLeft-&gt;GetInverseScaleFactors();//2Frame::Frame(const cv::Mat &amp;imLeft, const cv::Mat &amp;imRight,……)&#123;……// 猜测是因为这种除法计算需要的时间略长，所以这里直接存储了这个中间计算结果 invfx = 1.0f/fx; invfy = 1.0f/fy;……&#125;//3int ORBmatcher::SearchByProjection(KeyFrame* pKF, cv::Mat Scw, const vector&lt;MapPoint*&gt; &amp;vpPoints, vector&lt;MapPoint*&gt; &amp;vpMatched, int th)&#123;…… const float invz = 1/p3Dc.at&lt;float&gt;(2); const float x = p3Dc.at&lt;float&gt;(0)*invz; const float y = p3Dc.at&lt;float&gt;(1)*invz;……&#125;//等等 5. 循环或函数开始前先把vector等变量reserve扩容至足够大，防止循环时因容量不够发生临时扩容 1234567891011121314151617181920212223//例如：1int ORBmatcher::SearchByBoW(KeyFrame* pKF,Frame &amp;F, vector&lt;MapPoint*&gt; &amp;vpMapPointMatches)&#123;…… // 特征点角度旋转差统计用的直方图 vector&lt;int&gt; rotHist[HISTO_LENGTH]; for(int i=0;i&lt;HISTO_LENGTH;i++) rotHist[i].reserve(500);……&#125;//2void Frame::AssignFeaturesToGrid()&#123;…… // 给存储特征点的网格数组 Frame::mGrid 预分配空间 int nReserve = 0.5f*N/(FRAME_GRID_COLS*FRAME_GRID_ROWS); // 开始对mGrid这个二维数组中的每一个vector元素遍历并预分配空间 for(unsigned int i=0; i&lt;FRAME_GRID_COLS;i++) for (unsigned int j=0; j&lt;FRAME_GRID_ROWS;j++) mGrid[i][j].reserve(nReserve);……&#125;//等等 6. 计算双目特征匹配时，只在某近邻像素行范围内查找，不全局暴力匹配 1234567891011121314151617181920212223242526272829303132void Frame::ComputeStereoMatches()&#123; /*两帧图像稀疏立体匹配（即：ORB特征点匹配，非逐像素的密集匹配，但依然满足行对齐） * 输入：两帧立体矫正后的图像img_left 和 img_right 对应的orb特征点集 * 过程： 1. 行特征点统计. 统计img_right每一行上的ORB特征点集，便于使用立体匹配思路(行搜索/极线搜索）进行同名点搜索, 避免逐像素的判断. 2. 粗匹配. 根据步骤1的结果，对img_left第i行的orb特征点pi，在img_right的第i行上的orb特征点集中搜索相似orb特征点, 得到qi 3. 精确匹配. 以点qi为中心，半径为r的范围内，进行块匹配（归一化SAD），进一步优化匹配结果 4. 亚像素精度优化. 步骤3得到的视差为uchar/int类型精度，并不一定是真实视差，通过亚像素差值（抛物线插值)获取float精度的真实视差 5. 最优视差值/深度选择. 通过胜者为王算法（WTA）获取最佳匹配点。 6. 删除离群点(outliers). 块匹配相似度阈值判断，归一化sad最小，并不代表就一定是正确匹配，比如光照变化、弱纹理等会造成误匹配 * 输出：稀疏特征点视差图/深度图（亚像素精度）mvDepth 匹配结果 mvuRight */…… // 右图特征点数量，N表示数量 r表示右图，且不能被修改 const int Nr = mvKeysRight.size(); // Step 1. 行特征点统计. 考虑到尺度金字塔特征，一个特征点可能存在于多行，而非唯一的一行 for(int iR = 0; iR &lt; Nr; iR++) &#123; // 获取特征点ir的y坐标，即行号 const cv::KeyPoint &amp;kp = mvKeysRight[iR]; const float &amp;kpY = kp.pt.y; // 计算特征点ir在行方向上，可能的偏移范围r，即可能的行号为[kpY + r, kpY -r] // 2 表示在全尺寸(scale = 1)的情况下，假设有2个像素的偏移，随着尺度变化，r也跟着变化 const float r = 2.0f * mvScaleFactors[mvKeysRight[iR].octave]; const int maxr = ceil(kpY + r); const int minr = floor(kpY - r); // 将特征点ir保证在可能的行号中 for(int yi=minr;yi&lt;=maxr;yi++) vRowIndices[yi].push_back(iR); &#125;……&#125; 7. 访问多线程加锁数据时，快速解锁，避免长时间独占共享数据 1234567891011//多线程编程注意，例如void LocalMapping::ProcessNewKeyFrame()&#123; &#123; unique_lock&lt;mutex&gt; lock(mMutexNewKFs); mpCurrentKeyFrame = mlNewKeyFrames.front(); mlNewKeyFrames.pop_front(); &#125; //上锁处理数据后，迅速解锁……//do anotherthing&#125; 8. 为不同作用的数据变量选用合适的容器 例如： 存储特征点的vector容器（频繁随机访问，变化较小：提取完成后很少再进行插入和删除） 存储共视关键帧mConnectedKeyFrameWeights的map容器。 mConnectedKeyFrameWeights是一个用于保存当前关键帧与其连接的其他关键帧之间权重信息的数据结构，其中键是连接的关键帧 ID，值是权重。此变量在 ORB-SLAM2 中被频繁地使用，因此它需要支持高效的查找和插入操作。 个人猜测，由于该变量的大小通常比较小，因此使用 std::map 。 std::map 是一种有序关联容器，它使用红黑树实现。由于它是一个有序容器，因此它提供了按键排序的功能，这使得它在查找和插入操作方面具有较高的效率。另外，由于红黑树的高效性能和可预测的内存占用，std::map 通常比 std::unordered_map 在处理小规模数据时表现更好。 四叉树均匀化分配特征点以及记录连接关键帧、局部地图点（如lLocalMapPoints）时使用list链表容器（不经常随机访问，而是遍历迭代访问，经常需要插入，list插入效率高） Map中的地图点和关键帧用set容器，因为经常需要做插入删除动作（印象中orbslam2这里地图点的删除没实现，可能会造成内存泄漏）set容器有序，无重复元素，方便转vector（返回关键帧集合转化的vector给可视化和BA优化程序用） 9. 待补充","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"code","slug":"robot/code","permalink":"https://silencht.github.io/categories/robot/code/"},{"name":"ORB-SLAM","slug":"robot/code/ORB-SLAM","permalink":"https://silencht.github.io/categories/robot/code/ORB-SLAM/"}]},{"title":"MapPoint::PredictScale()小记","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/code/ORB-SLAM/orb-slam2-MapPointPredictScale/","text":"0. 前提假设 每次相机拍摄后，将原始图像进行金字塔缩放操作，以获得尺度不变性。 图像金字塔层数nlevels设置为level 0 至 level 7，原始图像为level 0，最深层金字塔图像帧为level 7，共8层； 每层金字塔缩放系数因子scale为1.2； 常识：相机拍摄物体时，近大远小； 相机在参考关键帧 \\(RefKF\\) 位置首次 \"观测/提取/生成\" 了一个地图点 \\(M\\) 。 1. 地图点 观测距离范围 由参考帧在世界坐标系下的光心坐标和地图点 \\(M\\) 在世界系下的坐标可以算出两者之间的距离 \\(dist\\) 。 现在假设该距离值为 \\(dist=1\\) 米。 123456789101112131415161718192021void MapPoint::UpdateNormalAndDepth()&#123; // 略去部分无需关注的代码 // 获得观测到该地图点的所有关键帧、坐标等信息 pRefKF=mpRefKF; // 观测到该点的参考关键帧（第一次创建地图点时的关键帧） Pos = mWorldPos.clone(); // 地图点在世界坐标系中的位置 // 参考关键帧相机指向地图点的向量（在世界坐标系下的表示） cv::Mat PC = Pos - pRefKF-&gt;GetCameraCenter(); // 该地图点到参考关键帧相机光心的距离 const float dist = cv::norm(PC); const int level = pRefKF-&gt;mvKeysUn[observations[pRefKF]].octave;// 观测到该地图点的当前帧的特征点在金字塔的第几层 const float levelScaleFactor = pRefKF-&gt;mvScaleFactors[level]; // 当前金字塔层对应的尺度因子，scale^n，scale=1.2，n为层数 const int nLevels = pRefKF-&gt;mnScaleLevels; // 金字塔总层数，默认为8 &#123; //现假设dist=1 mfMaxDistance = dist\\*levelScaleFactor; // 观测到该点的距离上限 1\\*(1.2)^7=3.583 mfMinDistance = mfMaxDistance/pRefKF-&gt;mvScaleFactors[nLevels-1];// 观测到该点的距离下限 1/(1.2)^7=0.279 mNormalVector = normal/n; // 获得地图点平均的观测方向 &#125;&#125; 由以上信息可以推断： 要想使以后的相机（图像帧）可以再次观测到该地图点 \\(M\\) ，需要相机与地图点的距离在 [mfMinDistance，mfMaxDistance] 范围内。 分情况讨论： 1. mfMinDistance 假设，参考关键帧 \\(RefKF\\) （相机首次）\"提取/生成\"地图点 \\(M\\) 时的图像金字塔层级是level 0，也即地图点 \\(M\\) 所对应的特征点在参考帧中原始图像（level 0）中提取而来，且相机光心距离地图点为1米。 那么，相机（图像帧）可以拍摄到该地图点的最小距离为 \\(dist_{min}=dist*scale^{level+1-nlevels}=dist*scale^{0+1-8}=1*1.2^{-7}\\approx 0.279\\) ， 就是说，相机在距离该地图点 \\(M\\) 大约0.279米时拍摄的图像帧，经过7层缩放的level 7图像帧提取出的该地图点对应的特征点，与相机距离该地图点1米时在原始图像（level 0）提取的该地图点对应的特征点相似。 根据相机拍摄物体时近大远小原则，相机在距离 \\(M\\) 最近约0.279米时进行的图像金字塔的最深层缩放模拟形成的拍摄效果，类似于相机（参考帧）在距离约1米时对 \\(M\\) 拍摄的原始图像。 如果相机与 \\(M\\) 的距离小于0.279米，那么即使使用最深层的金字塔图像帧，也难以模拟出参考帧当时的拍摄效果。 2. mfMaxDistance 假设，参考关键帧 \\(RefKF\\) （相机首次）\"提取/生成\"地图点 \\(M\\) 时的图像金字塔层级是level 7，也即地图点 \\(M\\) 所对应的特征点在参考帧的最深层金字塔图像帧（level 7）中提取而来，且相机光心距离地图点为1米。 那么，相机（图像帧）可以拍摄到该地图点的最大距离为 \\(dist_{max}=dist*scale^{level}=dist*scale^{7}=1*1.2^{7}\\approx 3.583\\) ， 就是说，相机在距离该地图点 \\(M\\) 大约3.583米时拍摄的图像帧，在原始图像（level 0）提取出的该地图点对应的特征点，与相机距离该地图点1米时在最深层金字塔图像帧（level 7）提取的该地图点对应的特征点相似。 根据相机拍摄物体时近大远小原则，相机在距离 \\(M\\) 最远约3.583米时的原始图像形成的拍摄效果，类似于相机（参考帧）在距离约1米时对 \\(M\\) 拍摄的最深层金字塔图像帧（level 7）。 如果相机与 \\(M\\) 的距离大于3.583米，那么即使使用原始图像，也难以模拟出参考帧当时的拍摄效果。 2. 预测 地图点 金字塔尺度/层数 12345678910111213141516171819202122232425/\\*\\* \\* @brief 预测地图点对应特征点所在的图像金字塔尺度层数 \\* @param[in] currentDist 相机光心距离地图点距离 \\* @param[in] pKF 关键帧 \\* @return int 预测的金字塔尺度 \\*/int MapPoint::PredictScale(const float &amp;currentDist, KeyFrame\\* pKF)&#123; float ratio; &#123; unique\\_lock&lt;mutex&gt; lock(mMutexPos); // mfMaxDistance = ref\\_dist\\*levelScaleFactor 为参考帧考虑上尺度后的距离 // ratio = mfMaxDistance/currentDist = ref\\_dist/cur\\_dist ratio = mfMaxDistance/currentDist; &#125; // 取对数 int nScale = ceil(log(ratio)/pKF-&gt;mfLogScaleFactor); if(nScale&lt;0) nScale = 0; else if(nScale&gt;=pKF-&gt;mnScaleLevels) nScale = pKF-&gt;mnScaleLevels-1; return nScale;&#125; 明白了地图点的观测距离范围，PredictScale()就容易理解： 现在假设：在非参考帧外的其他图像帧（如 \\(pKF\\) ）位置又观测/关联到了地图点 \\(M\\) ，且已知两者之间的距离为 \\(currentDist\\) （假设其位于观测距离范围内）。 那么，我们可以通过该距离 \\(currentDist\\) 反向推断，该地图点 \\(M\\) 最有可能从 \\(pKF\\) 的哪一层金字塔图像帧上提取而来。其实，这个推断过程与 地图点 观测距离范围 的推断过程正好相反。 例如，如果当前帧 \\(pKF\\) 的相机光心位置与地图点 \\(M\\) 的距离 \\(currentDist\\approx3.583\\) 米。那么由第1节（地图点 观测距离范围）反向推理可知，此时观测/关联到地图点 \\(M\\)的特征点最有可能是从当前帧 \\(pKF\\)的原始图像（level 0）提取而来的。其他金字塔缩放层提取的特征点所对应的地图点，基本上与 \\(pKF\\) 之间的距离会远大于3.583米。 这个推断过程用数学表述就是利用mfMaxDistance的公式 反向求解 \\(level\\) ，即 $dist_{max}=dist*scale^{level}\\ =scale^{level}\\ level= $ 代码中ratio便是 \\(\\frac{dist_{max}}{dist}\\) ，pKF-&gt;mfLogScaleFactor即为 \\(log(scale)\\) 。 故当前帧与地图点的观测近，那么使用的图像金字塔层级便高； 当前帧与地图点的观测远，那么使用的图像金字塔层级便低。 https://blog.csdn.net/ncepu_Chen/article/details/116784652","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"code","slug":"robot/code","permalink":"https://silencht.github.io/categories/robot/code/"},{"name":"ORB-SLAM","slug":"robot/code/ORB-SLAM","permalink":"https://silencht.github.io/categories/robot/code/ORB-SLAM/"}]},{"title":"使用ORB-SLAM构建octomap要注意的一些问题","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/code/ORB-SLAM/使用ORB-SLAM构建octomap要注意的一些问题/","text":"使用ORB-SLAM构建octomap要注意的一些问题 以ORB-SLAM系统做为基本框架，RGB-D相机作为基本输入。然后在此基础上，新建一个点云建图线程，将普通帧或关键帧对应的深度图像转换为三维点云，再发布至octomap_server功能包（或者直接仿照此功能包在线程中直接重写八叉树地图构建代码）是目前诸多开源代码的主要流程。 结构点云与非结构点云、深度值合法性、坐标参考系转换 ORB-SLAM与ROS系统的坐标系模式转换 octomap_server建图时部分方格无故消失问题 在复现此类仓库代码时，有一些问题需要注意，在此总结如下。 1. 结构点云与非结构点云、深度值合法性、坐标参考系转换 如上述代码，根据关键帧pkf的深度图想构建了一个位于相机坐标系下的三维点云团camera_pc_和一个位于世界坐标系下的三维点云团world_pc_。需要注意的问题，已在注释中说明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void PointCloudMapping::generatePointCloud(KeyFrame* pkf ,pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr camera_pc_ ,pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr world_pc_)&#123;//如果后续需要点云团在深度图像中的像素坐标信息（比如要和深度学习获取的目标检测框、语义分割信息等进行处理）//那么可以生成此类“结构化点云（organized point cloud）”来保留点云像素坐标信息。//如果不需要像素坐标信息，那么可以直接略过以下三行代码，直接对深度图像进行处理计算，然后往点云团对象中//push_back点云点元素，如高翔老师仓库的实现：//https://github.com/gaoxiang12/ORBSLAM2_with_pointcloud_map/blob/cf94d66a9e4253abd66398c7ef461a7a903efffe/ORB_SLAM2_modified/src/pointcloudmapping.cc#L79//is_dense设置为false的原因是深度相机有很多位置的信息/点云不可信（不合法），做此标记后，后续的点云处理算法会//知道该点云团内部还有非法点，从而进行单独处理，避免算法因异常点引发崩溃 camera_pc_-&gt;resize(pkf-&gt;mImDep.rows * pkf-&gt;mImDep.cols); camera_pc_-&gt;width = pkf-&gt;mImDep.cols; camera_pc_-&gt;height = pkf-&gt;mImDep.rows; camera_pc_-&gt;is_dense = false;//false if have points are invalid (e.g., have NaN or Inf values).//有部分开源代码为节省算力，会对深度图进行跨点采样。具体做法是设置一个步长int stride = 3;然后嵌套for循环处的//行列m+=1和n+=1均改为m+=stride和n+=stride。 for ( int m=0; m&lt;pkf-&gt;mImDep.rows; m+=1) &#123; for ( int n=0; n&lt;pkf-&gt;mImDep.cols; n+=1) &#123; float d = pkf-&gt;mImDep.ptr&lt;float&gt;(m)[n];//在深度图像中得到深度值d后，需要对其进行合法性判断（深度相机的有效深度范围）。//多数仓库代码实现均为简单的深度相机值阈值判断：//如 if (d &lt; 0.01 || d&gt;10)，此处的0.01和10对应下述代码的camera_valid_depth_Min和camera_valid_depth_Max。//根据我的测试，如果d为nan值无法通过该范围滤除，因此最好判断条件里再加上nan值判断语句isnan(d) if(d &lt; camera_valid_depth_Min || d &gt; camera_valid_depth_Max || isnan(d)) continue; size_t index = m * pkf-&gt;mImDep.cols + n; camera_pc_-&gt;points[index].z = d; camera_pc_-&gt;points[index].x = ( n - pkf-&gt;cx) * d / pkf-&gt;fx; camera_pc_-&gt;points[index].y = ( m - pkf-&gt;cy) * d / pkf-&gt;fy; camera_pc_-&gt;points[index].r = pkf-&gt;mImRGB.ptr&lt;uchar&gt;(m)[n*3+2]; camera_pc_-&gt;points[index].g = pkf-&gt;mImRGB.ptr&lt;uchar&gt;(m)[n*3+1]; camera_pc_-&gt;points[index].b = pkf-&gt;mImRGB.ptr&lt;uchar&gt;(m)[n*3+0]; &#125; &#125;//上述点云团坐标均位于相机坐标系下，如果要得到世界系下的点云团，则使用关键帧的位姿变换矩阵Twc，将其转换至世界系。即，//P_&#123;world) = Twc * P_&#123;camera&#125;//world_pc_便为世界系下的点云团 Eigen::Isometry3d Twc = ORB_SLAM2::Converter::toSE3Quat( pkf-&gt;GetPoseInverse() ); pcl::transformPointCloud(*camera_pc_, *world_pc_, Twc.matrix());//3D Semantic Object Detect if(pkf-&gt;mvObjects2D.size() &gt; 0 &amp;&amp; is_octo_semantic_map_construction) mpDetector3D-&gt;Detect(pkf-&gt;mvObjects2D,pkf-&gt;mImDep,world_pc_);//如果要进行全局三维点云地图重建 if(is_global_pc_reconstruction) slam_to_ros_mode_transform(*world_pc_, *world_pc_);&#125; 2. ORB-SLAM与ROS系统的坐标系模式转换 此处可参考此文章：ORB_SLAM到ROS坐标转换。用图来说明便是， SLAM坐标系与ROS坐标系之间的转换 在三维点云重建功能中，一般实现方法是：将连续到来的每张关键帧计算得到的世界系部分点云团world_pc_都累加到一个global_map_pc对象中，然后通过ROS将全图点云团global_map_pc发布至Rviz进行可视化。 问题是，即使从关键帧的深度图中导出了该帧的世界系点云团world_pc_，此世界系位姿也是相对于SLAM系统的初始帧（默认初始帧位姿为世界系单位阵）而言的。它的坐标系表示方式是上图中上方的SLAM（Z超前，X朝右，Y朝下）模式的。如果直接将该点云发布至Rviz进行可视化，那么此点云的显示相对于Rviz的grid网格是有一个错位颠倒的变换的，看起来是“垂直于”网格地面。所以我们发布前需要统一位姿表示模式。 这就是做三维点云地图重建时，代码里要做一个T_slam_to_ros的位姿转换的原因：从SLAM位姿模式的Z、-X、-Y转变为ROS模式下的X、Y、Z，以便在Rviz中正确显示。 123456789101112131415//如果要进行全局三维点云地图重建if(is_global_pc_reconstruction) slam_to_ros_mode_transform(*world_pc_, *world_pc_);//将点云位姿从SLAM表示模式转换至ROS表示模式void PointCloudMapping::slam_to_ros_mode_transform(pcl::PointCloud&lt;pcl::PointXYZRGB&gt;&amp; source, pcl::PointCloud&lt;pcl::PointXYZRGB&gt;&amp; out)&#123; Eigen::Matrix4f T_slam_to_ros; T_slam_to_ros&lt;&lt; 0,0,1,0, -1,0,0,0, 0,-1,0,0, 0,0,0,0; Eigen::Affine3f transform(T_slam_to_ros); pcl::transformPointCloud(source, out, transform);&#125; 同理，向ROS发布当前相机位姿，也是如此处理： 1234567891011121314151617181920212223242526272829303132Camera_Pose = SLAM.TrackRGBD(imRGB,imD,tframe);//从Track获得当前帧位姿，即TcwPub_CamPose(Camera_Pose); //将该位姿发布，在Rviz中进行显示void Pub_CamPose(cv::Mat &amp;pose)&#123; cv::Mat Rwc(3,3,CV_32F); cv::Mat twc(3,1,CV_32F); Eigen::Matrix&lt;double,3,3&gt; rotationMat; sg_slam_tf_broadcaster = new tf::TransformBroadcaster; if(pose.dims &lt; 2 || pose.rows &lt; 3)&#123; Rwc = Rwc;twc = twc; &#125;else&#123; Rwc = pose.rowRange(0,3).colRange(0,3).t();//pose is Tcw, so Rwc need .t() twc = -Rwc*pose.rowRange(0,3).col(3); rotationMat &lt;&lt; Rwc.at&lt;float&gt;(0,0), Rwc.at&lt;float&gt;(0,1), Rwc.at&lt;float&gt;(0,2), Rwc.at&lt;float&gt;(1,0), Rwc.at&lt;float&gt;(1,1), Rwc.at&lt;float&gt;(1,2), Rwc.at&lt;float&gt;(2,0), Rwc.at&lt;float&gt;(2,1), Rwc.at&lt;float&gt;(2,2); Eigen::Quaterniond Q(rotationMat); // sg-slam&#x27;s trans. x is twc.at&lt;float&gt;(0), y is twc.at&lt;float&gt;(1), z is twc.at&lt;float&gt;(2) // ros&#x27;s x 为 slam&#x27;s Z; ros&#x27;s y 为 slam&#x27;s -x; ros&#x27;s z 为 slam&#x27;s -y sg_slam_tf.setOrigin(tf::Vector3(twc.at&lt;float&gt;(2), -twc.at&lt;float&gt;(0), -twc.at&lt;float&gt;(1))); sg_slam_tf.setRotation(tf::Quaternion(Q.z(), -Q.x(), -Q.y(), Q.w())); //sg_slam_tf_broadcaster.sendTransform(tf::StampedTransform(sg_slam_tf, ros::Time::now(), &quot;/map&quot;, &quot;/camera&quot;)); //delete sg_slam_tf_broadcaster; Cam_Pose.header.stamp = ros::Time::now(); Cam_Pose.header.frame_id = &quot;/map&quot;; tf::pointTFToMsg(sg_slam_tf.getOrigin(), Cam_Pose.pose.position); tf::quaternionTFToMsg(sg_slam_tf.getRotation(), Cam_Pose.pose.orientation); CamPose_Pub.publish(Cam_Pose); &#125;&#125; 3. octomap_server建图时部分方格无故消失问题 通过点云建图线程向ROS发布关键帧的点云话题，然后使用octomap_server功能包订阅点云话题构建八叉树地图（或者可以根据octomap库api自己直接编写相关功能）进行增量地图构建时，地图在扩建的过程中，之前的部分体素格会出现”逐渐消失“情况。如： DS-SLAM的这部分代码 DS-SLAM发布点云话题相关代码 1234567891011121314151617for ( size_t i=lastKeyframeSize; i&lt;N ; i++ )&#123; PointCloud::Ptr p = generatePointCloud( keyframes[i],semanticImgs_color[i], semanticImgs[i],colorImgs[i], depthImgs[i] ); *KfMap += *p; *globalMap += *p; &#125; PointCloud::Ptr tmp1(new PointCloud()); voxel.setInputCloud( KfMap ); voxel.filter( *tmp1 ); KfMap-&gt;swap( *tmp1 ); pcl_cloud_kf = *KfMap; Cloud_transform(pcl_cloud_kf,pcl_filter); pcl::toROSMsg(pcl_filter, pcl_point); pcl_point.header.frame_id = &quot;/pointCloud&quot;; pclPoint_pub.publish(pcl_point); 将点云团由相机系转换为世界系（SLAM模式）后，再由SLAM模式转换为ROS模式（ Cloud_transform(,) ）。其点云参考系为“frame_id = \"/pointCloud\"”，随后便直接发布至ROS系统。在启动octomap建图时，要先使用roslaunch启动两个节点： 一是octomap_server，其参考系为/map 1&lt;param name=&quot;frame_id&quot; type=&quot;string&quot; value=&quot;/map&quot; /&gt; 二是transform.launch，作用是向ROS输出一个全局静态TF变换，即参考系/pointCloud与参考系/map（实际上，在这里map系就是默认的Rviz世界系）的固定变换为\"0.195 -0.095 0.9 0 0 0\"（x y z r p y表示）。 1&lt;node pkg=&quot;tf&quot; type=&quot;static_transform\\_publisher&quot; name=&quot;map&quot; args=&quot;0.195 -0.095 0.9 0 0 0 /map /pointCloud 70&quot; &gt; 以上便是DS-SLAM发布点云至octomap_server增量建图的基本思路。 接下来，看octomap_server源码中接收点云建图的相关代码。octomap_server节点启动，对象构建时，参数设置完毕后便会启用回调函数进行无限循环（#179），回调函数上方是两个话题订阅器，顾名思义，一个订阅点云话题，一个订阅点云位姿tf话题。 123456//https://github.com/OctoMap/octomap_mapping/blob/kinetic-devel/octomap_server/src/OctomapServer.cpp//#L179 m_pointCloudSub = new message_filters::Subscriber&lt;sensor_msgs::PointCloud2&gt; (m_nh, &quot;cloud_in&quot;, 5); m_tfPointCloudSub = new tf::MessageFilter&lt;sensor_msgs::PointCloud2&gt; (*m_pointCloudSub, m_tfListener, m_worldFrameId, 5); m_tfPointCloudSub-&gt;registerCallback(boost::bind(&amp;OctomapServer::insertCloudCallback, this, boost::placeholders::_1)); 回调函数的主要功能在代码中注释如下： 1234567891011121314151617181920212223242526272829303132333435363738void OctomapServer::insertCloudCallback(const sensor_msgs::PointCloud2::ConstPtr&amp; cloud)&#123; ros::WallTime startTime = ros::WallTime::now(); // ground filtering in base frame PCLPointCloud pc; // input cloud for filtering and ground-detection pcl::fromROSMsg(*cloud, pc);//从ROS系统的话题中订阅获取传感器参考系（此文中即相机系）到世界系的位姿变换放入sensorToWorldTf tf::StampedTransform sensorToWorldTf; try &#123; m_tfListener.lookupTransform(m_worldFrameId, cloud-&gt;header.frame_id, cloud-&gt;header.stamp, sensorToWorldTf); &#125; catch(tf::TransformException&amp; ex)&#123; ROS_ERROR_STREAM( &quot;Transform error of sensor data: &quot; &lt;&lt; ex.what() &lt;&lt; &quot;, quitting callback&quot;); return; &#125; Eigen::Matrix4f sensorToWorld; pcl_ros::transformAsMatrix(sensorToWorldTf, sensorToWorld);//格式转换 // 一些滤波处理（部分代码省略） pcl::PassThrough&lt;PCLPoint&gt; pass_x; …… if (m_filterGroundPlane)&#123; //如果设置了滤除地面，部分处理操作（省略） …… &#125; else &#123; // directly transform to map frame:将点云从传感器坐标系变换至世界系 pcl::transformPointCloud(pc, pc, sensorToWorld); // 滤波处理（省略） …… // pc_nonground is empty without ground segmentation pc_ground.header = pc.header; pc_nonground.header = pc.header; &#125;//将点云插入octomap，进行增量更新 insertScan(sensorToWorldTf.getOrigin(), pc_ground, pc_nonground); ……&#125; 点云插入增量更新代码如下， 1234567891011121314151617181920212223242526272829303132333435void OctomapServer::insertScan(const tf::Point&amp; sensorOriginTf, const PCLPointCloud&amp; ground, const PCLPointCloud&amp; nonground)&#123; point3d sensorOrigin = pointTfToOctomap(sensorOriginTf);…… // instead of direct scan insertion, compute update to filter ground: KeySet free_cells, occupied_cells; // insert ground points only as free: …… // 对于所有非地面点云: free on ray, occupied on endpoint: for (PCLPointCloud::const_iterator it = nonground.begin(); it != nonground.end(); ++it)&#123; point3d point(it-&gt;x, it-&gt;y, it-&gt;z); if ((m_minRange &gt; 0) &amp;&amp; (point - sensorOrigin).norm() &lt; m_minRange) continue; // maxrange check if ((m_maxRange &lt; 0.0) || ((point - sensorOrigin).norm() &lt;= m_maxRange) ) &#123; // free cells if (m_octree-&gt;computeRayKeys(sensorOrigin, point, m_keyRay))&#123; free_cells.insert(m_keyRay.begin(), m_keyRay.end()); &#125; // occupied endpoint OcTreeKey key; if (m_octree-&gt;coordToKeyChecked(point, key))&#123; occupied_cells.insert(key); …… &#125; else &#123;// ray longer than maxrange:; …… &#125; &#125; &#125; // mark free cells only if not seen occupied in this cloud…… // now mark all occupied cells:…………&#125; 从OctomapServer::insertScan()函数中可以看出，每次插入点云时，以传感器在世界系下的原点为起点，以点云（世界系下）坐标为终点，更新octomap。即，从原点到终点光线ray上的所有点设置为空闲free，点云所在点（终点）设置为占据occupied状态（free on ray, occupied on endpoint），如下图所示。 https://www.arminhornung.de/Research/pub/hornung13roscon.pdf 综上，那么DS-SLAM以及一些类似的问题[1] [2]出现体素格莫名其妙消失（清除cleared)的原因可以分析如下： 在SLAM系统生成点云时，在SLAM中便将3D点云转换为了世界系（此时均为SLAM位姿模式），然后又将SLAM模式转换为ROS模式（见本文第二节），最后将点云消息进行发布。 octomap_server功能包的建图逻辑是订阅 【相机系下的3D点云信息】、【与该点云信息有关的传感器系（本文即相机系）到世界系的位姿变换 tf 】两种数据（octomap_server默认所有消息的位姿类型均为ROS模式）。 DS-SLAM并没有在SLAM系统中发布相机系到世界系的位姿变换 tf ，而且它将相机系下的3D点云（SLAM模式）手动转换为了世界系下的3D点云（ROS模式）并发布出去。 为了使得octomap_server可以处理DS-SLAM发布的点云数据，DS-SLAM直接roslaunch了一个tf静态变换文件，持续向ROS发布相机系/pointCloud到世界系/map的位姿变换tf，只不过这个tf除了一些xyz的单纯位置变换外，并没有其他的旋转操作。 1&lt;node pkg=&quot;tf&quot; type=&quot;static_transform_publisher&quot; name=&quot;map&quot; args=&quot;0.195 -0.095 0.9 0 0 0 /map /pointCloud 70&quot; &gt; 两种数据齐备，那么octomap_server此时确实已经可以运行。不过这里有一个小小的问题，那便是： 由于每次octomap_server接收到的相机系到世界系的位姿变换tf是DS-SLAM手动发布的静态信息，因此octomap_server每次处理3D点云并对octomap进行增量更新时，它所参考的传感器原点（上文图中的sensor origin）一直是\"0.195 -0.095 0.9 0 0 0\"这个相对于世界系的静态坐标，从来不会发生变化。 再由八叉树更新原理可知，每次的空闲和占据状态是根据传感器真正原点到点云坐标点的“光线”（下图中以true sensor origin起始的黑色箭头）来进行处理的。本来每次的原点sensor origin都应该是传感器实时相对于世界系的真实原点，而点云则是基于传感器系下的坐标，然后回调函数insertCloudCallback()会自己对这些数据进行坐标系变换处理。 正确的传感器原点、错误的传感器原点设置 然而，如上图所示，现在DS-SLAM的部分代码一边对点云的坐标系和模式进行了手动处理（点云变为了ROS模式的世界系坐标），一边发布了一个静态tf变换对octomap_server进行“蒙蔽”。这就导致一旦相机拍摄到已经占据的体素格的点云，新产生的光线线路（图中绿色箭头）上所有的体素格（无论占据与否）都将更新为空闲free。那么便会有一部分实际为占据状态的体素（如end point)，被更新为空闲状态。这就导致了部分体素“消失”的现象。 解决的方法很简单，按照octomap_server的正常使用方式使用即可： 1. generatePointCloud( )直接输出相机系下的点云团，只将SLAM位姿模式改为ROS模式即可，并将点云团参考系设为/camera. 2. 求解相机系到世界系的位姿变换tf（ROS模式的）， 3. 发布点云团和tf变换，标记tf参考系变换为/camera_sensor至/map 那么，octomap_server现在接收到的信息便是： 每个关键帧的位于相机系下的ROS模式点云团数据，参考系为/camera_sensor； 每个关键帧的自相机系/camera_sensor至世界系/map的ROS模式位姿变换tf； 然后octomap_server便可正确处理这些数据了。 还可参考代码或文章 高翔老师octomap tutor 本文部分代码摘自仓库 SG-SLAM 参考 [^](#ref_1_0)https://answers.ros.org/question/224488/octomap-decreasing-probabilities-when-obstacle-is-not-there-anymore/ [^](#ref_2_0)https://answers.ros.org/question/51837/octomap_server-globally-referenced-pointcloud-and-transform/","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"code","slug":"robot/code","permalink":"https://silencht.github.io/categories/robot/code/"},{"name":"ORB-SLAM","slug":"robot/code/ORB-SLAM","permalink":"https://silencht.github.io/categories/robot/code/ORB-SLAM/"}]},{"title":"特征点数量分配计算时缩放因子开方原因","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/code/ORB-SLAM/特征点数量分配计算时缩放因子开方原因/","text":"特征点数量分配计算时缩放因子开方原因 原始分配策略是根据图像金字塔每层图像的面积大小来决定特征点提取数量，故第 \\(i\\) 层图像应分配特征点数量为: \\(N_i=\\frac{N(1-s^2)}{1-(s^2)^m}(s^2)^i\\) ORB-SLAM2实际实现时（代码如下），将系数 \\(s^2\\) 替换为开方后的 \\(s\\) 12345678910111213141516171819//图片降采样缩放系数的倒数float factor = 1.0f / scaleFactor;//第0层图像应该分配的特征点数量float nDesiredFeaturesPerScale = nfeatures\\*(1 - factor)/(1 - (float)pow((double)factor, (double)nlevels));//用于在特征点个数分配的，特征点的累计计数清空int sumFeatures = 0;//开始逐层计算要分配的特征点个数，顶层图像除外（看循环后面）for( int level = 0; level &lt; nlevels-1; level++ )&#123; //分配 cvRound : 返回个参数最接近的整数值 mnFeaturesPerLevel[level] = cvRound(nDesiredFeaturesPerScale); //累计 sumFeatures += mnFeaturesPerLevel[level]; //乘系数 nDesiredFeaturesPerScale \\*= factor;&#125; 将 \\(s^2,s\\) 两种情况的每层特征分配数量分别计算如下： 1234567891011121314151617181920212223242526import mathN = 1000S = 1/1.2seq = [0,1,2,3,4,5,6,7]SumF = 0 # F is s^2SumK = 0 # K is sfor i in seq: F = N\\*(1-S\\*S)\\*math.pow(S\\*S,i)/(1-math.pow(S\\*S,8)) K = N\\*(1-S)\\*math.pow(S,i)/(1-math.pow(S,8)) SumF = SumF + F SumK = SumK + K print(&quot;F is %d ,&quot; % F,&quot;K is %d .&quot; % K ,end=&#x27;\\n&#x27;)print(&quot;SumF is %d &quot;% SumF,end=&#x27;\\n&#x27;)print(&quot;SumK is %d &quot;% SumK,end=&#x27;\\n&#x27;)#输出如下：F is 323 , K is 217 .F is 224 , K is 180 .F is 155 , K is 150 .F is 108 , K is 125 .F is 75 , K is 104 .F is 52 , K is 87 .F is 36 , K is 72 .F is 25 , K is 60 .SumF is 1000SumK is 1000 故猜测系数替换原因： 将 \\(s^2\\) 替换为 \\(s\\) 后，“高层”金字塔图像分配的特征点数量较以往有所增加，从而每层金字塔图像分配的数量会更为“均匀”，避免“高层”金字塔图像的特征数量过少导致匹配效果不好。","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"code","slug":"robot/code","permalink":"https://silencht.github.io/categories/robot/code/"},{"name":"ORB-SLAM","slug":"robot/code/ORB-SLAM","permalink":"https://silencht.github.io/categories/robot/code/ORB-SLAM/"}]},{"title":"Eigen代码第90行保证半正定的简单证明","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/note/slambook14/Eigen代码第90行保证半正定的简单证明/","text":"《视觉SLAM十四讲》第二版，3.2节 实践：Eigen代码第50页第90行代码如下 1matrix_NN = matrix_NN * matrix_NN.transpose(); //保证半正定 这里涉及一个简单的概念证明，如下： 【定义】矩阵 \\(A\\) 为 \\(n\\) 阶实数方阵，当且仅当存在非零的 \\(n\\) 维向量 \\(x\\) ，使得 \\(x^{T}Ax\\geq0\\) 恒成立，则矩阵 \\(A\\) 是一个半正定矩阵。 【\\(A^{T}A\\) 的半正定性证明】 设矩阵 \\(A\\) 为 \\(n\\) 阶可逆实矩阵， \\(x\\) 为任意非零 \\(n\\) 维向量， 则 \\(x^{T}(A^{T}A)x=(x^{T}A^{T})(Ax)=(Ax)^{T}(Ax)=||(Ax)||^{2}\\geq0\\) 即 \\(A^{T}A\\) 半正定","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"},{"name":"slambook14","slug":"robot/note/slambook14","permalink":"https://silencht.github.io/categories/robot/note/slambook14/"}]},{"title":"SLAMBOOK14-NOTE","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/note/slambook14/book-note/","text":"1、SLAM整体框架 SLAM整体框架图 1.1 传感器信息读取 在视觉SLAM中主要为相机图像信息的读取和预处理。如果是在机器人中，还可能有码盘、惯性传感器等信息的读取和同步。 1.2 视觉里程计（Visual Odometry，VO） 视觉里程计的任务是估算相邻图像间相机的运动，以及局部地图的样子。VO又称为前端（Front End）。VO与计算机视觉研究领域更为相关，比如图像的特征提取与匹配等。 缺陷：仅通过VO来估计轨迹，会出现累计漂移（Accumulating Drift） 解决方案： 回环检测：负责检测“机器人回到原始位置”信息 后端优化：根据回环检测的信息，校正整个轨迹形状 1.3 后端优化（Optimization） 后端接受不同时刻视觉里程计测量的相机位姿，以及回环检测的信息，对它们进行优化，得到全局一致的轨迹和地图。由于接在VO之后，又称为后端（Back End）。 主要是处理SLAM过程中的噪声问题，主要是利用滤波与非线性优化算法。 1.4 回环检测（Loop Closing） 回环检测判断机器人是否到达过先前的位置。如果检测到回环，它会把信息提供给后端进行处理。 主要解决位置估计随时间漂移的问题。 实质上是一种计算图像数据相似性的算法。 1.5 建图（Mapping） 它根据估计的轨迹，建立与任务要求对应的地图。地图大体可分为度量地图（Metric Map）和拓扑地图（Topological Map）两种。 度量地图：强调精确的表示地图中物体的位置关系。通常又分为稀疏（Sparse）与稠密（Dense）两种。 稀疏：进行一定程度抽象，不需要表达所有物体，选择一部分具有代表意义的东西，称为路标，一张稀疏地图就是由路标组成的地图。一般用于定位。 稠密：着重于建模所有看到的东西。一般用于导航。可以用于各种导航算法。如A*,D*等，缺点是耗费大量存储空间以及大规模度量地图的一致性问题。 拓扑地图：更强调地图元素之间的关系。是一个图（Graph），有节点和边组成，只考虑节点间的连通性。 1.6 SLAM问题的数学表述 假设: 离散时刻：\\(t=1,\\cdot\\cdot\\cdot,K\\) 各时刻位置：\\(x_1,\\cdot\\cdot\\cdot,x_K\\) 观测到的路标点：\\(y_1,\\cdot\\cdot\\cdot,y_N\\) 有： （从\\(k-1\\)时刻到\\(k\\)时刻，位置\\(x\\)如何变化）运动方程：\\(x_k=f(x_{k-1},u_k,w_k),\\space\\space k=1,\\cdot\\cdot\\cdot,K\\) \\(u_k\\)：已知。运动传感器的输入（或读数） \\(w_k\\)：运动过程加入的噪声 （在\\(k\\)时刻观察到了某一个路标点\\(y_j\\)）观测方程：\\(z_{k,j}=h(y_j,x_k,v_{k,j}),\\space\\space (k,j)\\in O\\) \\(z_{k,j}\\)：已知。观测数据 \\(v_{k,j}\\)：观测过程加入的噪声 \\(O\\)：集合，记录哪个时刻观察到了哪个路标 估计： \\(x\\)和\\(y\\) 2、三维空间刚体运动 如何描述刚体在三维空间中的运动？ 我们日常生活的空间是三维的，三维空间由3个轴组成，所以一个空间点（质点）的位置可以由3个坐标指定。不过目前要研究的机器人、相机等物件可以看作刚体1。与质点相比，对于刚体位置的描述，不仅要指出其在空间中的位置坐标（3个坐标），还要指出其自身的姿态（即刚体的朝向）2。 向量是一种具有大小和方向的矢量（此处向量均默认为列向量）。当指定了空间中具有一组基的坐标系后，向量在这个坐标系下的坐标和其自身所代表的方向就可以描述刚体的位姿。 实际场景中会定义各种各样的坐标系，向量在不同坐标系下的坐标不同，所以需要一种数学手段描述向量在不同的坐标系下坐标的变换关系。两个坐标系之间的坐标相差了一个欧式变换 （Euclidean Transform）。 欧式变换由一个旋转加一个平移组成。 2.1 旋转矩阵与平移向量 2.1.1 旋转 假设向量\\(\\vec a\\)在坐标系1和坐标系2下的坐标分别为\\(a_1\\)和\\(a_2\\)，两坐标系的基分别为\\(\\vec e_1\\)和\\(\\vec e_2\\) 有： \\[ \\vec a ={\\vec e_1}^{T} \\cdot a_1 \\\\ \\vec a ={\\vec e_2}^{T}\\cdot a_2 \\] 即： \\[ {\\vec e_1}^{T} \\cdot a_1 ={\\vec e_2}^{T}\\cdot a_2 \\] 同时左乘\\(\\vec e_1\\)，有： \\[ \\vec e_1 \\cdot {\\vec e_1}^{T} \\cdot a_1 =\\vec e_1 \\cdot {\\vec e_2}^{T}\\cdot a_2\\\\ \\vec I \\cdot a_1 =\\vec e_1 \\cdot {\\vec e_2}^{T}\\cdot a_2\\\\ a_1 =\\vec e_1 \\cdot {\\vec e_2}^{T}\\cdot a_2 \\] 那么，两个坐标系的两组基之间的内积（即\\(\\vec e_1 \\cdot {\\vec e_2}^{T}\\)）组成旋转矩阵\\(\\ R\\)（Rotation Matrix.），刻画了旋转前后同一个向量的坐标变换关系： \\[ a_1=R\\cdot a_2=R_{12}\\cdot a_2 \\] 其中，\\(R_{12}\\)的表示含义为 把坐标系2的向量变换到坐标系1中 又因为旋转矩阵是一个行列式为1的正交矩阵。所以n 维度旋转矩阵的集合可定义为特殊正交群（Special Orthogonal Group）： \\[ SO(n)=\\left \\{ R\\in \\mathbb{R}^{n\\times n} \\mid RR^{T} =I,det(R)=1\\right \\} \\] 由于旋转矩阵为正交矩阵，所以它的逆\\({R}^{-1}\\)（即转置\\({R}^{T}\\)）描述了一个相反的旋转。 \\[ a_2={R}^{-1}\\cdot a_1={R}^{T}\\cdot a_1 \\] 2.1.2 平移 \\(\\ t\\)称为平移向量。相比旋转，平移部分只需要把平移向量加到旋转之后的坐标上： \\[ a_1=R_{12} \\cdot a_2+t_{12} \\] 其中，\\(t_{12}\\)的表示含义为 坐标系1原点指向坐标系2原点的向量，在坐标系1下取的坐标 反过来的\\(t_{21}\\)，即从坐标系2原点指向坐标系1原点的向量，在坐标系2下取的坐标，并不等于\\(-t_{12}\\) 证明过程：《视觉SLAM十四讲》互为反向的平移向量坐标值的关系 2.1.3 总结 通过上述，用一个旋转矩阵\\(\\ R\\)和一个平移向量\\(\\ t\\)完整描述了一个欧式空间的坐标变换关系。 然而还存在一个小问题：这里的变换关系不是线性关系。 2.2 变换矩阵与齐次坐标 引入齐次坐标和变换矩阵来处理上述的小问题。将一个三维向量的末尾添加1，将其变成四维向量，进行降维打击。这被称为齐次坐标。矩阵T称为变换矩阵（Transform Matrix）。 \\[ \\begin{bmatrix}a&#39; \\\\1\\end{bmatrix}=\\begin{bmatrix}R &amp; t\\\\0^{T} &amp; 1\\end{bmatrix}\\begin{bmatrix}a \\\\1\\end{bmatrix}\\overset{def} {=} T\\begin{bmatrix}a \\\\1\\end{bmatrix} \\] 变换矩阵这种矩阵又称为特殊欧氏群（Special Euclidean Group）: \\[ SE(3)=\\left \\{ T=\\begin{bmatrix}R &amp; t\\\\0^{T} &amp; 1\\end{bmatrix}\\in \\mathbb{R}^{4\\times 4} \\mid R\\in SO(3),t \\in \\mathbb{R}^{3} \\right \\} \\] 与特殊正交群一样，变换矩阵的逆矩阵表示一个反向的变换。 2.2.1 总结 旋转由旋转矩阵SO（3）描述，平移直接由一个三维向量描述。将旋转和平移放在一个矩阵中，就形成了变换矩阵SE（3）.这个变换矩阵描述了一个6自由度的三维刚体运动，不过矩阵表示方式至少有两个缺点： SO（3）的旋转矩阵有9个量，但一次旋转只有3个自由度；SE（3）有16个量，表达了6自由度的欧式变换。表达方式是冗余的。 旋转矩阵自身带有约束：必须是正交矩阵且行列式为1。变换矩阵同理。这些约束使得求解变得困难。 因此，需要一种方式来紧凑的描述旋转和平移。 2.3 旋转向量与欧拉角 2.3.1 旋转向量 任意旋转都可以用一个旋转轴和一个旋转角来刻画。 于是，使用一个向量，其方向与旋转轴一致，长度等于旋转角，这种向量称为旋转向量，也称为角轴（Angle-Axis）。此时，只需要一个三维向量即可描述旋转；同样，使用一个旋转向量和一个平移向量即可描述一次变换，这时正好是六维向量。 表示一个旋转，可以用旋转矩阵\\(\\ R\\)。假设旋转轴为单位向量\\(\\vec n\\)，旋转角度为\\(\\theta\\)，那么向量\\(\\theta \\vec n\\)也可描述该旋转。 旋转矩阵和旋转向量如何转换？ 旋转向量\\(\\longrightarrow\\)旋转矩阵3： \\[ R=\\cos\\theta \\mathit{I} + \\left ( 1-\\cos \\theta \\right ) \\vec n \\vec n^{T} + \\sin \\theta \\vec n^{\\wedge } \\] 旋转矩阵\\(\\longrightarrow\\)旋转向量4： \\[ \\theta =\\arccos \\frac{tr\\left ( R \\right )-1 }{2} \\] 转轴n是旋转矩阵R特征值1对应的归一化特征向量 注：旋转轴上的向量在旋转后不会发生改变，所以\\(R\\vec n=1\\vec n\\)，即有上述。 \\(^\\wedge\\)符号：将一个向量变为对应的反对称矩阵。然后则有外积：\\(a\\times b=a^\\wedge b\\) \\(^\\vee\\)符号：将一个反对称矩阵变为对应的向量。若\\(A\\)为反对称矩阵，则\\(a^\\wedge=A\\)，\\(A^\\vee=a\\) 2.3.2 欧拉角 旋转矩阵和旋转向量对于人类不直观，欧拉角提供了一种直观的方式来描述旋转——使用三个分离的转角，，把一个旋转分解成3次绕不同轴的旋转。不过欧拉角的定义方式很多，带来了很多困难。这里介绍rpy角，它的绕轴旋转顺序是Z（偏航角yaw）Y（俯仰角pitch）X（滚转角roll）。 欧拉角的一个重大缺点是著名的万向锁问题（Gimbal Lock）：在俯仰角（即绕Y轴的角）为±90°时，第一次旋转与第三次旋转将使用同一个轴，使得系统丢失了一个自由度。这被称为奇异性问题（旋转向量同样有此问题）。 万向锁问题：这种现象的发生就是由于上述固定坐标轴旋转顺序造成的。理论上，欧拉旋转可以靠这种顺序让一个物体指到任何一个想要的方向，但如果在旋转中不幸让某些坐标轴重合了就会发生万向节锁，这时就会丢失一个方向上的旋转能力，也就是说在这种状态下我们无论怎么旋转（当然还是要原先的顺序）都不可能得到某些想要的旋转效果，除非我们打破原先的旋转顺序或者同时旋转3个坐标轴。由于万向节锁的存在，欧拉旋转无法实现球面平滑插值。 用途：验证算法是否有错，转换成欧拉角能快速分辨结果是否正确。某些主体主要为2D场合，也可以把旋转分解为三个欧拉角，然后把其中一个拿出来做定位输出。 万向锁问题参考资料1 万向锁问题参考资料2 2.4 四元数 旋转矩阵用9个量描述3自由度的旋转，具有冗余性；旋转向量和欧拉角是紧凑的，但具有奇异性。 事实上，我们找不到不带奇异性的三维向量描述方式。 四元数（Quaternion）可以描述三维空间的旋转，它既是紧凑的，也没有奇异性。 阅读材料1：quaternion.pdf 阅读材料2：Understanding_Quaternions Chinese 阅读材料3：形象理解四元数 视频：四元数的可视化 3、李群与李代数 什么样的相机位姿最符合当前观测数据？这就需要构建一个优化问题，求解最优\\(R,t\\)，使得误差最小化。 旋转矩阵自身带有约束（正交且行列式值为1）。将之作为优化变量会引入额外约束，使优化变困难。 所以我们希望通过李群—李代数的转换关系，将位姿估计变成无约束的优化问题。 3.1.1 李群与李代数 群（Group）是一种集合加上一种运算的代数结构。 现在把集合记作\\(\\ A\\)，一种运算记作\\(\\cdot\\)，群记作\\(\\ G=(A, \\cdot)\\)，群要求运算满足以下四个条件： 封闭性：集合中的两个元素运算后还属于该集合； 结合律：元素运算的先后顺序不影响结果； 幺元：存在一个单位元，使得每个元素与之运算的结果都是元素本身； 逆元：对于集合内所有的元素，都有其对应的逆元素，使得元素与对应逆元素运算结果为单位元； 李群是指具有连续（光滑）性质的群。 李群的例子：\\(SO(3)\\)和\\(SE(3)\\) 李代数：由一个集合\\(\\mathbb V\\)、一个数域\\(\\mathbb F\\)和一个二元运算\\(\\ [,]\\)组成，称\\((\\mathbb V,\\mathbb F,[,])\\)为李代数，记作\\(\\mathfrak g\\) 需满足以下性质： 封闭性：同一集合的两元素运算过后还属于该集合 双线性 自反性：自己与自己运算结果为零 雅可比等价 其中：二元运算被称为李括号。 每个李群都有与之对应的李代数。李代数描述了李群的局部性质（单位元附近的正切空间）。 李代数的例子： \\(SO(3)\\)对应的李代数\\(\\mathfrak {so}(3)\\)为三维向量\\(\\phi\\)。每个\\(\\phi\\)都可以生成一个反对称矩阵\\(\\Phi = \\phi ^\\wedge \\in \\mathbb R^{3\\times 3}\\)。 有：\\(\\mathfrak {so}(3) =\\{\\phi \\in \\mathbb R^3,\\Phi=\\phi^\\wedge \\in \\mathbb R^{3\\times 3} \\}\\)。其可以用来表达旋转矩阵的导数。 \\(SO(3)\\)与\\(\\mathfrak {so}(3)\\)关系为：\\(R=exp(\\phi^\\wedge)\\) 此定义下，两个向量的李括号为：\\([\\phi_1,\\phi_2]=(\\Phi_1\\Phi_2-\\Phi_2\\Phi_1)^\\vee\\) \\(SE(3)\\)对应的李代数\\(\\mathfrak {se}(3)\\)为六维向量\\(\\xi\\)。 \\[ \\mathfrak{s e}(3)=\\left\\{\\boldsymbol{\\xi}=\\left[\\begin{array}{c} \\rho \\\\ \\phi \\end{array}\\right] \\in \\mathbb{R}^{6}, \\rho \\in \\mathbb{R}^{3}, \\phi \\in \\mathfrak{s o}(3), \\boldsymbol{\\xi}^{\\wedge}=\\left[\\begin{array}{cc} \\phi^{\\wedge} &amp; \\rho \\\\ 0^{T} &amp; 0 \\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4}\\right\\} \\] 其中，前三位为平移（与变换矩阵平移不同），记为\\(\\rho\\)；后三维为旋转，记为\\(\\phi\\)，实质为\\(\\mathfrak {so}(3)\\)。 注意：在\\(\\mathfrak {se}(3)\\)中，使用\\(^\\wedge\\)符号表示将一个六维向量转换成四维矩阵： \\[ \\boldsymbol{\\xi}^{\\wedge}=\\left[\\begin{array}{cc} \\boldsymbol{\\phi}^{\\wedge} &amp; \\boldsymbol{\\rho} \\\\ \\mathbf{0}^{T} &amp; 0 \\end{array}\\right] \\in \\mathbb{R}^{4 \\times 4} \\] 此定义下，两个向量的李括号为：\\(\\left[\\xi_{1}, \\xi_{2}\\right]=\\left(\\boldsymbol{\\xi}_{1}^{\\wedge} \\boldsymbol{\\xi}_{2}^{\\wedge}-\\boldsymbol{\\xi}_{2}^{\\wedge} \\boldsymbol{\\xi}_{1}^{\\wedge}\\right)^{\\vee}\\) 0、注释 \\[ a^{\\wedge } =\\begin{bmatrix}0 &amp; -a_{3} &amp;a_{2} \\\\a_{3} &amp; 0 &amp; -a_{1} \\\\-a_{2} &amp; a_{1} &amp;0 \\end{bmatrix} \\] 在物理学里，理想刚体（rigid body）是一种有限尺寸，可以忽略形变的固体。不论是否感受到外力，在刚体内部，质点与质点之间的距离都不会改变。这种理想模型适用条件是，运动过程比固体中的弹性波的传播要缓慢得多。根据相对论，这种物体不可能实际存在，但物体通常可以假定为完美刚体，前提是必须满足运动速度远小于光速的条件。↩︎ 刚体是由一群数量超多的质点组成。实际而言，不可能精确地追踪其中每一个质点的运动。为了简化运算，可以利用刚体的“刚性”，即其内部所有质点彼此之间距离不变的性质。假若物体具有刚性，则倚靠设定三个不共线质点的位置，就足以设定此物体的位置。这意味着，在三维空间里，刚体至多只有九个自由度，但由于假定三个质点之间的距离固定不变，所以，刚体只有六个自由度。假设还有其它约束，例如，刚体的运动必需绕着其内部一点旋转（定点转动），或绕着其内部一直轴旋转（定轴转动），则自由度会小于六。↩︎ 符号^是向量到反对称矩阵的转换符。↩︎ tr求迹是求矩阵的对角线之和。↩︎","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"},{"name":"slambook14","slug":"robot/note/slambook14","permalink":"https://silencht.github.io/categories/robot/note/slambook14/"}]},{"title":"互为反向的平移向量坐标值的关系","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/note/slambook14/互为反向的平移向量坐标值的关系/","text":"《视觉SLAM十四讲》互为反向的平移向量坐标值的关系 《视觉SLAM十四讲》第二版第三章3.1.2节 46页中写道“但是反过来的 \\(t_{21}\\) ，即从2指向1的向量在坐标系2下的坐标，却并不等于 \\(-t_{12}\\) ，而是和两个系的旋转还有关系。” 写一个简单的证明过程： 设世界坐标系为下标 \\(w\\) ，相机坐标系为下标 \\(c\\) ，有： \\(P_{w}=R_{wc}\\cdot P_{c}+t_{wc}\\) ————① $P_{c}=R_{cw}P_{w}+t_{cw} $ ————② 由①移项，有： \\(P_{c}=R_{wc}^{-1}\\cdot (P_{w}-t_{wc})=R_{cw}\\cdot (P_{w}-t_{wc})\\) ————③ 比较②和③有： \\(t_{cw}=-R_{cw}\\cdot t_{wc}\\) 证毕。 其中， \\(R_{wc}\\) 为旋转正交矩阵，它的逆矩阵（也等于转置矩阵）描述了与 \\(R_{cw}\\) 相同的旋转。所以， \\(P_{c}=R_{wc}^{-1}\\cdot P_{w}+t_{cw} =R_{wc}^{T}\\cdot P_{w}+t_{cw}=R_{cw}\\cdot P_{w}+t_{cw}\\) 附一个解释该问题的博文 SLAM中的位姿与轨迹评价指标:APE、RPE、ATE、RTE","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"},{"name":"slambook14","slug":"robot/note/slambook14","permalink":"https://silencht.github.io/categories/robot/note/slambook14/"}]},{"title":"四元数到旋转向量公式的补充","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/note/slambook14/四元数到旋转向量公式的补充/","text":"书中第60页（3.42-3.43）公式证明较为简略，补充一部分其他参考信息。 1. 旋转向量-----角轴 任意旋转都可以用一个旋转轴和一个旋转角来刻画。 于是，使用一个向量，其方向与旋转轴一致，长度等于旋转角，这种向量称为旋转向量，也称为角轴（Angle-Axis）。此时，只需要一个三维向量即可描述旋转；同样，使用一个旋转向量和一个平移向量即可描述一次变换，这时正好是六维向量。 表示一个旋转，可以用旋转矩阵 \\(R\\) 。假设旋转轴为单位向量 \\(\\vec n\\) ，旋转角度为 \\(\\theta\\) ，那么向量 \\(\\theta \\cdot \\vec n\\) 也可描述该旋转。旋转矩阵和旋转向量如何转换？ 旋转向量 \\(\\longrightarrow\\) 旋转矩阵： $R= + ( 1-) n n^{T} + n^{} $ 旋转矩阵 $$ 旋转向量： \\(\\theta =\\arccos \\frac{tr\\left ( R \\right )-1 }{2}\\) 转轴 \\(\\vec n\\) 是旋转矩阵 \\(R\\) 特征值1对应的归一化特征向量 2. 四元数到旋转向量 设四元数： \\(q=(s,\\vec v)=(s,v_1,v_2,v_3)\\) ,其中 \\(s \\in \\mathbb R,\\vec v=[v_1,v_2,v_3]^T \\in \\mathbb R\\) 设旋转向量：旋转轴为单位向量\\(\\vec n=(n_x,n_y,n_z)\\) ，旋转角度为 \\(\\theta\\) ，旋转向量为 \\(\\theta \\cdot \\vec n=\\theta \\cdot (n_x,n_y,n_z)\\) 因为 \\(\\vec n\\) 为单位向量，所以 \\(n_x^2+n_y^2+n_z^2=1\\) 【非严格证】 根据三角函数公式 \\(cos^2(\\frac\\theta 2) + sin^2(\\frac\\theta 2) = 1\\) 将上式 $sin^2() $ 乘系数1（即 \\(n_x^2+n_y^2+n_z^2=1\\) ），有 \\(cos^2(\\frac\\theta 2) + sin^2(\\frac\\theta 2) \\times1= 1 \\\\ cos^2(\\frac\\theta 2) + sin^2(\\frac\\theta 2) \\times(n_x^2+n_y^2+n_z^2)=1\\) 展开，有 \\(cos^2(\\frac\\theta 2) + sin^2(\\frac\\theta 2) \\times n_x^2+sin^2(\\frac\\theta 2) \\times n_y^2+sin^2(\\frac\\theta 2) \\times n_z^2=1\\) 这与单位四元数的形式类似： \\(|q|=s^2+v_1^2+v_2^2+v_3^2=1\\) 对上述前两个式子的相似项同时开根号，对比有： \\(s=cos(\\frac\\theta2)\\\\ v_1=sin(\\frac\\theta2)\\cdot n_x\\\\ v_2=sin(\\frac\\theta2)\\cdot n_y\\\\ v_3=sin(\\frac\\theta2)\\cdot n_z\\) 【证毕】 参考资料","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"},{"name":"slambook14","slug":"robot/note/slambook14","permalink":"https://silencht.github.io/categories/robot/note/slambook14/"}]},{"title":"两点的叉乘为过两点直线的系数","date":"2023-11-29T02:08:16.537Z","path":"wiki/robot/note/视觉惯性SLAM理论与源码解析/齐次形式下两点的叉乘为过该两点的直线的系数/","text":"《视觉惯性SLAM理论与源码解析》P31证明，整理自《两点的叉乘为过两点直线的系数[1]》，另外参考[2] 已知：二维平面下的两点 \\(A(x_1,y_1)\\) ， \\(B(x_2,y_2)\\) ，证明 \\(A,B\\) 两点的齐次形式的叉乘为过该两点的直线的系数。 预备：叉乘的定义为，已知向量 \\(a = (a_1,a_2,a_3), b=(b_1,b_2,b_3)\\) , 那么\\(a\\times b=(a_2b_3-a_3b_2, a_3b_1-a_1b_3, a_1b_2-a_2b_1)\\) 证明： 因为 \\(A,B\\) 两点的齐次式为 \\((x_1,y_1,1)\\) 和 \\((x_2,y_2,1)\\) ，代入叉乘的定义得 \\((y_1-y_2, x_2-x_1, x_1y_2-y_1x_2)\\) ； 定义直线的斜截式为 \\(y=kx + b\\) ,将 \\(A,B\\) 两点代入有： \\(y_1 = kx_1 + b\\) \\(y_2 = kx_2 + b\\) 将上面两式化简得， \\(k = \\frac{y_2-y_1}{x_2-x_1} ------(1)\\) \\(b = y_1 - \\frac{y_2-y_1}{x_2-x_1}* x_1------(2)\\) 接下来，将直线斜截式 $y = kx + b $ 转化为一般式 $ ax + by + c = 0$ ，即 \\(-kx+y-b=0\\) ， 那么有 \\((a,b,c)=(-k,1,-b)\\)， 代入式（1）和式（2）得， \\((a,b,c)=(\\frac{y_1-y_2}{x _2-x_1},1,\\frac{y_2-y_1}{x_2-x_1}*x_1-y_1)\\) 两边同乘 \\((x_2-x_1)\\) 后得, \\((a,b,c)=(y_1-y_2,x_2-x_1,(y_2-y_1)*x_1-(x_2-x_1)*y_1)\\) ，即 \\((a,b,c)=(y_1-y_2, x_2-x_1, x_1y_2-y_1x_2)\\) ，可见其与 \\(A,B\\) 两点叉乘结果一致。 结论： 齐次形式下的两点的叉乘为过该两点的直线的系数； 两点的齐次坐标的叉乘结果可以表示过该两点的直线。 补充： 实际上，齐次形式下的两点的叉乘结果还是该直线与原点所形成平面的法向量。 即，直线与原点组成的平面的法向量和直线方程的系数实际是相同的，都是直线上任意不同两点的叉乘结果（可能相差一个非零实数系数k）。 参考 [^](#ref_1_0)两点的叉乘为过两点直线的系数 https://blog.csdn.net/u011089570/article/details/79040948 [^](#ref_2_0)齐次坐标，向量叉乘，无穷远点 https://www.cnblogs.com/vivian187/p/15238794.html","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"},{"name":"视觉惯性SLAM理论与源码解析","slug":"robot/note/视觉惯性SLAM理论与源码解析","permalink":"https://silencht.github.io/categories/robot/note/%E8%A7%86%E8%A7%89%E6%83%AF%E6%80%A7SLAM%E7%90%86%E8%AE%BA%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"c-basic","date":"2023-11-29T02:08:16.533Z","path":"wiki/cs/c&c++/c-basic/","text":"备注： C语言读书摘录笔记，笔记内容绝大部分摘录整理自李春葆、李筏驰老师编著的《直击招聘——程序员面试笔试C语言深度解析》一书，少部分来自于网络博客及网上资源（尽量保留了资源原始链接）. 第一章 程序设计基础——变量 1.1 变量定义和声明 1.1.1定义变量就是使用内存 1.如果一个变量占用内存空间的多个内存字节，其第一个字节地址就是它的存储地址 2.简单理解为变量就是内存的一个箱子，箱子的名称就是变量名，用户可以向其中放入数据，也可以取出其中的数据。 1.1.2变量的作用域和在内存中的存储方式 1.变量的作用域：确定变量的作用范围 局部变量：在函数内部定义的变量为内部变量，只在本函数范围内有效，在该函数外不能使用这些变量。 全局变量：在函数之外定义的变量为外部变量，作用域从定义变量的位置开始到本源程序文件结束，全局变量保存在静态存储区。 C程序中局部变量和全局变量重名时，局部变量会屏蔽全局变量 2.变量的存储类别：确定变量存放在内存的位置 auto：自动变量，缺省情况下，编译器默认所有局部变量为自动变量，它的存储空间由系统自动分配和释放，系统不会自动初始化。【影响】若定义局部变量时不初始化值，那么此时该局部变量为无意义的辣鸡值，因为自动变量不会初始化。 register：寄存器变量，变量值存放在CPU内部寄存器中，存取速度最快，这类变量不能进行取变量地址操作。只有局部自动变量和函数形参才可以定义为寄存器变量。 extern：外部变量，全局变量是从作用域角度提出，而外部变量是从存储类别提出。该关键字告诉编译器存在着一个变量或函数，即使在当前源程序文件中没有看到它，也不是错误的，它可能在另外一个源程序文件中或者在当前文件的后面定义。extern的作用有两个： 在函数中提前使用全局变量（提前声明），即在定义之前使用 使用其他源文件中的全局变量 static：静态变量，在函数内部用该关键字定义的变量称为静态局部变量，在函数外部用static关键字定义的变量称为静态全局变量。 静态局部变量，程序执行期间，在内存的静态存储区中占据这永久性的存储单元，即便退出函数后，该变量的生命期也不终止，下次再次进入函数时，仍使用原来的存储单元。定义时初始化的静态局部变量，初始化仅仅执行一次；对于初始化的静态局部变量，C编译系统自动给它幅值0. 静态全局变量，作用域只限于本源程序文件。静态全局变量和普通全局变量的区别是静态全局变量只能初始化一次，由于静态全局变量的作用域限于本源程序文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引用而引起错误。 3.内存组织结构 代码段：该内存区域属于只读，区域大小在程序执行前就已经确定 数据段：执行程序时，BSS段会预先清空，所以存放在BSS段的变量均默认初始化为0 堆空间：存放进程（可简单理解为程序的一次执行）执行中被动态分配的内存段，大小不固定，可动态扩张或缩减。从堆分配的内存仅能通过指针访问。速度一般较慢，容易产生内存碎片。 栈空间：方便用来保存/恢复调用现场，可以看作一个存放、交换临时数据的内存区。由系统自动分配，速度较快，程序员无法控制栈空间。 4.变量静态分配和动态分配方式 变量静态分配：程序编译期间分配固定的存储空间的方式。该存储分配方式在变量定义时就分配存储单元并一直保持不变，直到整个程序结束。所有变量都是采用静态分配方式。静、动态分配方式主要是针对指针变量（或者数组）指向的空间而言的。 变量动态分配：程序执行期间根据需要动态申请堆空间的方式。C语言提供了一套机制可以在程序执行时动态分配存储空间。如malloc(),calloc()等函数。 如果程序员在程序中采用动态分配方式分配大量内存空间，用完后不及时释放，可能会消耗完应用程序的内存空间，称之为内存泄漏。 1.2 运算符和表达式 1.2.1 C中的运算符 1.++n、n++、--n、n--的区别 虽然对于int数据类型的变量进行++、--运算完全可以用n=n±1完成，但是用++、--运算符可以提高程序的执行效率，因为++、--只需要一条机器指令就可以完成，而n=n±1需要对应三条机器指令 自增、自减运算符的运算对象只能是简单变量，不能是常数或是带有运算符的表达式 编译器实现n++、n--是先创建n的一个副本，然后n自增、自减1，最后返回这个副本的值，所以n++、n--不能作为左值（因为作为左值时改变的是副本的值）；而实现++n、--n是先n自增、自减1，最后返回n的值（不是副本的值），所以++n、--n可以作为左值。故for循环递增量表达式建议采用++i，而非i++，因为++i占用空间小。 2.表达式中符号的求值 符号指的是程序的一个基本组成单元，其作用相当于一个句子中的单词。在C编译器解释表达式符号时，它在移动到下一个符号之前在单个符号中包括尽可能多的字符，即为贪心法。 i+++j解释为（i++）+j a+++++b本应解释为（a++）++ +b，而a++不能作为左值，所以应解释为（a++）+（++b） y=x/*p按照贪心法，会把p当作注释语句，导致编译错误，所以应该书写为y=x/（*p） 3.表达式中求值中的类型转换 自动转换的原则 若参与运算类型不同，则先转换为同一类型 转换按数据长度增加的方向进行，以保证精度不降低 所有的浮点运算都是以双精度进行的，即使仅含float单精度运算表达式，也要先转换为double型 char和short型参与运算时必须先转换为int型 幅值运算中，幅值号右边量的类型先转换为左边量的类型。如果右边的数据类型长度比左边长，将丢失一部分数据，降低精度，丢失的部分按照四舍五入向前舍入。 隐式转换见书25页-27页 4.表达式求值的副作用 一个表达式在求值的过程中对使用的变量不但引用，还对它们的值加以修改，这样的表达式称为有副作用的表达式，例如：x=x++，有两个副作用，因为x值发生了两次修改. a[i]=i++; 问题是：数组下标i是引用旧值还是引用新值？对这种情况编译器的解释可能不同，并因此产生不同的结果。C语言标准对大多数这类问题有意未做具体规定。表达式何时会产生这种副作用（对变量赋值），将由编译器决定，因为最佳的求值顺序同机器结构有很大关系。（ANSI C标准明确规定了所有对参数的副作用都必须在函数调用之前生效，但这对前面介绍的printf函数调用并没有什么帮助）。 在任何一种编程语言中，如果代码的执行结果与求值顺序相关，则都是不好的程序设计风格。很自然，有必要了解哪些问题需要避免。但是，如果不知道这些问题在各种机器上是如何解决的，就最好不要常识运用某种特殊的实现方式。 K&amp;R.The C Programming Language.43页 第二章 数据处理——控制结构 2.1 选择控制结构 2.1.1 If 语句 计算if后面的表达式，结果为0或者空字符时表示假，为非0或者非空字符时表示真。当实数变量与0值进行比较时，由于实数有精度限制，不能写成if(f==0.0)的形式，而应该写为if(f＞=EPSINON &amp;&amp; f＜=EPSINON)，其中EPSINON是允许的误差（精度），如取值为0.000001. 在if的表达式中不能将“==”写为“=”，后者为幅值表达式，总是为真。好的习惯应是写为if(2==n)，这样可以避免类似的错误出现。 2.1.2 Switch语句 switch后面圆括号内的“表达式”的值只能是整数或字符值，不允许是实数和布尔值，例如switch(n==1)是错误的 case后面的值必须是整形或字符型值，不允许是实数，也不允许含有运算符，例如case 1.2：和case 1+2：都是错误的 同一switch语句的所有case的值必须互不相同，多个case可以共用一组执行语句 2.2 循环控制结构 2.2.1 for语句 for(表达式1；表达式2；表达式3) 语句； 表达式1可以省略，此时应该在for语句之前给循环变量赋初值，其后的分号不能省略 表达式2可以省略，即不继续判断条件，循环无终止的进行下去，需要在循环体中用break等语句退出循环，其后的分号不能省略 表达式3可以省略，这样需要在循环体中让循环变量变化，以保证循环能正常的结束 2.2.2 break和continue语句 break只能用于循环语句和switch语句中，它跳出所在的那一层循环语句或者switch语句 continue只能用于循环语句中，它跳出所在的那一轮循环，继续下一轮循环 第三章 内存操作——指针 3.1 指针基础 3.1.1 指针变量与运算 指针变量中存放的是地址值，无论指针变量的基类型是何种数据类型，占用的内存大小都是相同的。 3.1.2 野指针 一个指针变量的值（地址值）为垃圾值的指针变量称为野指针。产生野指针的原因和解决方法： 指针变量定义时没有被初始化。解决办法是定义指针时初始化，可以是具体的地址值，也可以是NULL 指针p被free或者delete之后没有被置为NULL，后面还使用它。解决办法是指针指向的内存空间被释放后指针应该指向NULL 指针操作超越了所指变量的作用域。解决办法是在所指变量的作用域结束前释放掉变量的地址空间，并让指针指向NULL 3.2 常量和常量指针 3.2.1 常量 程序执行期间其值不能被改变的量称为常量，常量分为字面常量和符号常量 字面常量 字面常量只能引用不能修改，如123等，通常保存在程序符号表中，程序无法读取字面常量的地址，只有一个例外，即字符串常量。例如：char *p=\"abc\";，字符串常量放在静态数据区，由p指针指向它，不能通过p指针来修改该常量。 程序员最好采用const char *p=\"abc\";定义，这样在执行*p='x'时会发生编译错误，以便避免bug。 int *p=123；也是不允许的，尽管123是常量，但这里编译器认为是将123作为地址存放在指针变量p中，而123是整数，正确的做法是int *p=（int *）123；即将123转换为地址值赋给p，但这种做法是有危险的。 又由于p指向的常量字符串不是通过malloc函数分配的，所以执行free（p）会导致程序崩溃。 符号常量 符号常量主要又两种定义方法： 第一种是用宏定义实现（即宏常量），例如#define PI 3.14 第二种是用const定义（即const常量），const的意思是“一个不能被改变的变量”，例如const int n=123； const修饰的常量的值不能修改，所以必须在定义时初始化 两种定义方法的区别： 前者是宏替换命令，不是语句，所以不以“；”结尾，后者是定义，以“；”结尾。 前者在预处理时进行替换，后者定义的常量像变量一样（称为常变量），只是其值不能改变 const常量有数据类型，而宏常量没有数据类型。编译器对前者进行类型安全检查，对后者不进行类型安全检查。 3.2.2 const指针常量、常量指针 在定义指针时用const关键字进行修饰，称为const指针常量，有三种情况： 1.常量指针 用const修饰*时称为常量指针，表示不能修改p指向的内容 [注意此时p指向的内容仅仅是不能通过指针p修改，其自身如果不是常量的话，可以通过其他方式修改]。例如： const char *p;，此时不能通过p指针修改指向的内容，否则会出现编译错误。 也可以写作char const *p;，但习惯上常用第一种 它的本质还是一个指针，是一个指向常量的指针（变量） 指针本身的指向可以改变，但是指向的内容不可修改 通常用于参数传递过程中，如果被传入的参数的值在函数执行期间不希望被修改可以使用const 修饰已达到安全的目的。 2.指针常量 char * const p；const修饰p，表示不能修改变量p。指针p是一个指针常量，p的值不能再发生改变，所以必须初始化。一旦初始化，p不能指向其他数据，但可以通过指针p修改所指的内容。 一般指针常量用于不会发生指向变化的指针，但是用法并不常见。 3.指向常量的常指针 相当于常量指针和指针常量的结合，格式 const char * const p = &amp;num,相当于有一个指向不可修改的指针指向了一个不可修改的常量，在实际coding中很少使用。 4.总结 const 修饰谁，谁就不变 3.3 多级指针 3.3.1 void *和void ** void：字面意思是无类型，真正发挥作用的地方在于对函数返回值的限定和对函数参数的限定； void *：无类型指针，可以指向任何类型的数据。 既然是无类型指针，那么就不能做解引用与指针算数运算. 任何类型的指针都可以直接幅值给它，无需进行强制类型转换，但这并不意味这void *也可以无须强制类型转换地赋给其他类型的指针。因为“无类型”可以包容“有类型”，但是“有类型”不能包容“无类型”，例如： 123456789101112131415161718void *p1;int *p2;double *p3;p3=p2;//错误，必须改为第5行，强制转换后才可编译通过p3=(double *)p2;//正确p1=p2;//正确，可以将任何有类型地址赋给无类型指针变量p2=p1;//错误，不能将任何无类型地址赋给有类型指针变量p2=(int *)p1;//正确，将无类型地址强制转换为有类型地址，这就是malloc等函数原型的返回值为void *的原因 void *的用处：因为对于函数的通用型接口，你不知道用户的数据类型是什么，但是你必须能够处理用户的各种类型数据，因而会使用void*。void*能包容地接受各种类型的指针。也就是说，如果你期望接口能够接受任何类型的参数，你可以使用void*类型。但是在具体使用的时候，你必须转换为具体的指针类型。例如，你传入接口的是int*，那么你在使用的时候就应该按照int*使用。 void **：本质上是标识一个二级指针,即无类型指针的指针，它指向一个放 void*型的地方. (void**)&amp;data：把变量的地址强制转换为无类型指针的指针，即(void**)本质表示将&amp;data强制转换类型为一个指向无类型的二级指针。举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//为了使函数更加的通用，使用void**作为函数参数类型void swap(void **a, void **b)&#123; void *t; t =*a; *a =*b; *b=t;&#125;int main()&#123; int i = 3; int j = 5; int *p = &amp;i; int *q = &amp;j; char *s1=&quot;abc&quot;; char *s2=&quot;def&quot;; swap((void**)&amp;p, (void**)&amp;q); swap((void**)&amp;s1, (void**)&amp;s2);&#125;//注意char*是字符串指针，需要改变其对应的变量必须用地址，s1就是&quot;abc&quot;的起始地址，是不能被改变，要想改变s1必须用他的地址也就是&amp;s1，所以需要void**————————————————版权声明：本文为CSDN博主「unix21」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。[原文链接](https://blog.csdn.net/unix21/article/details/8923752) *(void**)&amp;data：data是指针变量，&amp;data取指针变量的地址， (void **)将这个data这个指针变量的地址类型强制转换为 指向无类型的二级指针类型，最后“翻译”最前面的*，作用是解引用，将 (void **)类型的&amp;data变量解引用一次，即指向了data本身，但此时data本身的数据类型实际上已经是无类型的一级指针了。 3.4 实例解析 3.4.1 （int&amp;)a 代码： 1234float a = 01f;printf(&quot;%d&quot;,(int&amp;)a); 解释：（存疑） ​ 等价于*(int*)(&amp;a)， 首先对float型变量取地址 强制类型转换为整型变量的地址（地址的值并没有变） 将该地址指向的变量输出（但是由于整型和浮点型数据存储方式的不同，输出结果是不同的） 第4章 数据组织——数组 4.1 一维数组 4.1.1 一维数组定义 由于const定义的常量具有变量的性质，因此这类常量不能作为定义数组的“长度表达式”。 4.1.2 一维数组初始化 对于局部数组，若没有进行初始化，其所有元素值为垃圾值；若初始化时仅对部分元素赋了初值，其余元素取默认值（数值型为0，字符型为空字符） 除了初始化外，数组名不能作为左值，因为它是一个表示首元素地址的常量 数组名具有地址概念，是代表数组 首元素的地址常量，因此可以将数组名赋给指针，例如int a[10]中a与&amp;a[0]含义相同，“a==&amp;a[0]”返回真 &amp;a表示整个数组的首地址，其与a的区别主要是步长的不同。a+i=a+i*sizeof(int)，其步长为sizeof(int)；而&amp;a+i=&amp;a+i*(a数组的大小)（这里为10*sizeof(int)）.因此尽管二者值相同，但表示不同的含义。因此&amp;a==a是错误的比较，因为它们的数据类型并不相同（一个是int *[10]，一个是int *） 归纳起来，int a[10],*p=a;情况下： p+i和a+i就是a[i]的地址，地址值都要进行a+i*d（d为步长）的运算 *(p+i)或*(a+i)就是p+i或a+i所指向的数组元素a[i]。数组元素中的“[]”是变址运算符，相当于*(+)，a[i]相当于*(a+i) 指向数组元素的指针变量也可以带下标，所以a[i]、*(a+i)、p[i]、*(p+i)全部等价 注意p和a的差别，p是指针变量，a是符号常量，a不能作为左值 *p++ 、*++p、 (*p)++、++(*p)区别 *p++ 解析：等同于*p; p += 1;由于*和++的运算优先级一样，且是右结合。故*p++相当于*(p++)，p先与++结合，然后p++整体再与*结合。前面陈述是一种最常见的错误。因为++后置的时候，本身含义就是先运算后增加1（运算指的是p++作为一个整体与前面的*进行运算；增加1指的是p+1），所以实际上\\*p++符号整体对外表现的值是\\*p的值，运算完成后p再加1. 【注意】是运算后p再加1，而不是p所指向的变量*p再加1 *++p 解析：等同于 p += 1; *p;由于++在p的前面，++前置的含义是，先加1，得到一个新的p（它的值是原来p的值加1）。然后这个新的p再与前面的*结合. 【总结】无论是*p++还是*++p，都是指针p += 1，即p的值+1，而不是p所指向的变量*p的值+1。++前置与++后置，只是决定了到底是先p+=1，还是先*p。++前置表示先p+= 1，再*p。++后置表示先*p，在p+= 1 (*p)++ 解析：使用()强制将*与p结合，只能先计算*p，然后复制创建*p副本，再对原始*p整体的值++，最后结果返回复制创建的*p副本值，因此其结果不能作为左值。 ++(*p) 解析：先*p取值，再前置++，该值+1后作为整个表达式的值。 4.1.3 一维数组和指针的差异 例如：char *p=\"abc\"; char s[]=\"abc\"; 对于字符串\"abc\"，编译器存储的是常量\"abc\\0\" 对于char *p=\"abc\"; 定义的是一个字符指针p，没有动态分配空间来存放字符串，所以编译器把\"abc\"当作常量存放在静态数据区，p作为指针指向这个常量的地址。因此，最好采用const char *p=\"abc\";的定义方式； 该定义中，因为字符串是常量，因此不能通过指针p来修改\"abc\". 如果希望p为指针变量，又要初始化\"abc\"，定义方式应为： char *p=(char*)malloc(4sizeof(char));strcpy(p;\"abc\"); sizeof(p)值为4，含义表示一个地址空间的大小 对于char s[]=\"abc\"; 定义的是一个字符数组，编译器把它解析为 char s[4]=&#123;'a','b','c','\\0'&#125;; 如果数组s是已初始化的全局数组或者静态局部数组，则存放在静态数据区，如果是在函数内部定义的局部数组则存放到栈空间 sizeof(s)值为4，含义表示数组s含有4个字符元素（含结尾符） 4.1.4 运算符sizeof sizeof的三种语法格式 sizeof (object) sizeof (type_name) sizeof object 基本数据类型的sizeof：大小一般与系统相关 指针变量的sizeof：等于计算机内部地址总线的宽度 数组名的sizeof：等于其元素类型做sizeof的结果乘以数组元素的个数，即返回整个数组在内存中占用的内存字节数 数组名在作为函数参数传递过程中，会退化成指针，因此在函数内部使用数组名的sizeof时，返回退化为指针变量的sizeof，而非返回原数组名的sizeof. sizeof的副作用 sizeof(i++)之后，i的值会怎样？答案是不变。记得大一初学C语言时想研究一下sizeof与函数有什么区别，得到的结果只是一些语法上的差别；学了汇编之后看看编译器生成的代码，才发现sizeof在编译时直接给定了一个常值，而非在运行时求值。进而又分析过sizeof(表达式)的结果，清楚了类型提升原理。但我之前没有注意过表达式中出现副作用的问题，于是在sizeof(i++)的问题上犹豫了。现在经过查阅资料和实验，结论是：sizeof在大多数情况下是编译时定值的，表达式中的任何副作用（包括有副作用的运算符、函数调用等）都不会发生。这里说“大多数情况”，排除了针对C99的新特性——不定长数组（variable length array）的特例。 原文出处点击此处 4.2 二维数组 4.2.1 二维数组的定义 数据类型 数组名[长度表达式1][长度表达式2]； 长度表达式1 指数组行大小，长度表达式2 指数组列大小，都必须为正整数 二维数组中的所有元素在内存中按行序优先存放，即先顺序存放第1行的元素，再存放第2行的元素，以此类推。 4.2.2 多维数组的各级地址 以二维数组为例， 设二维数组 a 有3行4列，定义：int a [3][4] = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;; 其中， a 是数组名，它的各元素是按行顺序存储的。a 数组有3 行，将它们看成3 个一维数 组元素，即a=&#123;a[O],a[1],a[2]&#125;，每个一维数组元素又含4 个元素。这种降维的思路可以扩 展到三维或三维以上的数组。 数组名 a 代表的是该二维数组首元素 a[0] 的首地址，即a 与＆a[0] 的含义相同， a==&amp;a[0]返回真，是正确的比较。因此，二维数组名是个二级地址（例如，**a 的结果为 a[0][0] ），三维数组名是个三级地址，以此类推。 二维数组 a 的一维数组元素a[i] (0≤i≤2)又是一级地址，例如， a[0]与&amp;a[0][0]的含 义相同(&amp;a[0][0]中的＆运算符将其提升为一级地址）， a[0]==&amp;a[0][0] 返回真，是正确的 比较。 &amp;a 是整个二维数组的首地址，为三级指针，所以a==&amp;a 的比较是错误的，会出现 '==': no conversion from 'int (＊)[3][4]' to 'int (*)[4]'的编译错误。 总结： 对于一维数组b, b[j]相当千＊(b+j) 对千二维数组元素a[i][j] ，将一维数组元素a[i]当成 b 代入＊(b+j)得到＊(a[i]+j)，再将 其中的a[i] 换成＊(a+i)又得到＊(＊(a+i)+j)，所以a[i][j]、 ＊(a[i]+j)、 ＊(＊(a+i)+j)三者相同都表示第 i 行第 j 列元素。 表达式 | 含义 | :-------------------------------------- | :----------------------------------------------------------- | a、&amp;a[0] | 分别为二维数组名和首元素a[0]的地址，两者含义相同，均为二级地址。 | a[0] 、＊(a+O)、＊a 、&amp;a[0][0] | 均为a[0][0]元素的地址，四者含义相同，均为一级地址 | a[0]+1 、*a+1 、&amp;a[0][1] | 均为a[0][1]元素的地址， 三者含义相同，均为一级地址 | a+1、&amp;a[1] | 均为a[1] 的地址，两者含义相同，均为二级地址 | a[1] 、*(a+1) 、&amp;a[1][0] | 均为a[1][0]元素的地址， 三者含义相同，均为一级地址 | a[1]+3 、*(a+1)+3、&amp;a[1][3] | 均为a[1][3]元素的地址， 三者含义相同，均为一级地址 | *(a[1]+3) 、*(*(a+1)+3) 、a[1][3] | 均为a[1][3]元素， 三者含义相同 | （注意：二级地址与二级指针并非一个概念） 4.3 字符数组和字符串数组 4.3.1 字符数组 定义及初始化 字符数组中的元素是字符，因此在对字符数组中的元素赋值时必须使用单引号 初始化表中的初值个数可以少于数组元素的个数，这时只为数组的前几个元素赋初值，其余的元素将自动被赋以空格符（空格符不同于空字符，空字符的ASCII 码为0, 空格符的ASCII码为32)。如果初始化表中的初值个数多于数组元素的个数，则被当成语法错误来处理 sizeof 运算符与strlen函数的差别： strlen 函数用于求一个字符串的实际长度，从开始字符到遇见第1个'\\0'，如果只定义没有给它赋初值，这个结果是不定的，它会从首地址一直找下去，直到遇到 '\\0' 停止 sizeof 运算符返回变量定义后所占内存的字节数，不是实际长度。例如，定义char a[5], strlen(a)的结果是不定的，因为数组a没有赋初值，而sizeof(a)的结果为5 sizeof 可以用类型作为参数，而strlen 只能用char ＊作为参数，且必须是以“\\0”结尾的 数组在作为strlen 的参数时退化为指针，而作为sizeof 的参数时不退化 strlen 的结果要在执行时才能计算出来，是用来计算字符串的长度，不是类型占内存的大小；而sizeof 不能返回动态分配的空间大小 4.3.2 字符串数组 字符串数组的赋值操作 初始化赋值，如：char name[3][8]=&#123; \"Mary\",\"Smith\",\"GoodBye\" &#125;; 使用scanf 或者gets 函数赋值，如： 1234scanf(&quot;%s&quot;,name[0]) ; ／／输入的字符串不能含空格gets(name[0]) ; ／／输入的字符串可以含空格 使用标准字符串函数strcpy等实现字符串的复制，如：strcpy(name[0], \"Smith\"); 使用一般赋值语句赋值，如：name [0][0]='M'; name [0][1] ='a';etc... 注：在这种情况下，编译器不会自动添加结尾符 '\\0', 需要程序添加 4.4 指针数组 当多个基类型相同的指针变量集合成数组时，就形成了指针数组。指针数组是指针的集合，它的每个元素都是一个指针变量。其定义形式为：数据类型 ＊指针数组名［长度表达式］； 实例解析：int *p[3]; 由千[]比*优先级高，因此p先与[3]结合，形成p[3] 的数组形式，它有3个元素。然后再与p前面的*结合，表示是指针类型的数组，该数组的每个元素都是整型数的指针，所以每个元素都具有指针的特性。 4.5 数组指针 因为数组名是常量，不能像变量那样操作，为此可以设计指向数组的指针变量，以便于数组的操作。 一维数组指针，例如int a[]=&#123;l,2,3&#125;,*p=a;，通过指针p 访问数组a 的元素，其中a 为一级地址，p 为一级指针。 二维数组指针，定义格式：基类型 （＊指针变量）［长度表达式］，“长度表达式”指出二维数组中列的大小. 例如：int a[2][3] , (*p)[3]=a; 解析（对比指针数组例子）： 在(*p)[3]中，由于括号和［］的优先级相同，其结合性是从左到右的，所以“*“首先与p 结合，表示p是一个指针变量，然后再与［］结合，表示指针变量p的基类型（即这个p指向的变量的类型）是一个包含有3 个int型元素的数组，也就是说p为一个二维数组的指针变量，该数组中每列有3个元素。 二维数组名不能直接幅给二维指针的原因 二维数组名 指向 一个包含有已知列数量个基础类型元素的数组 的二级地址常量，而二维指针 是指向 基础类型的指针 的二维指针变量；例如： 1234567int a[2][3]; int **pa; pa=a;//p=a会报错int a[2][3]; int (*pb)[3]; pb=a;//正确int a[2][3]; int **pc; pc=(int**)a;//正确 因为a指向包含3个int型元素的一维数组，a逻辑上等同于&amp;a[0]，此时a+1是a[1]的地址，所以步长为sizeof(a[0])=4×3=12 ； 而pa是指向int *类型的二维指针，步长未知，因此两者指向对象的类型并不相同。而第二行代码中，说明了pb是一个指针变量，且pb这个指针变量指向的是一个包含有3个int型元素的数组，其步长也为12 ；这也解释了为什么定义二维数组指针时必须要指定列的大小：因为要“指定”你的二级地址/二维指针的步长。 第三行代码强制转换后语法正确，但不能通过pc 来访问数组a 的元素，因为强制转换之后已经丢失步长信息。 一旦定义了二维数组指针变量，该数组指针变量就可以像数组名一样使用，且可以在数组元素中移动. 三维数组指针 定义：基类型 ( (＊指针变批)[第二维长度] ) [第三维长度]; 第5章 数据结构II——结构体与联合体 5.1 结构体 5.1.1 结构体类型的声明 结构体类型声明语句必须以分号结尾，可以放在函数内部， 也可以放在函数外部，其作用域和变量的作用域类似 不同于变量可以使用extern 声明，必须先声明结构体类型，再定义其变量，如在a.c文件中定义了struct Student结构体之后，在b.c文件中 extern struct Student的提取声明将被忽略，也就是不接受结构体类型的提取声明.因为此时b.c文件只知道结构体变量的性质，并不知道其定义。简单的办法就是把结构体定义放在公共头文件中，a.c和b.c都包含该头文件。 5.1.2 结构体变量的定义 1234struct Student st;//传统C语言方式Student st;//C++方式 注：从语法角度出发，结构体变虽可以和结构体成员同名，因为它们处于不同的＂层次“ 上，不会有二义性，但从软件工程角度出发建议不要这样做。 5.1.3 结构体变量的引用 引用结构体变量中的一个成员 1234结构体变量．成员名 // &quot;.&quot;为结构体变量成员访问运算符结构体指针变量-&gt;成员名// &quot;-&gt;&quot;为结构体指针变量成员访问运算符 结构体类型变量的整体引用 用户可以将一个结构体变量作为一个整体赋给另一个同结构体类型的结构体变量，其前提条件是两个结构体变量必须具有完全相同的结构体类型。 当结构体内成员有指针变量类型时，单纯的整体幅值会造成“浅复制”，即a结构体变量幅值给b结构体变量后，b的指针变量成员同样指向了a结构体的对应成员指向的位置。因此以后对b的该成员的操作可能会直接影响到a结构体变量。 5.1.4 结构体变量的初始化 ​ 在对结构体变量赋初值时， C 编译程序按每个成员在结构体中的顺序一一对应赋初值，不允许跳过前面的成员给后面的成员赋初值；但可以只给前面的若干个成员赋初值，对于后面未赋初值的成员，对于数值型和字符型数据，系统自动赋初值零。 5.1.5 结构体变量的内存分配 结构体的内存对齐 结构体变量的首地址是结构体中有效对齐值的整数倍 编译器在给结构体开辟空间时，首先找到结构体中有效对齐值。有效对齐值取得方法： 取结构体内所有成员数据类型中占字节空间最大的自身对齐值记为N1.【注：若有结构体类型成员，其对齐值为该结构体成员内的所有成员中自身对齐值最大的那个值。】 寻找是否有自定义有效对齐值，若有则记为N2.【注1：自定义有效对齐值是用宏命令#pragma pack(n) 自定义的，对齐值为n ，用宏命令#pragma pack() 取消自定义对齐。】【注2：自定义有效对齐值中n=1时，称为紧凑编译】 若N2不存在，则有效对齐值就是N1；若N2存在，则有效对齐值便是：min｛N1,N2｝。 然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。 结构体每个成员相对于结构体首地址的偏移量（offset）都是当前成员大小的整数倍，如有需要编译器会在成员之间加上填充字节 为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。 结构体的总大小为结构体中最宽基本数据成员的整数倍。如有需要，编译器将会在结构体末尾（存疑）添加填充字符 柔性数组成员 12345678910Struct Type&#123; int n; int a[];//或者 “int a[0];”&#125;s; 成员数组a 称为柔性数组，它的长度为0 , 所以sizeof(s) 的大小为4, 以后可以分配变长度空间。柔性数组只能作为最后一个成员。柔性数组扩展阅读 5.2 联合体 5.2.1 定义联合体的注意事项 分配内存时，联合体变量所占内存的实际长度等千各成员中占内存最长的成员的 长度。 只有最后一个存放的成员值有效，其他成员将失去原值。 5.2.2 初始化联合体的注意事项 联合体变量在定义的同时只能用第1个成员的类型的值进行初始化，对联合体变量初始化时尽管只能给第1个成员赋值，但必须用大括号括起来。 联合体变量和结构体变量的区别： 联合体变量在定义的同时只能用第1个成员的类型的值进行初始化 联合体变量中的所有成员共享一段公共存储区，所以联合体变量所占内存的字节数与其成员中占字节数最多的那个成员相等；而结构体变量中的每个成员分别占有独立的内存空间，所以结构体变量所占内存的字节数是其成员所占字节数的总和 由于联合体变量中的所有成员共享内存空间，因此变量中的所有成员的首地址相同，而且变量的地址也就是该变量成员的地址 字节序描述数据在内存中的排列格式。在存储和加载时， CPU 必须采用硬件支待的字节序格式。字节序分为两类，即大端( BigEndian ) 和小端(LittleEndian ) 采用大端格式时，高位字节存储在第一个位置，次高位字节存储在次邻位置。采用小端格式时，低位字节存储在第一个位置，次低位字节存储在次邻位置。 字节序扩展阅读1 字节序扩展阅读2 5.3 枚举类型 暂无 5.4 用户定义类型 5.4.1 有关typedef的说明 使用typedef 只能对已有的类型名重新命名，并不能产生新的数据类型，原有的类型也没有被取代，即用户定义类型只是原类型的一个别名 typedef 并不是做简单的字符串替换。typedef与#define 的区别: 语法格式不同：typedef定义是语句，句尾要加上分号；而#define不是语句，不能在句尾加分号 用法不同： typedef用来定义一种数据类型的别名，增强程序的可读性；而#define主要用来定义常量，以及书写复杂的使用频繁的宏 执行时间不同：typedef是编译过程的一部分，有类型检查的功能；#define 是宏定义，是预编译的部分，其发生在编译之前，只是简单粗暴地进行字符串的替换，不进行类型的检查 作用域不同：typedef有作用域限定；#define不受作用域约束，只要是在define命令后的引用都正确 对指针的操作不同： typedef 和#define 定义的指针有很大的区别，如此例： 1234567891011121314151617typedef char * String_t;//是语句，为char＊指定一个新类型别名String_t, 有类型检查，编译的时候处理；#define String_d char * //是宏命令，只做简单的替换，无类型检查，预编译的时候处理，所以typedef 比＃define安全//而且定义多个变量时有区别，如：String_t a,b; /*等同于*/ char *a,*b;String_d c,d; /*替换为*/ char *c,d; //c为char＊类型，而d为char类型。 typedef与#define区别的扩展阅读 用typedef 定义类型名可嵌套进行 用typedef 定义类型名有利于程序的移植，并增加程序的可读性. 第6章 模块化——函数 6.1 函数基础 6.1.1函数的定义与调用 函数的定义 默认的函数类型为int void型函数无返回值，不能包含带返回值的return语句；其他类型的函数至少包含一个return语句 函数的定义不能嵌套，即不能在一个函数体内又包含另一个函数的定义。这就保证了每一个函数是一个独立的、功能单一的程序单元 复合语句（用花括号{}括起来的语句）申明的变量的作用域只在复合语句中,出了复合语句就不起作用。复合语句中的变量名和复合语句外面的变量即使同名也不是同一变量。 函数的调用 实参(argument)： 全称为\"实际参数\"，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值 形参(parameter)： 全称为\"形式参数\" ，由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数。在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。没有形参时，圆括号也不可省；多个参数之间应用逗号分隔。参数包括参数名和参数类型 来源：牛客网 6.1.2 函数的返回值与return语句 return的语句功能：返回调用函数（终止该函数的执行），并将return语句中表达式的值带给调用函数 return语句中表达式的类型与函数的类型不一致时则以函数类型定义为准，系统自动进行类型转换 C语言中可以使用不带表达式的语句直接返回，C++必须使用带表达式的return语句返回 return 语句不能返回局部变量的地址，因为该地址中存放的局部变量在函数执行完毕后被释放，但可以返回静态局部变量的地址，因为静态局部变量的空间不是在栈帧中，而是在静态数据区，即使栈帧退栈了，它仍然存在 6.1.3 函数的声明 函数声明语句也称为函数原型 如果调用一个函数出现在该函数的定义之前，则在调用前必须对该函数进行声明 如果函数原型放在调用函数定义的内部，则该声明仅对该调用函数有效 fun()与fun(void)声明的区别：对于前者，编译器编译时不检查该函数调用的参数传递情况；对于后者，括号中有void，编译器编译时会严格检查该函数调用时的参数传递情况，如果带参数调用，则会编译错误或者警告 6.1.4 外部函数与内部函数 函数默认类型是外部函数，其作用域是整个源程序，即：除了可被本源文件中的其他函数调用外，还可被其他源文件中的函数调用（其他源文件调用时，需要对被调用的外部函数用extern语句进行声明） 内部函数，也称为静态函数，使用static关键字定义，其作用域局限于定义它的源文件内部，即：只能被本源文件中的函数调用，不能被统一程序的其他源文件中的函数调用，其有以下优点： 其他源文件中可以定义相同名字的函数，不会发生冲突 静态函数不能被其他源文件所用，达到“隐藏”目的 6.1.5 函数间的参数传递 参数传递有两种方式：传值，传地址 传值方式 一个函数调用另一个函数时直接将实参的值传递给对应的形参，这称为传值方式，对应的形参称为值参数。传值方式实现了把数据由调用函数传递给被调用函数。由于数据在传递方（实参方）和被传递方（形参方）占用不同的内存空间（函数的形参属于自动变量，函数执行完毕后自动释放），所以形参在被调用函数中无论如何变化都不会影响调用函数中相应实参的值，也就是说调用函数时实参和形参之间是单向的从实参到形参的值传递。 传地址方式 如果要通过一个函数fun改变某个实参y （对应形参为x, 数据类型为Type ）的值，需要在fun 形参表定义为Type *x, 在调用函数的语句中指定为＆y (取y 的地址）。这样此时形参变量指向的内存地址与实参的地址相同，所以通过解引用形参变量指针进行的操作等同于对实参进行操作。 6.1.5 函数调用的实现原理 大多数CPU上的程序使用栈空间来支持函数调用操作。单个函数调用操作所使用的函数调用栈被称为栈帧(stack frame) 结构。每次函数调用时都会相应地创建一帧，保存返问地址、函数形参和局部变量值等，并将该帧压入调用栈。若在该函数返回之前又发生新的调用，则同样要将与新函数对应的一帧进栈，成为栈顶。函数一旦执行完毕，对应的帧便出栈（此时局部变量的生命周期结束），控制权交还给该函数的上层调用函数，并按照该帧中保存的返回地址确定程序中继续执行的位置。 函数调用要点 栈空间中每个栈帧的大小是有限的，所以在—个函数中不要定义很大空间的数组，否则可能会导致栈溢出，程序崩溃。 每个栈帧对应着一个未运行完的函数。栈帧中保存了该函数的返回地址和局部变量，每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧维护着函数调用所需要的各种信息。函数的返回地址和参数，保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。函数栈帧的大小并不固定，一般与其对应函数的局部变量多少有关。函数运行过程中，其栈帧大小也是在不停变化的！ ———————————————— 版权声明：本文为CSDN博主「YYtengjian」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。 当—个函数多次调用时，每次调用都会创建一个栈帧，为同名的局部变量分配空间，但它们的地址是不同的，它们之间也没有关系。 6.1.7 函数调用时参数的求值顺序 如果所有实参表达式的求值没有二义性，那么从右往左求值和从左往右求值结果是相同的。人们一般认为是从右往左顺序求值的。但，如果出现二义性，输出结果便是不确定的。例如： 1234567891011121314#include &lt;stdio.h&gt;int main()&#123; int a=l; printf(&quot;%d,%d,%d\\n&quot;,a++,++a,a++); return 0;&#125; 此程序在VC++中输出“2,2,1”，但在Dev C++中输出“3,4,1”，这是因为printf函数的实参存在二义性，因为在函数的所有参数赋值之后且在函数的第一条语句执行之前有一个顺序点，而参数间的逗号处没有顺序点，任意两个顺序点之间的副作用的求值次序都是不确定的，这里有3 个副作用，所以输出结果不确定。 见笔记第1章1.2.1中第4点表达式求值的副作用 C语言参考手册：求值顺序 6.1.8 atexit()函数 ​ 即使main()函数终止以后仍然可以执行一些代码，这需要使用stdlib.h 头文件中的atexit()函数。一般来说，如果在main()中调用某个函数，程序的执行会跳转到该函数并执行它。在执行该函数后控制权又交还给main()函数。 ​ 当使用了atexit() 函数以后，进程的执行可以简单地理解为当main()函数终止后跳转到atexit()函数，然后再也不会返回到main()函数。atexit()函数的使用格式如下： 12atexit(函数名)； ​ 由于atexit()函数是按后进先出的方式注册这些函数的，因此最后注册的函数先调用。 6.2 数组作为函数参数 以二维数组为例： 123456int a[M][N]; int (*pa)[n] = a ;void func(int a[][N]); void func(int a[M][N]);//函数声明func(a); func(pa);//调用 6.3 指针数组作为函数参数 当指针数组作为实参时，对应的形参应当是一个指向指针的指针变量.例如以下三种形式： 123456void func(int *a[]);void func(int *a[N]);void func(int **a); 6.4 指针函数和函数指针 6.4.1 指针函数 例如：int *func(int a,float x); 解释： 定义指针型函数时前面的*号与“数据类型”相结合，表示此函数是指针型函数。上例，定义func()函数时首部中的int* 是一个整体，表示该函数返回的是整型变量的地址 在程序中不要使用数组名接收指针型函数的返回值，因为数组名为地址常量，不能向它赋值 6.4.2 函数指针 函数的存储首地址又称为函数的执行入口地址， C 规定函数的首地址就是函数名。当指针变量保存函数的入口地址时它就指向了该函数，所以称这种指针变量为指向函数的指针变量，简称为函数指针. 定义函数指针的一般格式：函数类型（＊函数指针名）（形参表）; 解释： 在定义函数指针变量时，“函数指针名“两边的圆括号不能省略，它表示函数指针名先与*结合，即为指针变量，然后再与后面的”(形参表)”相结合，表示该指针变量指向函数。如果少了前面的一组括号，则变为函数类型 ＊函数名（形参表）它表示返回值为地址值（指针）的函数 函数指针变量的类型是被指向的函数类型 给函数指针赋值格式：函数指针名＝函数名; 通过函数指针调用函数格式：(＊函数指针)(实参表); 函数指针的作用主要体现于在函数间传递函数，这种传递不是传递任何数据，而是传递函数的执行地址，或者说是传递函数的调用控制。当函数在两个函数间传递时，调用函数的实参应该是被传递函数的函数名，而被调用函数的形参应该是接收函数地址的函数指针。 函数指针的用处： 使用函数指针的目的是为了增加执行函数的通用性，特别是在可能调用的函数可变的情况下，可以动态设置内容，有灵活性。如：排序的qsort函数需要传入比较的函数指针，来确定排序是从大到小还是从小到大，如下： 12void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*));//其中参数compar——用来比较两个元素的函数，即函数指针（回调函数） 6.2.3 两个函数指针实例 1.实例一： 实例二： 12void ( *func(void (*p)(void *),void *x) ) (void *); ​ 解释： 6.5 递归函数 递归函数又称自调用函数，其特点是在函数内部调用自己。C 规定不允许函数递归定义，即不允许在一个函数体中定义另一个函数，但可以递归调用。在执行递归函数时将反复调用其自身，每调用一次就进入新的一层。 一般地， 一个递归函数定义由两个部分组成，即递归结束情况和递推关系情况。递推关系就是把一个不能或不好直接求解的“大问题“转化成一个或儿个“小问题”来解决，再把这些“小问题”进一步分解成更小的“小问题”来解决（即递推），如此分解，直到每个“小问题”都可以直接解决（此时分解到递归结束情况）。 第7章 位操作——位运算和位域 7.1 位运算符 在C 中只能对整型或字符型数据进行位运算，不能对其他类型的数据进行位运算。 7.1.1 按位求反~ 所有的位运算都是以补码形式进行的 位运算适合于任何类型的整数，包括各种带符号整数，对于带符号整数，符号位也参与按位求反 ~运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他位运算符都高 7.1.2 左移运算&lt;&lt; 在VC++环境下，当左移位数n大于等于整数的位数m时，实际左移位数为n%m ，例如a&lt;&lt;36 等同于a&lt;&lt;(36%32)（这里n=36 、m=32) ，如a=1时其结果为16 7.1.3 右移运算&gt;&gt; 在VC++环境下，对于带符号整数，右移时高位正数补0 、负数补1， 例如int a=-2, a&gt;&gt;2的结果为-1。有的编译器全部补0 7.1.4 按位与&amp; 与运算可以实现的功能如下： 清零 如果想将一个单元清零，也就是使其全部二进位为0, 只需与0进行按位与运算即可达到清零的目的 保留/取 一个数中的某些位 要想将哪一位（或哪些位）保留下来，就与一个数进行＆运算，此数在这些位取1。例如有一个整数a (16 位），想取a中两个字节中的高字节，只需将a 与八进制数177400 (1111 1111 0000 0000) 按位与即可。 7.1.5 按位异或^ 异或运算可以实现的功能如下： 使特定位翻转 要使哪几位翻转，就将与其进行按位异或运算的那几位置为1 即可。（注：任何数与0按位异或保留原值。） 编码解码 任何数与它自己做按位异或结果为0 。例如，设k为密码，a为原始数据， a＾k 为加密结果，再做akk结果即为a, 称为解码。 7.1.6 按位或| 任何位上的二进制数，只要和1进行按位或运算，该位即为1；和0进行按位或运算，该位保留原值不变。 7.1.7 不同长度的数据进行位运算 两个运算数位数不同时系统自动处理如下： 将两个运算数右端对齐 将位数较短的运算数往高位扩充，即无符号数和正整数左侧用0补全，负数左侧用1补全；然后对位数相等的这两个运算数按位进行位运算 7.2 位图 位图( bit-map ) 就是用一个位来标记某个元素对应的值。由于采用了位为单位来存储数据，因此可以大大节省存储空间。 7.2.1 在位图 a 中设置位序号为 i 的位为1 int的长度为4个字节，设SHIFT为5（2的5次方=32）, MASK 为0x1f（ 二进制数为11111) 。对于位序号为 i 的位，在位图a中设置对应位为1的过程如下： 求a所在的元素：位序号为 i 的位应该在a[i&gt;&gt;SHIFT]（即a[i/32]) 元素中 求32位基准向量：位序号为 i 的位在a[i&gt;&gt;SHIFT]元素中从右数第（ i &amp; MASK）位，这里i &amp; MASK表示取出 i 末尾的5个二进制位，相当于 i%32; 将0x00000001（或者1) 左移（i &amp; MASK）位，即1&lt;&lt;( i &amp; MASK)得到对应的32 位基准向量 将a[i&gt;&gt;SHIFT]元素与求得的32位基准向量进行按位或运算，就在位图 a 中将位序号为 i 的位设置为1 ，即a[i &gt;&gt; SHIFT] |= (1 &lt;&lt;(i &amp; MASK)） 函数代码 1234void clr(int i)&#123; a[i&gt;&gt;SHIFT]|=(1&lt;&lt;(i&amp;MASK));&#125; 7.2.2 初始化位序号为i的位的设置值为0 求出位序号为i的位在a[i&gt;&gt;SHIFT]元素中，对应的32位基准向量是1&lt;&lt;(i&amp;MASK)，通过a[i&gt;&gt;SHIFT]&amp; = ~(1&lt;&lt;(i&amp;MASK))便位序号为i的设置值设为0. 函数代码 1234void set(int i)&#123; a[i&gt;&gt;SHIFT]&amp; = ~(1&lt;&lt;(i&amp;MASK));&#125; 7.2.3 获取位图a中位序号为i的位的设置值 求出位序号为i的位在a[i&gt;&gt;SHIFT]元素中，对应的32位基准向量是1&lt;&lt;(i&amp;MASK)，通过a[i&gt;&gt;SHIFT]&amp;(1&lt;&lt;(i&amp;MASK))取出对应的设置值，如果为0（假），表示对应位为0；如果为非0值（真），表示对应位为1. 函数代码 1234int getbit(int i)&#123; return a[i&gt;&gt;SHIFT]&amp;(1&lt;&lt;(i&amp;MASK));&#125; 7.3 位段（位域） 7.3.1 位段定义的说明 位段名省略时称作匿名位段。匿名位段的存储空间通常闲置不用。 当匿名位段的宽度被指定为0时有特殊作用：它使下一个位段跳过当前字节剩余空间，直接从一个新的地址开始存放。 常规结构体成员和位段可以定义在一个结构体中 不能定义元素为位段结构的数组 7.3.2 位段的引用和赋值 位段的应用形式和结构体成员相同 超出位段位数范围的赋值不会报错，而是自动截取所赋值的低位，例如一个位段定义为struct &#123;……unsigned short a:1;……&#125;var;，若给位段a赋值3，即var.a=3;，3的二进制码是11，取低一位是1，所以var.a的值是1 由于每个位段都指定了长度，所以特别要注意位段中的位扩展。当一个位段转换为有符号类型时按位段的最高位进行为扩展，例如： 位段成员的类型必须为无符号或者带符号整形（含char） 位段可以参与算数表达式的运算，系统自动将其转换成整型数 位段可以利用整型格式描述符（%d,%u,%o,%x）进行输出 由于位段没有地址，所以不能对位段求地址，也不能通过scanf(）语句读入位段值、不能用指针指向位段，但可以对一个含位段的结构体变量中的非位段成员求地址 几个位段的分配空间不一定紧挨在一起，中间可能有空着不用的空间。例如几个位段均为char 类型， 一个长度小于8 的位段不能跨两个字节。 # 第8章 编译前的处理——预处理 8.1 宏定义 在C 源程序被编译之前，首先对源程序中的预处理命令进行处理，然后才对程序进行编译。编译预处理命令都是以“#“开头的，它不是C 语句，必须单独占一行，末尾不使用分号作为结束符。类似Word中的替换功能。常用的预处理命令包括宏定义、条件编译和文件包含等。 8.1.1 无参宏定义 格式：#define 标识符 字符串 定义要点： 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，属于一种简单的代换。该字符串可含任意字符，预处理时对它不作任何检查。如有错误，只能在编译已被宏替换的源程序的过程中发现问题。 当宏定义在一行中写不下， 需要在下一行继续时，只需在最后一个字符后紧接着加一个反斜线”＂ 。 扩展阅读：反斜线可能引发的bug 宏定义不是语句，在行末不必加分号，如加上分号则连分号一起被置换 宏名在源程序中若用引号括起来， 则预处理程序不对其作宏替换,例如printf函数的参数中，双引号内的宏名不会被替换 宏定义允许嵌套， 即在宏定义的字符串中可使用已经定义的宏名，并且在宏替换时由预处理程序层层代换 8.1.2 带参宏定义 格式：#define 标识符(形参表) 字符串 调用：宏名(实参表) 定义要点： 在带参宏的定义中宏名和形参表之间不能有空格出现，否则宏名后面的括号、形参表和字符串会被错误认为是无参宏 在宏定义中形参是标识符，而宏调用中的实参可以是表达式 在宏定义中字符串内的形参通常要用括号括起来，否则可能出错，这称为宏的副作用。例如，定义求正方形面积的宏如下： 1#define area(a) (a*a) 当调用area(2+3)时宏替换成(2+3*2+3) ，那么求出的面积是11, 而不是正确的25 。所以应该改为如下： 1#define area(a) ((a)*(a)) 宏定义可用来定义多个语句，在宏调用时把这些语句又代换到源程序内，例如： 1#define SET(a,b,c,d) a=1;b=2;c=3;d=4; 带参宏与函数的区别： 函数调用时先求出实参表达式的值，然后代入函数定义中的形参；而使用带参宏只是进行简单的字符串替换，不进行实参的计算 函数调用是在程序执行时处理的，分配临时的内存单元；而宏替换是在编译之前进行的，在宏替换时并不分配内存单元，也不进行值的传递处理，也没有“返回值＂的概念 对函数中的实参和形参都要定义类型，且两者的类型要求一致，如不一致应进行类型转换；而宏不存在类型问题，宏名无类型，它的参数也无类型，只是一个符号代表，宏替换时代入指定的字符即可 当使用宏次数较多时，宏替换后使源程序变长，而函数调用不使源程序变长，因此一般用宏来替换小的、可重复的代码段，对于代码行较多的应使用函数方式 宏替换不占执行时间，只占编译预处理时间，而函数调用占执行时间（分配内存、保留现场、值传递、返回等）。 8.2 条件编译 一般情况下，C 源程序中所有的行都参加编译过程。但有时出于对程序代码优化的考虑，希望对其中一部分内容只是在满足一定条件时才进行编译，形成目标代码。这种对程序的一部分内容指定编译的条件称为条件编译。 条件编译注意要点： 头文件中的ifndef/define/endif 有什么作用？例如： 12#ifndef _STDIO_H#define _STDIO_H “宏名“在理论上来说可以是自由命名的，但每个头文件的宏名都应该是唯一的，其命名规则一般是头文件名全大写，前、后加下划线， 并把文件名中的“.”也变成下划线，例如stdio. h 头文件的宏名是＿STDIO_H。上述条件编译命令表示若没有定义＿STDIO_H，就定义＿STDIO_H 。 其目的是为了防止同一头文件等被重复引用。牛客网题目参考连接 8.3 文件包含 所谓文件包含预处理，是指在一个文件中将另一个文件的全部内容包含进来的处理过程，即将另外的文件包含到本文件中。C 提供了＃include 编译预处理命令实现文件包含操作。 8.3.1 文件包含操作的两种格式 #include ＜包含文件名＞ #include “包含文件名” 两者区别： 第一种：＜包含文件名＞表示直接到指定的C/C++编译系统标准包含文件目录去寻找文件 第二种： “包含文件名” 表示先在当前目录寻找，如找不到再到标准包含文件目录寻找 因此： 一般来说，前者用来包含开发环境提供的库头文件，后者用来包含自己编写的头文件。 8.3.2 文件包含操作的过程 文件包含预处理的功能是在对源程序进行编译之前用包括文件的内容取代该文件包含预处理语句。例如， a.c 文件中有文件包含命令#include \"b.c\", 其预处理过程如下图： 注：被包含的文件并不限于C系统所提供的头文件（如stdio.h 、string.h 等），还可以是用户自己编写的命名文件（其中包括宏、结构体名、联合体名、全局变量的定义等）和其他的要求在本文件中引用的源程序文件。 8.3.3 文件包含的说明 一个#include 命令只能指定一个包含文件。如果要包含多个文件，则要使用多个#include 命令 如果文件file1.c 要使用文件file2.c 中的内容，而文件file2.c 要用到文件file3.c 中的内容，则可以在文件file1.c 中用两个#include 命令分别包含file2.c 和file3.c, 而且文件file3.c 应出现在文件file2.c 之前，即file1.c中有： 12#include &quot;file3.c&quot;#include &quot;file2.c&quot; 这样file1.c 和file2.c 均可以用file3.c 中的内容，而在file2.c 中不必再用＃include \"file3.c” 了 在一个被包含文件中又可以包含另一个被包含文件，即文件包含是可以嵌套的 被包含文件（如file2.c) 与其所在的文件(file1.c) 在预编译后已成为同一个文件（而不是两个文件），因此，如果file2.c 中有全局静态变量，它也在filel.c 文件中有效，不必再用extern 声明。 全局变量是否可以定义在可被多个 .c 文件包含的头文件中？为什么？ 如果包含该头文件（其中定义有全局变量n) 的多个.c 文件属于同一个工程，并且希望通过该全局变量n 在这些.c 文件的函数中共享数据，这是不可以的。例如，一个工程包含三个文件： headfile.h 头文件： 1int n; ／／全局变量 file1.c 文件： 123#include &lt;stdio.h&gt;#include &quot;headfile.h&quot;…… file2.c 文件： 123#include &lt;stdio.h&gt;#include &quot;headfile.h&quot;…… 在包含文件预处理之后，相当于一个程序中两次定义全局变量n，在编译时会出现变量重复定义的编译错误。 如果将headfile.h 头文件中全局变量n的定义改为static int n;，程序正确执行，即可以在不同c文件中定义同名的全局变量，但变量n为静态全局变量，不能在多个.c文件的函数中共享数据。即，虽然此时每个文件中都有静态全局变量n，但每个文件中的变量n的地址都是不相同的，只是变量名看似相同，并非真正的全局变量。 头文件中的的static变量意味着什么？ 菜鸟教程：C/C++ 中 static 的用法全局变量与局部变量","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"c&c++","slug":"cs/c-c","permalink":"https://silencht.github.io/categories/cs/c-c/"}]},{"title":"cpp-thread_local","date":"2023-11-29T02:08:16.533Z","path":"wiki/cs/c&c++/cpp-thread_local/","text":"线程局部存储 线程局部存储（TLS, thread local storage）是一个已有的概念。线程局部存储是指对象内存在线程开始后分配，线程结束时回收且每个线程有该对象自己的实例，线程局部存储的对象都是独立于各个线程的。简单地说，所谓线程局部存储变量，就是拥有线程生命期及线程可见性的变量。虽然C++一直没有在语言层面支持它，但是很早之前操作系统就有办法支持线程局部存储了。 缘由 线程局部存储实际上是由单线程程序中的全局 / 静态变量被应用到多线程程序中被线程共享而来。我们可以简单地回顾一下所谓的线程模型。通常情况下，线程会拥有自己的栈空间，但是堆空间、静态数据区（如果从可执行文件的角度来看，静态数据区对应的是可执行文件的data、bss段的数据，而从C/C++语言层面而言，则对应的是全局/静态变量）则是共享的。这样一来，全局、静态变量在这种多线程模型下就总是在线程间共享的。全局、静态变量的共享虽然会带来一些好处，尤其对一些资源性的变量（比如文件句柄）来说也是应该的，不过并不是所有的全局、静态变量都适合在多线程的情况下共享。 代码示例： 123456789101112131415161718192021222324#include &lt;pthread.h&gt;#include &lt;iostream&gt;using namespace std;int errorCode = 0;void* MaySetErr(void * input)&#123; if(*(int*)input == 1) errorCode = 1; else if(*(int*)input == 2) errorCode = -1; else errorCode = 0;&#125;int main()&#123; int input_a = 1; int input_b = 2; pthread_t thread1,thread2; pthread_create(&amp;thread1, NULL,&amp;MaySetErr,&amp;intput_a); pthread_create(&amp;thread2, NULL,&amp;MaySetErr,&amp;intput_b); pthread_join(thread2,NULL); pthread_join(thread2,NULL);&#125;//编译选项 g++ name.cpp -lpthread 在上述代码中，函数MaySetErr函数可能会根据输入值input设置全局的错误码errorCode。设想一下，一个多线程程序的线程A在某个时刻刚刚调用过一个函数，正准备获取其错误码，也正是这个时刻，另外一个线程B在执行了某个函数后修改了这个错误码，那么线程A接下来获取的错误码自然不会是它真正想要的那个。这种线程间的竞争关系破坏了errno的准确性，导致一些程序中运行的错误将会被隐藏不报。 实际上，本例中的errorCode即是POSIX标准中的错误码全局变量errno在多线程情况下遭遇的问题的一个简化。为了规避由此产生的不确定性，POSIX将errno重新定义为线程独立的变量，为了实现这个定义就需要用到线程局部存储，直到C++11之前，errno都是一个静态变量，而从C++11开始errno被修改为一个线程局部存储变量TLS。 定义 各个编译器公司都有自己的TLS标准。我们在g++/clang++/xlc++中可以看到如下的语法： 1__thread int errCode 即在全局或者静态变量的声明中加上关键字__thread，即可将变量声明为TLS变量。每个线程将拥有独立的errCode的拷贝，一个线程中对errCode的读写并不会影响另外一个线程中的errCode的数据。 C++11对TLS标准做出了一些统一的规定。与__thread修饰符类似，声明一个TLS变量的语法很简单，即通过thread_local修饰符声明变量即可。 1234567891011#一个例子int thread_local errCode;#另一个例子struct X&#123; thread_local static int i;&#125;thread_local X a;int main()&#123; thread_local X b;&#125; 一旦声明一个变量为thread_local，在同一个线程中，一个线程局部存储对象只会初始化一次，即使在某个函数中被多次调用。这一点和单线程程序中的静态对象非常相似。相对应的，对象的销毁也只会发生一次，通常发生在线程退出的时刻。。 thread_local说明符可以用来声明线程生命周期的对象，它能与static或extern结合，分别指定内部或外部链接，不过额外的static并不影响对象的生命周期。换句话说，static并不影响其线程局部存储的属性。 虽然TLS变量的声明很简单，使用也很直观，不过实际上TLS的实现需要涉及编译器、链接器、加载器甚至是操作系统的相互配合。在TLS中一个常被讨论的问题就是TLS变量的静态/动态分配的问题，即TLS变量的内存究竟是在程序一开始就被分配还是在线程开始运行时被分配。通常情况下，前者比后者更易于实现。C++11标准允许平台/编译器自行选择采用静态分配或动态分配，或者两者都支持。 还有一点值得注意的是，C++11对TLS只是做了语法上的统一，而对其实现并没有做任何性能上的规定。这可能导致thread_local声明的变量在不同平台或者不同的TLS实现上出现不同的性能（通常TLS变量的读写性能不会高于普通的全局/静态变量）。如果读者想得到最佳的平台上的TLS变量的运行性能的话，最好还是阅读代码运行平台的相关文档。 在了解了线程局部存储的意义之后，让我们回头仔细阅读其定义，会发现线程局部存储只是定义了对象的生命周期，而没有定义可访问性。也就是说，我们可以获取线程局部存储变量的地址并将其传递给其他线程，并且其他线程可以在其生命周期内自由使用变量。不过这样做除了用于诊断功能以外没有实际意义，而且其危险性过大，一旦没有掌握好目标线程的声明周期，就很可能导致内存访问异常，造成未定义的程序行为，通常情况下是程序崩溃。 值得注意的是，使用取地址运算符&amp;取到的线程局部存储变量的地址是运行时被计算出来的，它不是一个常量，也就是说无法和constexpr结合： 1234567thread_local int tv;static int sv;int main()&#123; constexpr int *sp = &amp;sv;//编译成功，sv的地址在编译时确定 constexpr int *tp = &amp;tv;//编译失败，tv的地址在运行时确定&#125; 在上面的代码中，由于sv是一个静态变量，因此在编译时可以获取其内存常量地址，并赋值到常量表达式sp。但是tv则不同，它在线程创建时才可能确定内存地址，所以这里会产生编译错误。 多线程已经成为现代程序应用中不可缺少的技术环节，但是在C++11标准出现之前，C++语言标准对多线程的支持是不完善的，无法创建线程局部存储对象就是其中的一个缺陷。幸好C++11的推出挽救了这种尴尬的局面。 参考文献 摘改自《深入理解C++11：C++11新特性解析与应用》 摘改自《现代C++语言特性解析》","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"c&c++","slug":"cs/c-c","permalink":"https://silencht.github.io/categories/cs/c-c/"}]},{"title":"an-introductionto-gcc-Brian-Gough","date":"2023-11-29T02:08:16.533Z","path":"wiki/cs/compile&debug/an-introductionto-gcc-Brian-Gough/","text":"2 编译一个C程序 2.1 编译一个简单的C程序 源文件：hello.c 123456#include&lt;stdio.h&gt;int main(void)&#123; printf(&quot;Hello,world!\\n&quot;); return 0;&#125; 编译命令：gcc -Wall hello.c -o hello NOTE： 机器代码输出文件由-o选项指定，这个选项通常在最后给出； 如果省略该选项，输出将被写入a.out的默认文件； 如果一个与可执行文件同名的文件已经存在于当前目录中，它将被覆盖； 选项-Wall打开所有最常用的编译器警告，建议始终使用此选项！ 运行命令：./hello 输出结果：Hello,world! 2.2 在一个简单的程序中发现错误 源文件：bad.c 123456#include &lt;stdio.h&gt;int main (void)&#123; printf (&quot;Two plus two is %f\\n&quot;, 4); return 0;&#125; 编译命令：gcc -Wall bad.c -o bad 编译警告： 12345bad.c: In function ‘main’:bad.c:4:27: warning: format ‘%f’ expects argument of type ‘double’, but argument 2 has type ‘int’ [-Wformat=] printf(&quot;Two plus two is %f\\n&quot;,4); ~^ %d 运行命令：./bad 输出结果：Two plus two is 0.000000（实际结果因平台与环境不同而不同） 2.3 编译多个源文件 源文件 文件1：main.c 123456#include &quot;hello.h&quot;int main (void)&#123; hello (&quot;world&quot;); return 0;&#125; 文件2：hello.h 1void hello (const char * name); 文件3：hello_fn.c 123456#include &lt;stdio.h&gt;#include &quot;hello.h&quot;void hello (const char * name)&#123; printf (&quot;Hello, %s!\\n&quot;, name);&#125; 编译命令：gcc -Wall main.c hello_fn.c -o newhello NOTE： 头文件‘hello.h’在命令行上的文件列表中没有指定。 源文件中的指令#include “hello.h”指示编译器在适当的位置自动包含它。 运行命令：./newhello 输出结果：Hello,World! 2.4 独立编译文件 NOTE： 当程序存储在独立的源文件中时，只有更改过的文件需要在修改源代码后重新编译。 在这种方法中，源文件先被单独编译，然后再连接在一起——这是一个分为两阶段的过程。 在第一阶段，在不创建可执行文件的情况下编译文件。第一阶段的结果被称为对象文件，在使用GCC时使用扩展名.o表示。 在第二阶段，对象文件由一个名为链接器的单独程序合并在一起。链接器将所有对象文件组合在一起，创建一个可执行文件。 对象文件包含机器代码，代码中任何引用了其他文件中函数（或变量）的内存地址的地方都暂未定义（缺失）。 这就允许在不直接引用其他文件的情况下编译源文件。 链接器在生成可执行文件时填充这些缺失的地址。 2.4.1 从源文件创建一个对象文件 编译命令：gcc -Wall -c main,c -c选项指定一个源文件编译为对象文件，在这种情况下，不需要-o选项来指定输出文件的名称。当使用-c编译时，编译器会自动创建一个对象文件，其名称与源文件相同，使用.o而不是原始扩展名。 这将生成一个对象文件main.o，其中包含主函数的机器代码。它包含对外部函数hello的引用，但在这个阶段，对象文件中留下了相应缺失的内存地址（稍后将通过链接来填写）。 编译命令：gcc -Wall -c hello_fn.c 生成对象文件hello_fn.o 2.4.2 从对象文件创建可执行文件 创建可执行文件的最后一步是使用gcc将对象文件链接在一起，并填写外部函数的缺失地址。 要将对象文件链接在一起，只需使用命令： 链接命令：gcc main.o hello_fn.o -o hello NOTE： 不需要-Wall选项的原因之一是每个单个源文件已经成功编译为对象文件了。一旦成功编译了源文件，链接是一个明确的过程，它要么成功，要么失败（只有在有无法解决的引用时才会失败）。 要执行链接步骤，gcc使用链接器ld，这是一个单独的程序。 在GNU系统上使用GNU链接器：GNU ld。 其他系统可以使用GNU linker with GCC，或它们自己的链接器。通过运行链接器，gcc从对象文件中创建可执行文件。 运行命令：./hello 输出结果：Hello,World! 2.4.3 对象文件的链接顺序 在类Unix系统中，编译器和链接器的一般行为是在命令行指定的对象文件中从左到右搜索外部函数。这意味着包含某函数定义的对象文件应该出现在调用该函数的任何文件之后。 因此，2.4.2节编译命令中，hello_fn.o应该放在main.o后面。 大多数当前编译器和链接器将搜索所有对象文件，而不管顺序如何，但由于并非所有编译器都这样做，所以最好遵循从左到右排序对象文件的约定。 2.5 重新编译和重新链接 源文件：main.c 123456#include &quot;hello.h&quot;int main (void)&#123; hello (&quot;everyone&quot;); /* changed from &quot;world&quot; */ return 0;&#125; 重新编译命令：gcc -Wall -c main.c 重新链接命令：gcc main.o hello_fn.o -o hello NOTE： 产生新的main.o文件后，没有必要为hello_fn.c编译一个新的对象文件，因为该文件和它所依赖的相关文件，如头文件，都没有发生更改。 如果文件hello_fn.c被修改，我们可以重新编译hello_fn.c来创建一个新的对象文件hello_fn.o，并将其与现有文件main.o重新链接【但如果函数的原型发生了变化，就有必要修改和重新编译使用它的所有其他源文件】。 一般来说，链接比编译更快——在具有许多源文件的大型项目中，只重新编译已修改的文件可以节省大量时间。 运行命令：./hello 输出结果：Hello,everyone! 2.6 链接外部库（静态库） 库是可以链接到程序中的预编译对象文件的集合。 库最常用的是提供系统函数，比如C数学库中找到的平方根函数sqrt。 库通常存储在具有扩展名.a的特殊存档文件中，称为静态库。它们是用一个单独的工具GNU archiver (ar)从对象文件中创建的，链接器在编译时用它们解析对函数的引用。 NOTE： 标准系统库通常存储在'/usr/lib'、'/usr/lib64'、'/lib'或'/lib64'中。如C数学库一般存储在'/usr/lib/libm.a'（腾讯云服务器-Ubuntu18.04系统中，该文件位于'/usr/lib/x86_64-linux-gnu'目录下），相应的原型声明存储在'/usr/include/math.h' 源文件：calc.c 12345678#include &lt;math.h&gt;#include &lt;stdio.h&gt;int main (void)&#123; double x = sqrt (2.0); printf (&quot;The square root of 2.0 is %f\\n&quot;, x); return 0;&#125; 编译命令（书中编译器）：gcc -Wall calc.c -o calc （实际测试可以顺利编译通过，可能是新版本编译器已经智能的为我们寻找到库并隐式链接好了） 编译警告： 12/tmp/ccbR6Ojm.o: In function ‘main’:/tmp/ccbR6Ojm.o(.text+0x19): undefined reference to ‘sqrt’ NOTE： 书中：出现编译错误的原因是，没有链接外部数学库libm.a，对sqrt函数的引用就无法解决。 函数sqrt在程序源代码和默认库libc.a（如printf就在这个库中）中没有定义，除非显式选择它，否则编译器不会链接到文件libm.a（实际我的gcc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0可以顺利编译通过）。 一个比较麻烦的链接编译命令：gcc -Wall calc.c /usr/lib/x86_64-linux-gnu/libm.a -o calc ​ libm.a库包含所有数学函数的对象文件，如sin、cos、exp、log和sqrt。 链接器通过搜索找到包含sqrt函数的对象文件。一旦找到了sqrt函数的对象文件，就可以链接主程序并生成完整的可执行文件。 ​ 为了避免在命令行上指定长路径的需要，编译器提供了一个用于连接库的捷径选项-l。 例如，下面的命令： 便捷链接编译命令：gcc -Wall calc.c -lm -o calc 一般来说，编译器选项 ' -l NAME ' 将尝试将对象文件与标准库目录中的库文件 libNAME.a 链接起来。 2.6.1 库的链接顺序 库的链接顺序与对象文件链接顺序遵循相同的规则：从左到右搜索它们——包含某函数定义的库应该出现在使用它的任何源文件或对象文件之后。 这包括用快捷键‘-l’选项指定的库，如下面的命令所示： 编译命令：gcc -Wall calc.c -lm -o calc（正确的顺序） 编译命令：gcc -Wall -lm calc.c -o calc（错误的顺序，但是我的环境中，编译器不会编译错误） ``` main.o: In function ‘main’: main.o(.text+0xf): undefined reference to ‘sqrt’ 12345678910111213141516171819- NOTE： - 当使用多个库时，应该对库本身遵循相同的约定：调用另一个库中定义的外部函数的库应出现在包含该函数的库之前。 - 至于对象文件，大多数当前编译器将搜索所有库，而不管顺序如何。 然而，由于并非所有编译器都这样做，所以最好遵循从左到右排序库的惯例### 2.7 使用库的头文件在使用库时，必须包含适当的头文件，以便声明函数参数并返回具有正确类型的值。- 源文件：badpow.c ```c #include &lt;stdio.h&gt; int main (void) &#123; double x = pow (2.0, 3.0); printf (&quot;Two cubed is %f\\n&quot;, x); return 0; &#125; 该文件缺乏 #include &lt;math.h&gt; 语句 编译命令：gcc badpow.c -lm 运行命令：./a.out 输出结果：Two cubed is 2.851120（根据特定的平台和环境，显示的实际输出可能会有所不同 ） 结果错误，正确应为8。因为调用pow的参数和返回值是用不正确的类型传递的 编译命令：gcc -Wall badpow.c -lm 编译警告： 12badpow.c: In function ‘main’:badpow.c:5: warning: implicit declaration of function ‘pow’ 3 编译选项 本章描述GCC中可用的其他常用编译器选项。 这些选项控制诸如：定位库和文件的搜索路径、使用附加警告和诊断、预处理器宏和特定版本的C语言的特性。 3.1 设置搜索路径 在上一章中，我们看到了如何使用快捷选项-lm和头文件math.h 链接C标准数学库libm.a中带有函数的程序。 而使用库头文件编译程序时常见的问题是： 1FILE.h: No such file or directory 如果该头文件不存在于gcc使用的标准头文件目录中，则会发生上述情况。 库也会出现类似的问题： 1/usr/bin/ld: cannot find library 同样的，如果用于链接的库不存在于gcc使用的标准库目录中，则会发生上述情况。 默认情况下，gcc搜索以下目录的头文件： 12/usr/local/include//usr/include/ 以及以下目录的库文件： 12/usr/local/lib//usr/lib/ 头文件的目录列表通常被称为包含路径，库的目录列表被称为库搜索路径或链接路径。 这些路径上的目录是按顺序搜索的，在上面的两个列表中从前到后搜索。默认的搜索路径还可能包括附加的系统相关目录或特定站点（site- specific）的目录，以及 gcc 本身的安装目录。 例如，在64位平台上，默认情况下还可以搜索附加的 'lib64' 目录。例如，在/usr/local/include中找到的头文件优先于在/usr/include中具有相同名称的文件’。 类似地，在/usr/local/lib中找到的库优先于在/usr/lib中同名的库。 当在其他目录中安装其他库时，需要扩展搜索路径，以便找到库。 编译器选项-I和-L分别在包含路径和库搜索路径的开头添加新目录。 3.1.1 搜索路径示例 下面的示例程序使用一个库，该库可以作为系统上的附加包安装——GNU数据库管理库(GDBM)。 GDBM库将键-值对存储在DBM文件中——这是一种数据文件类型，允许通过键（任意字符序列)存储和索引值。 源文件：dbmain.c 1234567891011121314#include &lt;stdio.h&gt;#include &lt;gdbm.h&gt;int main (void)&#123; GDBM_FILE dbf; datum key = &#123; &quot;testkey&quot;, 7 &#125;; /* key, length */ datum value = &#123; &quot;testvalue&quot;, 9 &#125;; /* value, length */ printf (&quot;Storing key-value pair... &quot;); dbf = gdbm_open (&quot;test&quot;, 0, GDBM_NEWDB, 0644, 0); gdbm_store (dbf, key, value, GDBM_INSERT); gdbm_close (dbf); printf (&quot;done.\\n&quot;); return 0;&#125; NOTE： 程序使用头文件gdbm.h和库libgdbm.a。 如果库已安装在‘/usr/local/lib’的默认位置，头文件在‘/usr/local/include’中，则可以使用以下简单命令编译程序： 编译命令：gcc -Wall dbmain.c -lgdbm NOTE： 如果GDBM的头文件和库所在的两个目录都是默认的 gcc 包含路径和链接路径的一部分，那么上面的命令可以成功编译。 但是，如果GDBM已经安装在不同的位置，尝试编译程序将会产生以下错误：dbmain.c:1: gdbm.h: No such file or directory。 例如，如果GDBM包的1.8.3版本安装在目录‘/opt/gdbm-1.8.3’下，则头文件的位置将是'/opt/gdbm-1.8.3/include/gdbm.h'。这不是默认的 gcc 包含路径的一部分。 此时，使用命令行选项-I将适当的目录添加到包含路径允许编译程序，但不链接的话： 编译命令：gcc -Wall -I/opt/gdbm-1.8.3/include dbmain.c -lgdbm 编译警告： 12/usr/bin/ld: cannot find -lgdbm collect2: ld returned 1 exit status NOTE： 包含库的目录在链接路径中仍然缺失。可以使用以下选项添加到链接路径中：-L/opt/gdbm-1.8.3/lib/ 编译命令：gcc -Wall -I/opt/gdbm-1.8.3/include -L/opt/gdbm-1.8.3/lib dbmain.c -lgdbm NOTE： 请注意，不要将头文件的绝对路径放在源代码中的#include语句中，因为这可能会影响源程序在其他系统上编译。 应该始终使用-I选项或INCLUDE_PATH环境变量来设置头文件的包含路径。 3.1.2 环境变量 头文件和库的搜索路径也可以通过shell中的环境变量来控制。 其他目录可以使用环境变量C_INCLUDE_PATH(对于C头文件)或CPLUS_INCLUDE_PATH(对于C头文件)将其添加到包含路径中。 例如，下面的命令将在编译C程序时向包含路径添加‘/opt/gdbm-1.8.3/include' 向环境变量添加包含路径命令： 12$ C_INCLUDE_PATH=/opt/gdbm-1.8.3/include$ export C_INCLUDE_PATH 此目录将在命令行上指定的选项-I和标准默认目录'/usr/local/include'和'/usr/include'之前搜索。需要shell命令 export 导出来使环境变量可用于shell本身之外的程序——例如编译器。 类似地，可以使用环境变量LIBRARY_PATH将附加目录添加到链接路径中。 例如，下面的命令将向链接路径添加‘/opt/gdbm-1.8.3/lib' 向环境变量添加链接路径命令： 12$ LIBRARY_PATH=/opt/gdbm-1.8.3/lib$ export LIBRARY_PATH 此目录将在命令行中指定的选项-L和标准默认目录‘/usr/local/lib’和‘/usr/lib’之前进行搜索。 如果使用上面给出的环境变量设置，程序dbmain.c可以在没有-I和-L选项的情况下成功编译： gcc -Wall dbmain.c -lgdbm 因为默认路径现在已经包含了环境变量C_INCLUDE_PATH和LIBRARY_PATH中指定的目录。 3.1.3 扩展搜索路径 按照标准的Unix搜索路径约定，可以在环境变量中将几个目录利用冒号分隔列表一起指定： 1DIR1:DIR2:DIR3:... 然后按从左到右的顺序搜索目录。 可以使用单个点.来指定当前目录（还可以使用空路径元素指定当前目录，例如.:DIR:DIR2等价于:DIR:DIR2）。 例如，下面的设置分别为各自安装在当前目录.和位于/opt/gdbm-1.8.3和/net的 include 和 lib 目录创建默认包含路径和链接路径： 12$ C_INCLUDE_PATH=.:/opt/gdbm-1.8.3/include:/net/include$ LIBRARY_PATH=.:/opt/gdbm-1.8.3/lib:/net/lib 若要在命令行上指定多个搜索路径目录，可以重复选项-I和-L。 例如下面的命令与上面的效果一样： 1$ gcc -I. -I/opt/gdbm-1.8.3/include -I/net/include -L. -L/opt/gdbm-1.8.3/lib -L/net/lib 当环境变量和命令行选项一起使用时，编译器按以下顺序搜索目录： 命令行选项-I和-L，从左到右; 由环境变量指定的目录，例如C_INCLUDE_PATH和LIBRARY_PATH; 默认系统目录; 3.2 共享库（动态库）和静态库 虽然上面的示例程序已经成功地编译和链接，但在能够加载和运行可执行文件之前需要最后一步。如果尝试直接启动可执行文件，那么大多数系统都会出现以下错误： 123$ ./a.out./a.out: error while loading shared libraries:libgdbm.so.3: cannot open shared object file: No such file or directory 这是因为GDBM包提供了一个共享库。 这种类型的库需要特殊处理——它必须在可执行文件运行之前从磁盘加载。 外部库通常以两种形式提供：静态库和共享库。 静态库是前面看到的.a文件。 当程序与静态库链接时，程序使用任何外部函数的对象文件中的机器代码将从库复制到最终的可执行文件中。 共享库使用更高级的链接形式处理，这使得可执行文件更小。 它使用扩展名.so，它代表共享对象。与共享库链接的可执行文件只包含它所需要的函数的一个小表，而不是来自外部函数的对象文件的完整机器代码。 在可执行文件开始运行之前，操作系统将外部函数的机器代码从磁盘上的共享库文件复制到内存中——这个过程被称为动态链接。 因为一个库的一个副本可以在多个程序之间共享，所以动态链接使可执行文件更小，并节省磁盘空间。 大多数操作系统还提供一种虚拟内存机制，允许所有运行的程序使用物理内存中的共享库的一份副本，从而节省内存和磁盘空间。 此外，共享库可以在不重新编译使用它的程序的情况下更新库（前提是库的接口不会更改）。 由于这些优点，gcc 编译程序在大多数系统中默认使用共享库（如果它们是可用的话）。 每当静态库 'libName.a’ 用选项-lName链接时，编译器首先检查是否具有相同名称和.so扩展的替代共享库。 在这种情况下，当编译器在链接路径中搜索'libgdbm'库时，如果它在目录‘/opt/gdbm-1.8.3/lib’中同时找到以下两个文件： 123$ cd /opt/gdbm-1.8.3/lib$ ls libgdbm.*libgdbm.a libgdbm.so 此时，它使用共享对象文件而不是静态库。 然而，当可执行文件启动时，它加载使用了共享库的程序函数时必须找到共享库才能将其加载到内存中。默认情况下，加载程序只在预定义的系统目录集中搜索共享库，例如‘/usr/local/lib’和‘/usr/lib’。因此，如果共享库不位于预定义的目录中，则必须将其添加到加载路径（Load Path）中。 （请注意，原则上，包含共享库的目录可以使用链接器选项 -rpath在可执行文件本身中存储（“硬编码”），但通常不会这样做，因为如果移动库或将可执行文件复制到另一个系统，则会产生问题）。 设置加载路径最简单的方法是通过环境变量LD_LIBRARY_PATH。 例如，下面的命令将加载路径设置为‘/opt/gdbm-1.8.3/lib’，以便于找到动态库‘libgdbm.so'： 1234$ LD_LIBRARY_PATH=/opt/gdbm-1.8.3/lib$ export LD_LIBRARY_PATH$ ./a.outStoring key-value pair... done. 可执行文件现在运行成功，打印它的消息并创建一个名为'test'的DBM文件，其中包含键-值对'testkey'和'testvalue'。 同样的，可以将几个共享库目录一起放置在加载路径中，冒号分离列表DIR1：DIR2：DIR3：…：DIRN。例如： 12$ LD_LIBRARY_PATH=/opt/gdbm-1.8.3/lib:/opt/gtk-1.4/lib$ export LD_LIBRARY_PATH 如果加载路径已经存在某些目录，可以通过这种语法来追加新的目录：LD_LIBRARY_PATH=NEWDIRS:$LD_LIBRARY_PATH。例如： 123$ LD_LIBRARY_PATH=/opt/gsl-1.5/lib:$LD_LIBRARY_PATH$ echo $LD_LIBRARY_PATH/opt/gsl-1.5/lib:/opt/gdbm-1.8.3/lib:/opt/gtk-1.4/lib 系统管理员可以为所有用户设置LD_LIBRARY_PATH变量，将其添加到默认登录脚本中，例如‘/etc/profile’。 或者，静态链接可以强制使用 gcc 的-static选项，以避免使用共享库。例如： 1$ gcc -Wall -static -I/opt/gdbm-1.8.3/include/ -L/opt/gdbm-1.8.3/lib/ dbmain.c -lgdbm 上行代码创建了一个与静态库'libgdbm.a'链接的可执行文件，可以在不设置LD_LIBRARY_PATH环境变量或将共享库放入默认目录的情况下运行。 如前所述，还可以通过指定命令行上的库的完整路径直接链接到单个库文件。例如，下面的命令将直接链接到静态库'libgdbm.a’： 1$ gcc -Wall -I/opt/gdbm-1.8.3/include dbmain.c /opt/gdbm-1.8.3/lib/libgdbm.a 下面的命令将链接到动态库文件'libgdbm.so’： 1$ gcc -Wall -I/opt/gdbm-1.8.3/include dbmain.c /opt/gdbm-1.8.3/lib/libgdbm.so 在这种链接共享库的情况下，仍然需要在运行可执行文件时设置库加载路径。 3.3 C语言标准 有几个选项可以控制gcc使用的C语言。 最常用的选项是-ansi和-pedantic。 每个标准的C语言的特定方言(dialect)也可以用-std选项选择。 3.3.1 ANSI/ISO -ansi 3.3.2 Strict ANSI/ISO -pedantic 3.3.3 Selecting specifific standards -std=c89 、-std=iso9899:1990、-std=gnu89 ... 3.4 内部警告选项 -Wall -Wall包括： -Wcomment、-Wformat、-Wunused、-Wimplicit ... 3.5 其他警告选项 略 4 使用预处理器","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"compile&debug","slug":"cs/compile-debug","permalink":"https://silencht.github.io/categories/cs/compile-debug/"}]},{"title":"gcc","date":"2023-11-29T02:08:16.533Z","path":"wiki/cs/compile&debug/gcc/","text":"本系列教程将介绍现代C/C++项目的构建编译常用工具链，GCC，Make，以及CMake。 其中，GCC是C/C++语言的编译工具，Make是增量式（编译）批处理工具，CMake是Make脚本生成工具。 在现代C/C++项目的构建中，它们的关系如下。 12 cmake make gccCMakelist.txt -----&gt; Makefile ----&gt; Cmds ---&gt; Binary 开发者需要编写CMakelist.txt文件，来配置项目相关的CMake参数。 通过运行cmake命令，自动生成对应平台的Make工具自动构建脚本Makefile文件。 当然，CMake也支持生成其他的构建工具的配置文件，比如Xcode的xxxx.xcodeproj，Visual Studio的xxxx.sln，Ninja的xxxx.ninja等等。 目前，大多数开源的C/C++项目都支持使用CMake生成Makefile文件，再调用make命令，使用Make工具进行自动构建。 Makefile文件可以看成是一系列依赖于文件的Shell命令。 它基于文件修改的时间戳来实现增量式处理。 具体规则大致如下，若生成的目标文件的时间戳早于依赖文件的时间戳时，则执行对应的命令，重新生成目标文件。 这实际上暗示了，Make工具不只用于编译，还可以用于其他的增量式文件生成任务。 使用Make工具来编译C/C++项目时，一般会使用Shell命令来调用gcc，自动化且增量式地实现C/C++源代码的编译链接等一系列工作。 GCC 在早期，GCC为GNU C Compiler的简写，即GNU计划中的C语言编译器。 但经过多年的扩展和迭代，GCC逐渐支持C、C++、Objective-C、Fortran、Java、Ada和Go等越来越多语言的编译。 因此，其GCC被重新定义为GNU Compiler Collection，即 GNU编译器套件。 在本篇中，我们仅介绍使用GCC编译C/C++项目。 值得注意的是，Apple公司曾经一直使用GCC作为官方的编译器。 但是由于GCC开发社区对Apple所提的需求，给予的优先级始终不高，甚至很多Apple的重要需求基本不做考虑。 于是，财大气粗的Apple一怒之下，决定放弃GCC，基于LLVM重新开发了编译工具Clang，支持 C、C++、Objective-C等语言。 因此，目前macOS上自带的默认gcc命令，实际上调用的是clang。 希望在macOS上使用GCC，需要自行安装，如使用macOS上常用的包管理工具Homebrew，（brew install gcc）。 比较幸运的一点事，clang在使用上（调用方式，参数等方面），基本复刻了gcc。 所以，在本篇中，笔者虽然讲GCC，但实际上给出的例子，都是使用的Clang，但基本上差异不大，不会导致太大的问题。 编译流程 使用gcc编译C/C++程序时，主要的编译流程如下，包含预处理、编译、汇编、链接等四个步骤。 以输入C语言程序源码文件b.c为例，直接调用命令gcc b.c，将会完整执行以下流程，并生成对应的可执行的二进制文件a.out。 注意，这里gcc的默认输出就是固定的a.out。 在GCC工具链中，汇编由工具as完成，链接则由工具ld完成。 123 -E -S -c b.c ------&gt; b.i ------&gt; b.s ------&gt; b.o ------&gt; a.out gcc gcc as ld 对gcc使用以下指令，将会使其编译流程停止在对应位置： -E，（prEprocessing），执行到预处理步骤之后，即处理C/C++源码中#开头的指令，包括宏展开以及#include头文件引入等等。 该指令默认不输出文件，可以使用-o指令输出约定后缀为*.i的文件。 -S，（aSsembly），执行到编译步骤之后，生成汇编文件，但不生成二进制机器码。 该指令默认的输出文件后缀为*.s。 -c，（compilation），执行到汇编步骤之后，调用工具as，从汇编码生成二进制机器码，但不进行链接。 该指令默认的输出文件后缀为*.o（object）。 不带以上参数调用gcc将会完整执行以上流程，即执行到到链接（linking）步骤之后。 链接步骤实际上调用链接工具ld来执行，会将源码生成的二进制文件，库文件，以及程序的启动部分进行组合，从而形成一个完整的二进制可执行文件。 特别的，使用指令-o，（output），可以指定输出文件的名称。 例如gcc b.c -o b.bin，将生成可执行文件b.bin，而不是默认的a.out。 以上指令都可以在编译流程任意环节的基础上进行调用，例如： 123456789&gt; gcc -E b.c -o b.i&gt; lsb.c b.i&gt; gcc -S b.ib.c b.i b.s&gt; gcc -c b.sb.c b.i b.o b.s&gt; gcc b.ob.c b.i b.o a.out b.s 编译参数 对于一个实际的C/C++项目而言，源文件一般不会只有一个，而且绝大多数情况下会使用到第三方库（Third-party Library）。 由于C/C++没有官方的包管理工具（Package Manager），如Python的pip，Java的maven，Nodejs的npm等等， 所以，在C/C++项目中使用第三方库时，一般使用系统自带的包管理器来进行第三方库的安装，例如Ubuntu下的apt-get，macOS的brew（Homebrew）等等。 同时，也可以选择自行获取第三方库的源码进行编译安装。 第三方库主要由两个部分组成，即 a)头文件， b)库文件。 头文件一般是一系列名为xxx.h（head）的文件，相当于暴露出第三方库所提供的API接口（函数签名）。 库文件一般会包含静态库文件和动态库文件，相当于第三方库在功能上的二进制实现。 其中，静态库文件是一系列名为libxxx.a（archive）的文件（Windows下为libxxx.lib，library）。 动态库文件则是一系列名为libxxx.so（shared object）的文件（Windows下为libxxx.dll，dynamic link library，macOS下为libxxx.dylib，dynamic library）。 系统自带的，以及由系统包管理器安装的第三方库，其头文件一般在/usr/include或/usr/local/include路径下，库文件一般在/lib，/usr/lib和/usr/local/lib目录下。 正是由于以上因素的影响，GCC工具链不负责管理第三方库，因此无法判定C/C++项目具体需要使用哪些库，以及这些库的准确信息，如位置、版本等。 所以，仅使用GCC，无法完全自动地解决C/C++项目第三方库的依赖问题。 我们需要人工地添加各种编译参数，如-I，-l以及-L，将所依赖的第三方库的相关信息，传递给gcc编译器。 其中-I传递的是头文件所在的目录，-l传递的是需要链接的库的名称，-L传递的是库文件所在的目录。 -I参数 回顾之前所介绍的GCC编译流程，在预处理阶段需要处理#include指令，将包含的头文件替换进源码。 一般来说，在进行预处理时，gcc会自动在当前工程目录下，以及/usr/include目录下寻找对应的头文件。 但对于位于其他目录下的第三方库的头文件，gcc无法自动寻找到所需头文件的位置，会报出形如xxx.h: file not found的错误。 我们需要使用-I参数来指定第三方库头文件的位置。 例如，在macOS下，使用Homebrew包管理器安装llvm，会相应地安装LLVM项目所包含的第三方库，其对应的头文件位于/usr/local/opt/llvm/include目录。 而我们在使用LLVM提供的库时，可以使用-I/usr/local/opt/llvm/include（或者-I /usr/local/opt/llvm/include，加空格）来指定头文件所在的位置。 从而，gcc会额外在-I参数指定的目录下搜索对应的头文件。 -I参数可以重复多次使用，从而指定多个额外的头文件目录。 -I参数一般指定绝对路径，但也可以用相对路径，比如头文件在当前目录，可以用-I.来指定。 需要注意的是，在C/C++源码中，使用#include\"xxxx.h\"语句时，其中的xxxx.h可以带上路径。 我们甚至可以使用绝对路径来引用头文件。 比如说，存在头文件/usr/local/opt/llvm/include/llvm/Pass.h，我们在使用它时，可以直接通过这样的方式引用#include\"/usr/local/opt/llvm/include/llvm/Pass.h\"。 不过，在C/C++工程中，并不推荐这种做法。 比较推荐的做法是，使用相对路径加参数-I include_dir的方法来引用头文件。 比如以上的例子中，我们会直接在源码中使用#include\"llvm/Pass.h\"，并且将llvm库的头文件所在目录，通过参数-I /usr/local/opt/llvm/include传递给gcc。 这样做能够灵活地管理第三方库版本，也便于不同机器下的多人协作开发，比直接包含绝对路径头文件要好很多。 总而言之，gcc在进行预处理时，会将库文件目录（如-I参数传递进来的目录，以及默认的/usr/include，/usr/local/include等目录），与程序源码中#include\"xxxx.h\"语句的xxxx.h进行组合拼接。 倘若某个组合，得到的路径存在实际的头文件，那么就会将该头文件包含进来。 -l参数 在GCC编译流程的链接阶段，会默认链接标准库，如libc.a，但是对于第三方库，就需要手动添加。 倘若在编译中报出如下的错误： Undefined symbols for architecture x86_64: xxx...xxx ld: symbol(s) not found for architecture x86_64这一般是由未正确指定需要链接的第三方库导致的。 在使用gcc时，一般会选择使用-l参数来指定需要链接的库。 例如，假定我们使用了math库（即#include&lt;math.c&gt;），在进行编译时，便会报出如上的Undefined错误。 这时，我们可以使用-lm（或者-l m）参数来指定需要链接math库。 注意，某些gcc编译器会把math库视为标准库进行自动链接。 这时我们需要加上-nostdlib参数，使其不自动链接标准库，才会报出如上的Undefined错误。 初看-lm参数，可能会感觉有些诡异。 那么，-l参数具体是如何使用的呢？ -l参数后需要接库名（如m），而不是库文件名（如libm.so）。 但库名和库文件名之间，存在非常直观的联系。 以math库为例，其库文件名是libm.so，而库名是m。 从中很容易看出，库名就是把库文件名的前缀lib和后缀名.so去掉后得到的。 再比如说，LLVM包含的库文件libLLVMCore.a，其对应的库名就是LLVMCore，而链接它的参数为-lLLVMCore。 -L参数 位于/lib，/usr/lib，/usr/local/lib等目录下的库文件，例如libm.so，在使用-l参数后，可以直接被链接。 但如果库文件不在这些目录里，只用-l参数，进行链接时仍会报错，ld: library not found for -lxxx。 这意味着链接程序ld在当前的库文件路径中，无法找到libxxx.so或libxxx.a。 这时，我们需要使用-L参数，将所要链接的库文件所在的路径告诉gcc。 -L参数后需要跟库文件所在的路径。 例如，在macOS下，使用Homebrew包管理器安装llvm，其对应的库文件位于/usr/local/opt/llvm/lib目录。 倘若我们需要使用库LLVMCore，即链接库文件libLLVMCore.a，除了添加-lLLVMCore参数外，还需要使用参数-L/usr/local/opt/llvm/lib，告诉gcc库文件所在的目录。 其他编译参数 除了以上的这些参数外，gcc还有一些其他的参数，也是比较重要的，在此分别简要介绍。 A. 静态链接参数 在前面讲库文件的时候，我们提到了静态链接库文件（libxxx.a）和动态链接库文件（libxxx.so）。 我们并未提及两者的区别。 其实，我们通过如下的方式简单进行理解。 gcc链接静态库文件，会将静态库文件中用到的部分，拷贝到生成的二进制程序中，从而导致生成的文件比较大； 而链接动态库文件，则不会进行拷贝，所以生成的二进制程序会比较小。 链接动态库文件的缺点是，在其他机器上运行该程序时，要求其上正确安装了对应的动态库文件。 相应的，链接静态库文件生成的程序，则没有这个要求。 在使用gcc进行链接时，默认优先使用动态链接库文件。 仅当动态链接库文件不存在时，才使用静态链接库文件。 如果需要使用静态链接的方式，则需要在编译时加上-static参数，强制使用静态链接库文件。 例如，在/usr/local/opt/llvm/lib目录下，同时存在库文件libunwind.so和libunwind.a。 为了让gcc在链接时使用静态链接库文件libunwind.a，我们可以添加-static参数，使用如下编译命令gcc hello.o –static –L/usr/local/opt/llvm/lib –lunwind。 B. 优化参数 编译优化也是编译器的重要功能，适当的编译优化能大大加速程序的执行效率。 gcc提供了4级优化参数，分别是-O0、-O1、-O2、-O3。 一般来说，数字越大，所包含的编译优化策略就越多。 此外，gcc还提供了特殊的-Os参数。 -O0参数表示不使用任何优化策略，是gcc默认的优化参数。 因为没有使用任何优化策略，编译得到的机器码与程序源码高度对应，两者之间基本可以建立一一对应的关系。所以，-O0优化非常适合用于程序调试，并且通常和生成调试信息的参数-g（generate debug information）配合使用。-g参数会在编译时给生成的二进制文件附加一些用于代码调试的信息，比如符号表和程序源码。 -O1会尽量采用一些不影响编译速度的优化策略，降低生成的二进制文件的大小，以及提高程序执行的速度。 -O2使用-O1中的所有优化策划，还会采用一些会降低编译速度的优化策略，以提高程序的执行速度。 -O3在-O2的基础上，使用更多的优化策略。这些额外的优化策略会进一步降低编译速度，而且会增加生成的二进制文件的大小，但程序的执行速度则会进一步提高。 -Os则和-O3优化的方向相反。它在-O2的基础上，采用额外的优化策略，尽量的降低生成的二进制文件的大小。 倘若对各优化参数下，所开启的优化策略感兴趣，或者希望了解其他的优化参数，可以参考[1]。 C. 宏相关参数 有时，为了保证C/C++项目的跨平台性，或者在编译时，能比较灵活地在多个相似的库中作出选择，需要在源码中使用条件编译。 条件编译即使用#ifdef M，#else，#endif（或#ifndef M，#else，#endif，以及#if，#elif，#else，#endif）等指令，通过宏定义来控制需要编译的代码。 C/C++语言中，可以使用#define M语句在源码中定义宏M。 但是条件编译一般需要从外界，如编译器，传入一个宏定义。 因此，gcc提供了宏定义参数-D以及取消宏定义参数-U。 在使用gcc进行编译时，可以通过如下的方式，来进行相应的宏操作： -Dmacro定义宏macro，默认将其定义为1，相当于在程序源码中使用#define macro语句。 -Dmacro=def定义宏macro为def，相当于在程序源码中使用#define macro=def语句。 -Umacro取消宏macro的定义，相当于在程序源码中使用#undef macro语句。 -undef取消所有非标准宏的定义。 D. 其他 此外，还有一些其他的参数，也很重要，例如： -std参数可以指定编译使用的C/C++标准。例如，-std=c++11表示使用C++11标准，-std=c99表示使用C99标准。特殊的，-ansi表示使用ANSI C标准，一般等同于-std=c90。 -Werror参数要求gcc将产生的警告（Warning）当成错误（Error）进行显示。 -Wall要求gcc显示出尽可能多的警告信息。 -w要求gcc不显示警告信息。 -Wl参数告诉gcc，将后面跟随的参数传递给链接器ld。 -v参数可以显示gcc编译过程中一些额外输出信息。 倘若希望了解gcc的其他参数，可以通过gcc --help或者man gcc查看，也可以直接参考[GCC手册1]。 pkg-config 一般来说，人工编辑第三方库的编译链接参数是比较麻烦的。 我们需要查找第三方库的头文件、库文件的安装路径，了解第三方库需要链接哪些其他的库，了解第三方库需要哪些编译参数等等。 这些都不利于第三方库的快速集成。 目前，很多现代的第三方库都提供了其对应的编译参数自动生成工具，一般名为xxx-config。 比如llvm就提供了llvm-config工具。 在使用系统包管理器，或者自行编译安装了llvm后，可以直接调用llvm-config命令。 我们以以llvm 10.0为例，进行说明。 执行llvm-config --cxxflags，可以得到-I/usr/local/Cellar/llvm/11.0.0/include -std=c++14 -stdlib=libc++ -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS。 这是编译llvm 10.0提供的库，所需的编译参数。 它说明llvm 10.0的头文件目录是/usr/local/Cellar/llvm/11.0.0/include，并且要求使用C++14标准，使用C++标准库，还定义了一些编译时需要的宏。 执行llvm-config --ldflags，可以得到-L/usr/local/Cellar/llvm/11.0.0/lib -Wl,-search_paths_first -Wl,-headerpad_max_install_names。 这是链接llvm 10.0提供的第三方库所需要的链接参数。 它告诉编译器，第三方库的位置在/usr/local/Cellar/llvm/11.0.0/lib，并会传递一些其他的参数给链接器ld。 执行llvm-config --libs会得到-lLLVMXRay -lLLVMWindowsManifest ... -lLLVMDemangle。 这是llvm 10.0可以链接的全部库。 一般我们不会选择链接所有的库。 而是会使用形如以下的命令llvm-config --libs core，得到 -lLLVMCore -lLLVMRemarks -lLLVMBitstreamReader -lLLVMBinaryFormat -lLLVMSupport -lLLVMDemangle。 这是使用core模块所需要链接的库。 执行llvm-config --system-libs会得到-lm -lz -lcurses -lxml2。 这是llvm 10.0所需要用到的系统库。 一般来说，我们会将以上命令的参数进行组合使用，例如调用llvm-config --cxxflags --ldflags --system-libs --libs core，就可以得到我们所需的全部编译参数。 除了第三方库自带的xxx-config以外，很多现代的第三方库都可以使用工具pkg-config来生成编译参数。 我们可以用pkg-config --list-all命令，来查看其所支持的所有第三方库。 pkg-config的一般使用方法是调用形如pkg-config pkg-name --libs --cflags的命令。 例如，倘若要使用gmp库，我们可以执行pkg-config gmp --libs --cflags，得到如下输出 -I/usr/local/Cellar/gmp/6.2.1/include -L/usr/local/Cellar/gmp/6.2.1/lib -lgmp。 我们可以直接复制这些输出，再粘贴到gcc命令后，也可以使用形如\"gcc a.c pkg-config gmp --libs --cflags\"的命令，通过内嵌shell命令的方式，将第三方库的编译参数传递给gcc. 原文链接","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"compile&debug","slug":"cs/compile-debug","permalink":"https://silencht.github.io/categories/cs/compile-debug/"}]},{"title":"旋转矩阵求导出现角速度的理解","date":"2023-11-29T02:06:46.261Z","path":"wiki/robot/note/旋转矩阵求导出现角速度的理解/","text":"文章来源 Author: [小林up] Link: [https://zhuanlan.zhihu.com/p/602088458] 在谷歌查资料的时候看到一个很好的帖子，讨论旋转矩阵求导为什么会出现角速度[1]。 how and why the angular velocity vector is related to the derivative of a rotation matrix 觉得打开了新的视角，记录一下，欢迎大家一起讨论学习。 所以为什么有有下面这个公式呢？ \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R} &amp; = {\\omega} \\times \\mathbf{R}\\end{align}\\\\\\) 第一种视角 要证上式就是考虑旋转矩阵按列分块 \\(\\begin{align}\\mathbf{R} &amp; = \\left[\\begin{array}{l|l|l}\\hat{\\mathbf{i} } &amp; \\hat{\\mathbf{j} } &amp; \\hat{\\mathbf{k} }\\end{array}\\right]\\end{align}\\\\\\) 即证明： \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\hat{\\mathbf{i} } &amp; = {\\omega} \\times \\hat{\\mathbf{i} } \\\\\\frac{\\mathrm{d}}{\\mathrm{d} t} \\hat{\\mathbf{j} } &amp; = {\\omega} \\times \\hat{\\mathbf{j} } \\\\\\frac{\\mathrm{d}}{\\mathrm{d} t} \\hat{\\mathbf{k} } &amp; = {\\omega} \\times \\hat{\\mathbf{k} }\\end{align}\\\\\\) 我们知道旋转矩阵的每一列都有这样的性质： \\(\\begin{align}\\|\\hat{\\mathbf{u}}\\| &amp; = 1\\end{align}\\\\\\) 这是因为旋转矩阵是正交矩阵： \\(\\begin{align}\\mathbf{R}^{T} \\mathbf{R} &amp; = \\mathbf{I}\\end{align}\\\\\\) 于是我们有： \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} {\\hat{\\mathbf{u}}^T \\hat{\\mathbf{u}}} &amp; = 0\\end{align}\\\\\\) 继而得到： \\(\\begin{align}\\hat{\\mathbf{u}} \\cdot \\frac{\\mathrm{d}}{\\mathrm{d} t} \\hat{\\mathbf{u}} &amp; = 0\\end{align}\\\\\\) 这不就说明每一列的\\(\\hat{u}\\)和其微分垂直吗？其微分可以表示为叉乘的形式（保证垂直）： \\(\\begin{align}\\hat{\\mathbf{u}} \\cdot({\\omega} \\times \\hat{\\mathbf{u}}) &amp; = 0\\end{align}\\\\\\) 也即我们有： \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\hat{\\mathbf{u}} &amp; = {\\omega} \\times \\hat{\\mathbf{u}}\\end{align}\\\\\\) 于是上式得到了证明。 \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R} &amp; = {\\omega} \\times \\mathbf{R}&amp;=[{\\omega} ]_\\times \\mathbf{R}\\end{align}\\\\\\) 式中： \\(\\begin{align}[{\\omega}]_\\times &amp; = \\left[\\begin{array}{ccc}0 &amp; -\\omega_{z} &amp; \\omega_{y} \\\\\\omega_{z} &amp; 0 &amp; -\\omega_{x} \\\\-\\omega_{y} &amp; \\omega_{x} &amp; 0\\end{array}\\right]\\end{align}\\\\\\) \\([{\\omega}]_\\times\\)的定义下同。 第二种视角 考虑全局坐标系下旋转角标为\\(S\\)，连体坐标系旋转角标为\\(B\\)，空间中一个矢量为\\(\\mathbf{u}\\)，我们有下面的关系： \\(\\begin{align}\\mathbf{u}_{S} &amp; = \\mathbf{R}\\mathbf{u}_{B}\\end{align}\\\\\\) 求导我们可以得到： \\(\\begin{align}\\mathbf{v}_{S} &amp; = \\left(\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R}\\right)\\mathbf{u}_{B}\\end{align}\\\\\\) 上式中\\(\\mathbf{v}_{S}\\)是全局坐标系下的速度，等式右边没有\\(\\mathbf{u}_{B}\\)的导数是因为连体坐标系内观察坐标始终没有变化，导数为0。 于是我们有： \\(\\begin{align}\\mathbf{v}_{S} &amp; =\\omega \\times\\mathbf{u}_{S} \\\\&amp; =\\omega \\times \\mathbf{R}\\mathbf{u}_{B} \\\\\\end{align}\\\\\\) 对比我们可以知道： \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R} &amp; = {\\omega} \\times \\mathbf{R}\\\\&amp;=[{\\omega} ]_\\times \\mathbf{R}\\end{align}\\\\\\) 空间角速度和物体角速度 我们经常在论文里看到反过来写的旋转矩阵的导数，这又是为什么呢？ \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R}&amp;= \\mathbf{R}[{\\omega} ]_\\times\\end{align}\\\\\\) 准确地说，上述\\([{\\omega} ]_\\times\\)应该指的是物体角速度\\([{\\omega}^B ]_\\times\\)： \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R}&amp;= \\mathbf{R}[{\\omega}^B ]_\\times\\end{align}\\\\\\) 我们需要搞清楚的是前面所推导和论证的公式准确地说应该描述的是惯性坐标系的空间角速度\\([{\\omega}^S ]_\\times\\)： \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R}&amp;=[{\\omega}^S ]_\\times \\mathbf{R}\\end{align}\\\\\\) 为了方便我们把旋转矩阵的微分写作： \\(\\begin{align}\\dot{\\mathbf{R}}=\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R}\\end{align}\\\\\\) 于是我们便得到： \\(\\begin{align}[{\\omega}^S ]_\\times=\\dot{\\mathbf{R}}\\mathbf{R}^{-1}\\end{align}\\\\\\) \\(\\begin{align}[{\\omega}^B ]_\\times=\\mathbf{R}^{-1}\\dot{\\mathbf{R}}\\end{align}\\\\\\) 空间角速度在前面（第二种视角）我们已经推导过了，下面我们推导一下物体角速度，根据坐标变换关系我们有： \\(\\begin{align}\\mathbf{v} _{S} &amp; = \\mathbf{R} \\mathbf{v} _{B}\\end{align}\\\\\\) \\(\\begin{align}\\mathbf{\\omega} _{S} &amp; = \\mathbf{R} \\mathbf{\\omega} _{B}\\end{align}\\\\\\) 根据前面的： \\(\\begin{align}\\mathbf{v}_{S} &amp; = \\dot{\\mathbf{R}}\\mathbf{u}_{B}\\end{align}\\\\\\) 则有： \\(\\begin{align}\\mathbf{R}^{-1}\\mathbf{v}_{S} &amp; = \\mathbf{R}^{-1}\\dot{\\mathbf{R}}\\mathbf{u}_{B}\\end{align}\\\\\\) 也即： \\(\\begin{align}\\mathbf{v}_{B} &amp; = \\mathbf{R}^{-1}\\dot{\\mathbf{R}}\\mathbf{u}_{B}=[{\\omega}^B ]_\\times\\mathbf{u}_{B}\\end{align}\\\\\\) 于是我们便得到： \\(\\begin{align}[{\\omega}^B ]_\\times=\\mathbf{R}^{-1}\\dot{\\mathbf{R}}\\end{align}\\\\\\) 也即证明了： \\(\\begin{align}\\frac{\\mathrm{d}}{\\mathrm{d} t} \\mathbf{R}&amp;= \\mathbf{R}[{\\omega} ]_\\times\\end{align}\\\\\\) 其他证明的思考 在李群李代数的一些书里，为了说明旋转矩阵的李代数是反对称矩阵，一般有这样的证明： \\(\\begin{align}\\mathbf{R}^{T} \\mathbf{R} &amp; = \\mathbf{I}\\end{align}\\\\\\) 对左右两边对时间求导数： \\(\\begin{align}\\mathbf{R}^{T} \\dot{\\mathbf{R}}+\\dot{\\mathbf{R}}^{T} \\mathbf{R} &amp; = \\mathbf{0}\\end{align}\\\\\\) \\(\\begin{align}[{\\omega} ]_\\times &amp; = \\mathbf{R}^{T} \\dot{\\mathbf{R}} \\quad \\text { and } \\quad {[{\\omega} ]_\\times}+[{\\omega} ]_\\times^{T} = \\mathbf{0}\\end{align}\\\\\\) \\(\\begin{align}\\dot{\\mathbf{R}} &amp; = \\mathbf{R} [{\\omega} ]_\\times\\end{align}\\\\\\) 事实上，我也可以对下面的式子做同样的操作。 \\(\\begin{align}\\mathbf{R} \\mathbf{R}^{T} &amp; = \\mathbf{I}\\end{align}\\\\\\) 对左右两边对时间求导数： \\(\\begin{align}\\dot{\\mathbf{R}} {\\mathbf{R}}^{T} +{\\mathbf{R}} \\dot{\\mathbf{R}}^{T}&amp; = \\mathbf{0}\\end{align}\\\\\\) \\(\\begin{align}[{\\omega} ]_\\times &amp; = \\dot{\\mathbf{R}}\\mathbf{R}^{T} \\quad \\text { and } \\quad {[{\\omega} ]_\\times}+[{\\omega} ]_\\times^{T} = \\mathbf{0}\\end{align}\\\\\\) \\(\\begin{align}\\dot{\\mathbf{R}} &amp; = [{\\omega} ]_\\times\\mathbf{R} \\end{align}\\\\\\) 以上两个都证明可以从数学的定义说明旋转矩阵群\\(SO(3)\\)的李代数是反对称矩阵。然而这样的证明并没有反映究竟是物体角速度还是空间角速度，实际应用中可能会让读者产生困惑，关于物体角速度和空间角速度和旋转矩阵的关系还是要用前面的推导说明。 本文使用 Zhihu On VSCode 创作并发布 参考 [^](#ref_1_0)Derivative of rotation matrix produces angular velocity vector https://physics.stackexchange.com/questions/637857/derivative-of-rotation-matrix-produces-angular-velocity-vector","tags":[],"categories":[{"name":"robot","slug":"robot","permalink":"https://silencht.github.io/categories/robot/"},{"name":"note","slug":"robot/note","permalink":"https://silencht.github.io/categories/robot/note/"}]},{"title":"cpp-basic","date":"2023-10-29T07:15:58.000Z","path":"wiki/cs/c&c++/cpp-basic/","text":"本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。 1 内存分区模型 C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前 ​ 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 ​ 代码区： ​ 存放 CPU 执行的机器指令 ​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 ​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 ​ 全局区： ​ 全局变量和静态变量存放在此. ​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ​ ==该区域的数据在程序结束后由操作系统释放==. 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() &#123; //局部变量 int a = 10; int b = 10; //打印地址 cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 static int s_a = 10; static int s_b = 10; cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 打印结果： 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后 栈区： ​ 由编译器自动分配释放, 存放函数的参数值,局部变量等 ​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： 1234567891011121314151617int * func()&#123; int a = 10; return &amp;a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 堆区： ​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 ​ 在C++中主要利用new在堆区开辟内存 示例： 1234567891011121314151617int* func()&#123; int* a = new int(10); return a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符 ​ C++中利用==new==操作符在堆区开辟数据 ​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete== ​ 语法：new 数据类型 ​ 利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 12345678910111213141516171819202122int* func()&#123; int* a = new int(10); return a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; //利用delete释放堆区数据 delete p; //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问 system(&quot;pause&quot;); return 0;&#125; 示例2：开辟数组 12345678910111213141516171819202122//堆区开辟数组int main() &#123; int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i + 100; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; //释放数组 delete 后加 [] delete[] arr; system(&quot;pause&quot;); return 0;&#125; 2 引用 2.1 引用的基本使用 作用： 给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： 1234567891011121314151617int main() &#123; int a = 10; int &amp;b = a; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： 12345678910111213141516int main() &#123; int a = 10; int b = 20; //int &amp;c; //错误，引用必须初始化 int &amp;c = a; //一旦初始化后，就不可以更改 c = b; //这是赋值操作，不是更改引用 cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.3 引用做函数参数 作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//1. 值传递void mySwap01(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;//2. 地址传递void mySwap02(int* a, int* b) &#123; int temp = *a; *a = *b; *b = temp;&#125;//3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp;&#125;int main() &#123; int a = 10; int b = 20; mySwap01(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap02(&amp;a, &amp;b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; mySwap03(a, b); cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值 作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： 123456789101112131415161718192021222324252627282930313233//返回局部变量引用int&amp; test01() &#123; int a = 10; //局部变量 return a;&#125;//返回静态变量引用int&amp; test02() &#123; static int a = 20; return a;&#125;int main() &#123; //不能返回局部变量的引用 int&amp; ref = test01(); cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; //如果函数做左值，那么必须返回引用 int&amp; ref2 = test02(); cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; test02() = 1000; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; &quot;ref2 = &quot; &lt;&lt; ref2 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 2.5 引用的本质 本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： 1234567891011121314151617//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123; ref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123; int a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl; func(a); return 0;&#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用 作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加==const修饰形参==，防止形参改变实参 示例： 1234567891011121314151617181920212223//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123; //v += 10; cout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123; //int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp; const int&amp; ref = 10; //ref = 100; //加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); system(&quot;pause&quot;); return 0;&#125; 3 函数提高 3.1 函数默认参数 在C++中，函数的形参列表中的形参是可以有默认值的。 语法：返回值类型 函数名 （参数= 默认值）&#123;&#125; 示例： 1234567891011121314151617181920int func(int a, int b = 10, int c = 10) &#123; return a + b + c;&#125;//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) &#123; return a + b;&#125;int main() &#123; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(20, 20) &lt;&lt; endl; cout &lt;&lt; &quot;ret = &quot; &lt;&lt; func(100) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 3.2 函数占位参数 C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型)&#123;&#125; 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 示例： 12345678910111213//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) &#123; cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;&#125;int main() &#123; func(10,10); //占位参数必须填补 system(&quot;pause&quot;); return 0;&#125; 3.3 函数重载 3.3.1 函数重载概述 作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041//函数重载需要函数都在同一个作用域下void func()&#123; cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a)&#123; cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;&#125;void func(int a ,double b)&#123; cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;&#125;void func(double a ,int b)&#123; cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;&#125;//函数返回值不可以作为函数重载条件//int func(double a, int b)//&#123;// cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;//&#125;int main() &#123; func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(&quot;pause&quot;); return 0;&#125; 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例： 123456789101112131415161718192021222324252627282930313233343536373839//函数重载注意事项//1、引用作为重载条件void func(int &amp;a)&#123; cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;void func(const int &amp;a)&#123; cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;&#125;//2、函数重载碰到函数默认参数void func2(int a, int b = 10)&#123; cout &lt;&lt; &quot;func2(int a, int b = 10) 调用&quot; &lt;&lt; endl;&#125;void func2(int a)&#123; cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;&#125;int main() &#123; int a = 10; func(a); //调用无const func(10);//调用有const //func2(10); //碰到默认参数产生歧义，需要避免 system(&quot;pause&quot;); return 0;&#125; 4 类和对象 C++面向对象的三大特性为：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 例如： ​ 人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌... ​ 车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调... ​ 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类 4.1 封装 4.1.1 封装的意义 封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： ​ 在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名&#123; 访问权限： 属性 / 行为 &#125;; 示例1：设计一个圆类，求圆的周长 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839//圆周率const double PI = 3.14;//1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物//封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle&#123;public: //访问权限 公共的权限 //属性 int m_r;//半径 //行为 //获取到圆的周长 double calculateZC() &#123; //2 * pi * r //获取圆的周长 return 2 * PI * m_r; &#125;&#125;;int main() &#123; //通过圆类，创建圆的对象 // c1就是一个具体的圆 Circle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作 //2 * pi * 10 = = 62.8 cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号 示例2代码： 123456789101112131415161718192021222324252627282930//学生类class Student &#123;public: void setName(string name) &#123; m_name = name; &#125; void setID(int id) &#123; m_id = id; &#125; void showStudent() &#123; cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl; &#125;public: string m_name; int m_id;&#125;;int main() &#123; Student stu; stu.setName(&quot;德玛西亚&quot;); stu.setID(250); stu.showStudent(); system(&quot;pause&quot;); return 0;&#125; 封装意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 示例： 123456789101112131415161718192021222324252627282930313233343536373839//三种权限//公共权限 public 类内可以访问 类外可以访问//保护权限 protected 类内可以访问 类外不可以访问//私有权限 private 类内可以访问 类外不可以访问class Person&#123; //姓名 公共权限public: string m_Name; //汽车 保护权限protected: string m_Car; //银行卡密码 私有权限private: int m_Password;public: void func() &#123; m_Name = &quot;张三&quot;; m_Car = &quot;拖拉机&quot;; m_Password = 123456; &#125;&#125;;int main() &#123; Person p; p.m_Name = &quot;李四&quot;; //p.m_Car = &quot;奔驰&quot;; //保护权限类外访问不到 //p.m_Password = 123; //私有权限类外访问不到 system(&quot;pause&quot;); return 0;&#125; 4.1.2 struct和class区别 在C++中 struct和class唯一的区别就在于 默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 12345678910111213141516171819202122class C1&#123; int m_A; //默认是私有权限&#125;;struct C2&#123; int m_A; //默认是公共权限&#125;;int main() &#123; C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 system(&quot;pause&quot;); return 0;&#125; 4.1.3 成员属性设置为私有 优点1：将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Person &#123;public: //姓名设置可读可写 void setName(string name) &#123; m_Name = name; &#125; string getName() &#123; return m_Name; &#125; //获取年龄 int getAge() &#123; return m_Age; &#125; //设置年龄 void setAge(int age) &#123; if (age &lt; 0 || age &gt; 150) &#123; cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl; return; &#125; m_Age = age; &#125; //情人设置为只写 void setLover(string lover) &#123; m_Lover = lover; &#125;private: string m_Name; //可读可写 姓名 int m_Age; //只读 年龄 string m_Lover; //只写 情人&#125;;int main() &#123; Person p; //姓名设置 p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl; //年龄设置 p.setAge(50); cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl; //情人设置 p.setLover(&quot;苍井&quot;); //cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl; //只写属性，不可以读取 system(&quot;pause&quot;); return 0;&#125; 练习案例1：设计立方体类 设计立方体类(Cube) 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。 练习案例2：点和圆的关系 设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。 4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数 对象的初始化和清理也是两个非常重要的安全问题 一个对象或者变量没有初始状态，对其使用后果是未知 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名()&#123;&#125; 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名()&#123;&#125; 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 1234567891011121314151617181920212223242526272829class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; Person p;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.2 构造函数的分类及调用 两种分类方式： ​ 按参数分为： 有参构造和无参构造 ​ 按类型分为： 普通构造和拷贝构造 三种调用方式： ​ 括号法 ​ 显示法 ​ 隐式转换法 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//1、构造函数分类// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int age;&#125;;//2、构造函数的调用//调用无参构造函数void test01() &#123; Person p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123; //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4);&#125;int main() &#123; test01(); //test02(); system(&quot;pause&quot;); return 0;&#125; 4.2.3 拷贝构造函数调用时机 C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Person &#123;public: Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; mAge = 0; &#125; Person(int age) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; mAge = age; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; mAge = p.mAge; &#125; //析构函数在释放内存之前调用 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int mAge;&#125;;//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123; Person man(100); //p对象已经创建完毕 Person newman(man); //调用拷贝构造函数 Person newman2 = man; //拷贝构造 //Person newman3; //newman3 = man; //不是调用拷贝构造函数，赋值操作&#125;//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) &#123;&#125;void test02() &#123; Person p; //无参构造函数 doWork(p);&#125;//3. 以值方式返回局部对象Person doWork2()&#123; Person p1; cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1;&#125;void test03()&#123; Person p = doWork2(); cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123; //test01(); //test02(); test03(); system(&quot;pause&quot;); return 0;&#125; 4.2.4 构造函数调用规则 默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; &#125;public: int age;&#125;;void test01()&#123; Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123; //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; //此时如果用户自己没有提供默认构造，会出错 Person p2(10); //用户提供的有参 Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 //如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; //此时如果用户自己没有提供默认构造，会出错 Person p5(10); //此时如果用户自己没有提供有参，会出错 Person p6(p5); //用户自己提供拷贝构造&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.5 深拷贝与浅拷贝 深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl; &#125; //有参构造函数 Person(int age ,int height) &#123; cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl; m_age = age; m_height = new int(height); &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); &#125; //析构函数 ~Person() &#123; cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl; if (m_height != NULL) &#123; delete m_height; &#125; &#125;public: int m_age; int* m_height;&#125;;void test01()&#123; Person p1(18, 180); Person p2(p1); cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 4.2.6 初始化列表 作用： C++提供了初始化列表语法，用来初始化属性 语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125; 示例： 123456789101112131415161718192021222324252627282930313233class Person &#123;public: ////传统方式初始化 //Person(int a, int b, int c) &#123; // m_A = a; // m_B = b; // m_C = c; //&#125; //初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125; void PrintPerson() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl; &#125;private: int m_A; int m_B; int m_C;&#125;;int main() &#123; Person p(1, 2, 3); p.PrintPerson(); system(&quot;pause&quot;); return 0;&#125; 4.2.7 类对象作为类成员 C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： 12345class A &#123;&#125;class B&#123; A a；&#125; B类中有对象A作为成员，A为对象成员 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Phone&#123;public: Phone(string name) &#123; m_PhoneName = name; cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl; &#125; ~Phone() &#123; cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl; &#125; string m_PhoneName;&#125;;class Person&#123;public: //初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123; cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl; &#125; void playGame() &#123; cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl; &#125; string m_Name; Phone m_Phone;&#125;;void test01()&#123; //当类中成员是其他类对象时，我们称该成员为 对象成员 //构造的顺序是 ：先调用对象成员的构造，再调用本类构造 //析构顺序与构造相反 Person p(&quot;张三&quot; , &quot;苹果X&quot;); p.playGame();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.2.8 静态成员 静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 示例1 ：静态成员变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person&#123; public: static int m_A; //静态成员变量 //静态成员变量特点： //1 在编译阶段分配内存 //2 类内声明，类外初始化 //3 所有对象共享同一份数据private: static int m_B; //静态成员变量也是有访问权限的&#125;;int Person::m_A = 10;int Person::m_B = 10;void test01()&#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.m_A = 100; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; Person p2; p2.m_A = 200; cout &lt;&lt; &quot;p1.m_A = &quot; &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据 cout &lt;&lt; &quot;p2.m_A = &quot; &lt;&lt; p2.m_A &lt;&lt; endl; //2、通过类名 cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; Person::m_A &lt;&lt; endl; //cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 示例2：静态成员函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person&#123;public: //静态成员函数特点： //1 程序共享一个函数 //2 静态成员函数只能访问静态成员变量 static void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 &#125; static int m_A; //静态成员变量 int m_B; // private: //静态成员函数也是有访问权限的 static void func2() &#123; cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl; &#125;&#125;;int Person::m_A = 10;void test01()&#123; //静态成员函数两种访问方式 //1、通过对象 Person p1; p1.func(); //2、通过类名 Person::func(); //Person::func2(); //私有权限访问不到&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.3 C++对象模型和this指针 4.3.1 成员变量和成员函数分开存储 在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 1234567891011121314151617181920212223242526class Person &#123;public: Person() &#123; mA = 0; &#125; //非静态成员变量占对象空间 int mA; //静态成员变量不占对象空间 static int mB; //函数也不占对象空间，所有函数共享一个函数实例 void func() &#123; cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl; &#125; //静态成员函数也不占对象空间 static void sfunc() &#123; &#125;&#125;;int main() &#123; cout &lt;&lt; sizeof(Person) &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 4.3.2 this指针概念 通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1234567891011121314151617181920212223242526272829303132333435363738class Person&#123;public: Person(int age) &#123; //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age; &#125; Person&amp; PersonAddPerson(Person p) &#123; this-&gt;age += p.age; //返回对象本身 return *this; &#125; int age;&#125;;void test01()&#123; Person p1(10); cout &lt;&lt; &quot;p1.age = &quot; &lt;&lt; p1.age &lt;&lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout &lt;&lt; &quot;p2.age = &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.3.3 空指针访问成员函数 C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： 12345678910111213141516171819202122232425262728293031323334//空指针访问成员函数class Person &#123;public: void ShowClassName() &#123; cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl; &#125; void ShowPerson() &#123; if (this == NULL) &#123; return; &#125; cout &lt;&lt; mAge &lt;&lt; endl; &#125;public: int mAge;&#125;;void test01()&#123; Person * p = NULL; p-&gt;ShowClassName(); //空指针，可以调用成员函数 p-&gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.3.4 const修饰成员函数 常函数： 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Person &#123;public: Person() &#123; m_A = 0; m_B = 0; &#125; //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const &#123; //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100; &#125; void MyFunc() const &#123; //mA = 10000; &#125;public: int m_A; mutable int m_B; //可修改 可变的&#125;;//const修饰对象 常对象void test01() &#123; const Person person; //常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 person.m_B = 100; //但是常对象可以修改mutable修饰成员变量 //常对象访问常成员函数 person.MyFunc(); //常对象不能调用普通的成员函数&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.4 友元 生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 friend 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元 123456789101112131415161718192021222324252627282930313233343536373839404142class Building&#123; //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building);public: Building() &#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;; &#125;public: string m_SittingRoom; //客厅private: string m_BedRoom; //卧室&#125;;void goodGay(Building * building)&#123; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; Building b; goodGay(&amp;b);&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.4.2 类做友元 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Building;class goodGay&#123;public: goodGay(); void visit();private: Building *building;&#125;;class Building&#123; //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay;public: Building();public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123; building = new Building;&#125;void goodGay::visit()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; goodGay gg; gg.visit();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.4.3 成员函数做友元 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Building;class goodGay&#123;public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以访问Building中私有内容 void visit2(); private: Building *building;&#125;;class Building&#123; //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit();public: Building();public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay()&#123; building = new Building;&#125;void goodGay::visit()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; goodGay gg; gg.visit();&#125;int main()&#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.5 运算符重载 运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 4.5.1 加号运算符重载 作用：实现两个自定义数据类型相加的运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Person &#123;public: Person() &#123;&#125;; Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; &#125;public: int m_A; int m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;// Person temp(0, 0);// temp.m_A = p1.m_A + p2.m_A;// temp.m_B = p1.m_B + p2.m_B;// return temp;//&#125;//运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) &#123; Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp;&#125;void test() &#123; Person p1(10, 10); Person p2(20, 20); //成员函数方式 Person p3 = p2 + p1; //相当于 p2.operaor+(p1) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123; test(); system(&quot;pause&quot;); return 0;&#125; 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载 4.5.2 左移运算符重载 作用：可以输出自定义数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142class Person &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public: Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p)&#123; //&#125;private: int m_A; int m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B; return out;&#125;void test() &#123; Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123; test(); system(&quot;pause&quot;); return 0;&#125; 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符重载 作用： 通过重载递增运算符，实现自己的整型数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyInteger &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public: MyInteger() &#123; m_Num = 0; &#125; //前置++ MyInteger&amp; operator++() &#123; //先++ m_Num++; //再返回 return *this; &#125; //后置++ MyInteger operator++(int) &#123; //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp; &#125;private: int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123; out &lt;&lt; myint.m_Num; return out;&#125;//前置++ 先++ 再返回void test01() &#123; MyInteger myInt; cout &lt;&lt; ++myInt &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;&#125;//后置++ 先返回 再++void test02() &#123; MyInteger myInt; cout &lt;&lt; myInt++ &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123; test01(); //test02(); system(&quot;pause&quot;); return 0;&#125; 总结： 前置递增返回引用，后置递增返回值 4.5.4 赋值运算符重载 c++编译器至少给一个类添加4个函数 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator=, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person&#123;public: Person(int age) &#123; //将年龄数据开辟到堆区 m_Age = new int(age); &#125; //重载赋值运算符 Person&amp; operator=(Person &amp;p) &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this; &#125; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; //年龄的指针 int *m_Age;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作 cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); //int a = 10; //int b = 20; //int c = 30; //c = b = a; //cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 4.5.5 关系运算符重载 作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;; bool operator==(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; bool operator!=(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; else &#123; return true; &#125; &#125; string m_Name; int m_Age;&#125;;void test01()&#123; //int a = 0; //int b = 0; Person a(&quot;孙悟空&quot;, 18); Person b(&quot;孙悟空&quot;, 18); if (a == b) &#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; if (a != b) &#123; cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyPrint&#123;public: void operator()(string text) &#123; cout &lt;&lt; text &lt;&lt; endl; &#125;&#125;;void test01()&#123; //重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(&quot;hello world&quot;);&#125;class MyAdd&#123;public: int operator()(int v1, int v2) &#123; return v1 + v2; &#125;&#125;;void test02()&#123; MyAdd add; int ret = add(10, 10); cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl; //匿名对象调用 cout &lt;&lt; &quot;MyAdd()(100,100) = &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 4.6 继承 继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中： 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 4.6.1 继承的基本语法 例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Java页面class Java &#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//C++页面class CPP &#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 继承实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//公共页面class BasePage&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl; &#125;&#125;;//Java页面class Java : public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python : public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//C++页面class CPP : public BasePage&#123;public: void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Java页面 cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //Python页面 cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl; //C++页面 cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 继承的好处：==可以减少重复的代码== class A : public B; A 类称为子类 或 派生类 B 类称为父类 或 基类 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 4.6.2 继承方式 继承的语法：class 子类 : 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Base1&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;//公共继承class Son1 :public Base1&#123;public: void func() &#123; m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问 &#125;&#125;;void myClass()&#123; Son1 s1; s1.m_A; //其他类只能访问到公共权限&#125;//保护继承class Base2&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son2:protected Base2&#123;public: void func() &#123; m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问 &#125;&#125;;void myClass2()&#123; Son2 s; //s.m_A; //不可访问&#125;//私有继承class Base3&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son3:private Base3&#123;public: void func() &#123; m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问 &#125;&#125;;class GrandSon3 :public Son3&#123;public: void func() &#123; //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C; &#125;&#125;; 4.6.3 继承中的对象模型 问题：从父类继承过来的成员，哪些属于子类对象中？ 示例： 123456789101112131415161718192021222324252627282930class Base&#123;public: int m_A;protected: int m_B;private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去&#125;;//公共继承class Son :public Base&#123;public: int m_D;&#125;;void test01()&#123; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 利用工具查看： 打开工具窗口后，定位到当前CPP文件的盘符 然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名 效果如下图： 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 4.6.4 继承中构造和析构顺序 子类继承父类后，当创建子类对象，也会调用父类的构造函数 问题：父类和子类的构造和析构顺序是谁先谁后？ 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142class Base &#123;public: Base() &#123; cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl; &#125;&#125;;class Son : public Base&#123;public: Son() &#123; cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 4.6.5 继承同名成员处理方式 问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Base &#123;public: Base() &#123; m_A = 100; &#125; void func() &#123; cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl; &#125;public: int m_A;&#125;;class Son : public Base &#123;public: Son() &#123; m_A = 200; &#125; //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() &#123; cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl; &#125;public: int m_A;&#125;;void test01()&#123; Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; s.func(); s.Base::func(); s.Base::func(10);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return EXIT_SUCCESS;&#125; 总结： 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式 问题：继承中同名的静态成员在子类对象上如何进行访问？ 静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Base &#123;public: static void func() &#123; cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl; &#125; static void func(int a) &#123; cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl; &#125; static int m_A;&#125;;int Base::m_A = 100;class Son : public Base &#123;public: static void func() &#123; cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl; &#125; static int m_A;&#125;;int Son::m_A = 200;//同名成员属性void test01()&#123; //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; //通过类名访问 cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son 下 m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base 下 m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;//同名成员函数void test02()&#123; //通过对象访问 cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100);&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名） 4.6.7 多继承语法 C++允许一个类继承多个类 语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议用多继承 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Base1 &#123;public: Base1() &#123; m_A = 100; &#125;public: int m_A;&#125;;class Base2 &#123;public: Base2() &#123; m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 &#125;public: int m_A;&#125;;//语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123;public: Son() &#123; m_C = 300; m_D = 400; &#125;public: int m_C; int m_D;&#125;;//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123; Son s; cout &lt;&lt; &quot;sizeof Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域 4.6.8 菱形继承 菱形继承概念： ​ 两个派生类继承同一个基类 ​ 又有某个类同时继承者两个派生类 ​ 这种继承被称为菱形继承，或者钻石继承 典型的菱形继承案例： 菱形继承问题： 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 示例： 1234567891011121314151617181920212223242526272829303132class Animal&#123;public: int m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.m_Age = &quot; &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态 4.7.1 多态的基本概念 多态是C++面向对象三大特性之一 多态分为两类 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Animal&#123;public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125;&#125;;class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; &#125;&#125;;//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123; animal.speak();&#125;////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01()&#123; Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 4.7.2 多态案例一-计算器类 案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//普通实现class Calculator &#123;public: int getResult(string oper) &#123; if (oper == &quot;+&quot;) &#123; return m_Num1 + m_Num2; &#125; else if (oper == &quot;-&quot;) &#123; return m_Num1 - m_Num2; &#125; else if (oper == &quot;*&quot;) &#123; return m_Num1 * m_Num2; &#125; //如果要提供新的运算，需要修改源码 &#125;public: int m_Num1; int m_Num2;&#125;;void test01()&#123; //普通实现测试 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public : virtual int getResult() &#123; return 0; &#125; int m_Num1; int m_Num2;&#125;;//加法计算器class AddCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//减法计算器class SubCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 - m_Num2; &#125;&#125;;//乘法计算器class MulCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 * m_Num2; &#125;&#125;;void test02()&#123; //创建加法计算器 AbstractCalculator *abc = new AddCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //用完了记得销毁 //创建减法计算器 abc = new SubCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //创建乘法计算器 abc = new MulCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc;&#125;int main() &#123; //test01(); test02(); system(&quot;pause&quot;); return 0;&#125; 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多 4.7.3 纯虚函数和抽象类 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为==抽象类== 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123;public: virtual void func() &#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl; &#125;;&#125;;void test01()&#123; Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 base = new Son; base-&gt;func(); delete base;//记得销毁&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.7.4 多态案例二-制作饮品 案例描述： 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//抽象制作饮品class AbstractDrinking &#123;public: //烧水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //规定流程 void MakeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125;&#125;;//制作咖啡class Coffee : public AbstractDrinking &#123;public: //烧水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl; &#125;&#125;;//制作茶水class Tea : public AbstractDrinking &#123;public: //烧水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl; &#125;&#125;;//业务函数void DoWork(AbstractDrinking* drink) &#123; drink-&gt;MakeDrink(); delete drink;&#125;void test01() &#123; DoWork(new Coffee); cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl; DoWork(new Tea);&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 4.7.5 虚析构和纯虚析构 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名() = 0; 类名::~类名()&#123;&#125; 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Animal &#123;public: Animal() &#123; cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl; &#125; virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //&#123; // cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl; //&#125; virtual ~Animal() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void Speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话!&quot; &lt;&lt; endl; &#125; ~Cat() &#123; cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl; if (this-&gt;m_Name != NULL) &#123; delete m_Name; m_Name = NULL; &#125; &#125;public: string *m_Name;&#125;;void test01()&#123; Animal *animal = new Cat(&quot;Tom&quot;); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： ​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 ​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 ​ 3. 拥有纯虚析构函数的类也属于抽象类 4.7.6 多态案例三-电脑组装 案例描述： 电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public: //抽象的计算函数 virtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public: //抽象的显示函数 virtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public: //抽象的存储函数 virtual void storage() = 0;&#125;;//电脑类class Computer&#123;public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //提供工作的函数 void work() &#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //提供析构函数 释放3个电脑零件 ~Computer() &#123; //释放CPU零件 if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; //释放显卡零件 if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; //释放内存条零件 if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125;private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class LenovoMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3;&#125; 5 文件操作 程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 ==&lt; fstream &gt;== 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件 5.1.1写文件 写文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ofstream ofs; 打开文件 ofs.open(\"文件路径\",打开方式); 写数据 ofs &lt;&lt; \"写入的数据\"; 关闭文件 ofs.close(); 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios:: out 示例： 12345678910111213141516171819202122#include &lt;fstream&gt;void test01()&#123; ofstream ofs; ofs.open(&quot;test.txt&quot;, ios::out); ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; ofs.close();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件 读文件与写文件步骤相似，但是读取方式相对于比较多 读文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ifstream ifs; 打开文件并判断文件是否打开成功 ifs.open(\"文件路径\",打开方式); 读数据 四种方式读取 关闭文件 ifs.close(); 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123; ifstream ifs; ifs.open(&quot;test.txt&quot;, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; //第一种方式 //char buf[1024] = &#123; 0 &#125;; //while (ifs &gt;&gt; buf) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第二种 //char buf[1024] = &#123; 0 &#125;; //while (ifs.getline(buf,sizeof(buf))) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第三种 //string buf; //while (getline(ifs, buf)) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c; &#125; ifs.close();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件 以二进制的方式对文件进行读写操作 打开方式要指定为 ==ios::binary== 5.2.1 写文件 二进制方式写文件主要利用流对象调用成员函数write 函数原型 ：ostream&amp; write(const char * buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public: char m_Name[64]; int m_Age;&#125;;//二进制文件 写文件void test01()&#123; //1、包含头文件 //2、创建输出流对象 ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary); //3、打开文件 //ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); Person p = &#123;&quot;张三&quot; , 18&#125;; //4、写文件 ofs.write((const char *)&amp;p, sizeof(p)); //5、关闭文件 ofs.close();&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 总结： 文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件 二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char *buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public: char m_Name[64]; int m_Age;&#125;;void test01()&#123; ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; &#125; Person p; ifs.read((char *)&amp;p, sizeof(p)); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); system(&quot;pause&quot;); return 0;&#125; 文件输入流对象 可以通过read函数，以二进制方式读数据","tags":[],"categories":[{"name":"cs","slug":"cs","permalink":"https://silencht.github.io/categories/cs/"},{"name":"c&c++","slug":"cs/c-c","permalink":"https://silencht.github.io/categories/cs/c-c/"}]}]}