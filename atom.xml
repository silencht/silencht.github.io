<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>silencht&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://silencht.github.io/"/>
  <updated>2024-01-05T08:54:55.971Z</updated>
  <id>https://silencht.github.io/</id>
  
  <author>
    <name>silencht</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kalibr_note</title>
    <link href="https://silencht.github.io/wiki/robot/note/kalibr_note/"/>
    <id>https://silencht.github.io/wiki/robot/note/kalibr_note/</id>
    <published>2024-01-05T08:49:39.016Z</published>
    <updated>2024-01-05T08:54:55.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="d435i双目imu联合标定">d435i双目+IMU联合标定</h2><h3 id="build-kalibr-from-source-code">1. build Kalibr from sourcecode</h3><ol type="1"><li>install ROS1 on system, for example</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="built_in">export</span> ROS1_DISTRO=noetic <span class="comment"># melodic=18.04, noetic=20.04</span></span><br><span class="line">sudo apt-get install ros-<span class="variable">$ROS1_DISTRO</span>-desktop-full</span><br><span class="line">sudo apt-get install python-catkin-tools <span class="comment"># ubuntu 18.04</span></span><br><span class="line">sudo apt-get install python3-catkin-tools python3-osrf-pycommon <span class="comment"># ubuntu 20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#酌情根据需要安装依赖项（optional）</span></span><br><span class="line">sudo apt-get install -y \</span><br><span class="line">    git wget autoconf automake nano \</span><br><span class="line">    libeigen3-dev libboost-all-dev libsuitesparse-dev \</span><br><span class="line">    doxygen libopencv-dev \</span><br><span class="line">    libpoco-dev libtbb-dev libblas-dev liblapack-dev libv4l-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#Then due to different Python versions, you will need to install the following:</span></span><br><span class="line"><span class="comment"># Ubuntu 18.04</span></span><br><span class="line">sudo apt-get install -y python3-dev python-pip python-scipy \</span><br><span class="line">    python-matplotlib ipython python-wxgtk4.0 python-tk python-igraph python-pyx</span><br><span class="line"><span class="comment"># Ubuntu 20.04</span></span><br><span class="line">sudo apt-get install -y python3-dev python3-pip python3-scipy \</span><br><span class="line">    python3-matplotlib ipython3 python3-wxgtk4.0 python3-tk python3-igraph python3-pyx</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>create a catkin workspace and clone the kalibr project</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/kalibr/src</span><br><span class="line"><span class="built_in">cd</span> ~/kalibr</span><br><span class="line"><span class="built_in">export</span> ROS1_DISTRO=noetic <span class="comment"># kinetic=16.04, melodic=18.04, noetic=20.04</span></span><br><span class="line"><span class="built_in">source</span> /opt/ros/<span class="variable">$ROS1_DISTRO</span>/setup.bash</span><br><span class="line">catkin init</span><br><span class="line">catkin config --extend /opt/ros/<span class="variable">$ROS1_DISTRO</span></span><br><span class="line">catkin config --merge-devel <span class="comment"># Necessary for catkin_tools &gt;= 0.4.</span></span><br><span class="line">catkin config --cmake-args -DCMAKE_BUILD_TYPE=Release</span><br><span class="line"><span class="comment">#then clone the project</span></span><br><span class="line"><span class="built_in">cd</span> ~/kalibr/src</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ethz-asl/kalibr.git</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>build</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/kalibr</span><br><span class="line"><span class="comment">#根据需要修改j数值</span></span><br><span class="line">catkin build -DCMAKE_BUILD_TYPE=Release -j14</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>source the catkin workspace setup to useKalibr，至此<strong>Kalibr</strong>安装完成</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/kalibr/devel/setup.bash</span><br><span class="line">rosrun kalibr &lt;command_you_want_to_run_here&gt;</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>安装<strong>code_utils</strong> &amp; <strong>imu_utils</strong>工具用于后面标定IMU</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先安装ceres</span></span><br><span class="line"><span class="comment"># google-glog + gflags</span></span><br><span class="line">sudo apt-get install libgoogle-glog-dev libgflags-dev</span><br><span class="line"><span class="comment"># now ready to build, test, and install Ceres.</span></span><br><span class="line"><span class="comment"># download ceres-solver-2.2.0 from https://github.com/ceres-solver/ceres-solver/archive/refs/tags/2.2.0.tar.gz</span></span><br><span class="line">tar zxf ceres-solver-2.2.0.tar.gz</span><br><span class="line"><span class="built_in">mkdir</span> ceres-bin</span><br><span class="line"><span class="built_in">cd</span> ceres-bin</span><br><span class="line">cmake ../ceres-solver-2.2.0</span><br><span class="line">make -j14</span><br><span class="line">make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># Optionally install Ceres, it can also be exported using CMake which</span></span><br><span class="line"><span class="comment"># allows Ceres to be used without requiring installation, see the documentation</span></span><br><span class="line"><span class="comment"># for the EXPORT_BUILD_DIR option for more information.</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装code utils</span></span><br><span class="line">sudo apt install libdw-dev</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/imu_calib/src</span><br><span class="line"><span class="built_in">cd</span> ~/imu_calib/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/silencht/code_utils.git</span><br><span class="line"><span class="comment">#仓库文件已经将sumpixel_test.cpp中#include &quot;backward.hpp&quot;改为：#include &quot;code_utils/backward.hpp&quot;</span></span><br><span class="line"><span class="comment">#如果下方步骤编译出错，可酌情再次修改为#include &quot;backward.hpp&quot;</span></span><br><span class="line">catkin_make -j14</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装imu utils</span></span><br><span class="line"><span class="built_in">cd</span> ~/imu_calib/src/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/silencht/imu_utils.git</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make -j14</span><br></pre></td></tr></table></figure><ol start="6" type="1"><li>为d435i相机安装realsense ros1驱动包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://github.com/IntelRealSense/realsense-ros/tree/ros1-legacy</span></span><br><span class="line"><span class="comment">#create a catkin workspace for realsense ros</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/d435i_ros/src</span><br><span class="line"><span class="built_in">cd</span> ~/d435i_ros/src</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/silencht/realsense-ros.git</span><br><span class="line"><span class="built_in">cd</span> realsense-ros/</span><br><span class="line">git checkout `git tag | <span class="built_in">sort</span> -V | grep -P <span class="string">&quot;^2.\d+\.\d+&quot;</span> | <span class="built_in">tail</span> -1`</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_init_workspace</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make clean</span><br><span class="line">catkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Release</span><br><span class="line">catkin_make install</span><br><span class="line"><span class="comment">#运行和测试查看</span></span><br><span class="line">roslaunch realsense2_camera rs_camera.launch</span><br><span class="line">rviz</span><br></pre></td></tr></table></figure><h3 id="imu标定">2. IMU标定</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rs_camera_for_calib.launch主要相对于rs_camera.launch修改了</span></span><br><span class="line"><span class="comment">#  &lt;arg name=&quot;infra_width&quot;         default=&quot;640&quot;/&gt;       此行作用：将红外图像分辨率由848*480变为640*480</span></span><br><span class="line"><span class="comment">#  &lt;arg name=&quot;gyro_fps&quot;            default=&quot;400&quot;/&gt;</span></span><br><span class="line"><span class="comment">#  &lt;arg name=&quot;accel_fps&quot;           default=&quot;250&quot;/&gt;</span></span><br><span class="line"><span class="comment">#  &lt;arg name=&quot;enable_gyro&quot;         default=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="comment">#  &lt;arg name=&quot;enable_accel&quot;        default=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="comment">#  &lt;arg name=&quot;unite_imu_method&quot;    default=&quot;linear_interpolation&quot;/&gt;</span></span><br><span class="line"><span class="comment">#启动相机驱动程序，开始发布数据</span></span><br><span class="line">roslaunch realsense2_camera rs_camera_for_calib.launch</span><br><span class="line"><span class="comment">#此时相机开始输出数据，其中有imu数据，可使用如下命令查看数据是否正常发布</span></span><br><span class="line">changhe@changhe:~/d435i_ros$ rostopic list -v | grep imu</span><br><span class="line"> * /camera/imu [sensor_msgs/Imu] 1 publisher</span><br><span class="line"> * /camera/gyro/imu_info [realsense2_camera/IMUInfo] 1 publisher</span><br><span class="line"> * /camera/accel/imu_info [realsense2_camera/IMUInfo] 1 publisher</span><br><span class="line">changhe@changhe:~/d435i_ros$ rostopic <span class="built_in">echo</span> /camera/imu</span><br><span class="line">header: </span><br><span class="line">  <span class="built_in">seq</span>: 10135</span><br><span class="line">  stamp: </span><br><span class="line">    secs: 1704355811</span><br><span class="line">    nsecs: 680399179</span><br><span class="line">  frame_id: <span class="string">&quot;camera_imu_optical_frame&quot;</span></span><br><span class="line">orientation: </span><br><span class="line">  x: 0.0</span><br><span class="line">  y: 0.0</span><br><span class="line">  z: 0.0</span><br><span class="line">  w: 0.0</span><br><span class="line">orientation_covariance: [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</span><br><span class="line">angular_velocity: </span><br><span class="line">  x: -0.001745329238474369</span><br><span class="line">  y: 0.001745329238474369</span><br><span class="line">  z: 0.0</span><br><span class="line">angular_velocity_covariance: [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]</span><br><span class="line">linear_acceleration: </span><br><span class="line">  x: -0.00493930911018656</span><br><span class="line">  y: -9.846020630401458</span><br><span class="line">  z: 0.019613299518823624</span><br><span class="line">linear_acceleration_covariance: [0.01, 0.0, 0.0, 0.0, 0.01, 0.0, 0.0, 0.0, 0.01]</span><br><span class="line"></span><br><span class="line"><span class="comment">#静置相机，录制2小时以上的ROS bag，2小时以后使用ctrl+c终止命令，imu_calib目录下产生imu_calibration.bag文件</span></span><br><span class="line"><span class="comment">#或者也可以跳过该步骤，直接使用静置相机的话题发布数据，不记录ROS bag</span></span><br><span class="line"><span class="built_in">cd</span> ~/imu_calib</span><br><span class="line">rosbag record -O imu_calibration /camera/imu</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行IMU校准程序，如果认为2小时太长，可以在d435i_imu_calibration.launch中max_time_min设置value调整计时分钟</span></span><br><span class="line"><span class="built_in">source</span> ~/imu_calib/devel/setup.bash</span><br><span class="line">roslaunch imu_utils d435i_imu_calibration.launch</span><br><span class="line"><span class="comment">#执行上述命令后，输出以下信息，便可等待程序执行完成（2小时以后）</span></span><br><span class="line">[ INFO] [1704356481.837577493]: Loaded imu_topic: /camera/imu</span><br><span class="line">[ INFO] [1704356481.838011572]: Loaded imu_name: d435i</span><br><span class="line">[ INFO] [1704356481.838159386]: Loaded data_save_path: /home/changhe/imu_calib/src/imu_utils/data/</span><br><span class="line">[ INFO] [1704356481.838308947]: Loaded max_time_min: 120</span><br><span class="line">[ INFO] [1704356481.838460625]: Loaded max_cluster: 400</span><br><span class="line">gyr x  num of Cluster 400</span><br><span class="line">gyr y  num of Cluster 400</span><br><span class="line">gyr z  num of Cluster 400</span><br><span class="line">acc x  num of Cluster 400</span><br><span class="line">acc y  num of Cluster 400</span><br><span class="line">acc z  num of Cluster 400</span><br><span class="line"><span class="built_in">wait</span> <span class="keyword">for</span> imu data.</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开ROS bag数据包进行回放，如果使用相机的直出发布数据则忽略该步骤</span></span><br><span class="line">rosbag play -r 400 imu_calibration.bag</span><br><span class="line"></span><br><span class="line"><span class="comment">#标定结束后，标定结果位于imu_utils/data目录下的d435i_imu_param.yaml文件内,终端输出示例：</span></span><br><span class="line"><span class="built_in">wait</span> <span class="keyword">for</span> imu data.</span><br><span class="line">gyr x  numData 2878675</span><br><span class="line">gyr x  start_t 1.70436e+09</span><br><span class="line">gyr x  end_t 1.70436e+09</span><br><span class="line">gyr x dt </span><br><span class="line">-------------7200.01 s</span><br><span class="line">-------------120 min</span><br><span class="line">-------------2 h</span><br><span class="line">gyr x  freq 399.816</span><br><span class="line">gyr x  period 0.00250115</span><br><span class="line">gyr y  numData 2878675</span><br><span class="line">gyr y  start_t 1.70436e+09</span><br><span class="line">gyr y  end_t 1.70436e+09</span><br><span class="line">gyr y dt </span><br><span class="line">-------------7200.01 s</span><br><span class="line">-------------120 min</span><br><span class="line">-------------2 h</span><br><span class="line">gyr y  freq 399.816</span><br><span class="line">gyr y  period 0.00250115</span><br><span class="line">gyr z  numData 2878675</span><br><span class="line">gyr z  start_t 1.70436e+09</span><br><span class="line">gyr z  end_t 1.70436e+09</span><br><span class="line">gyr z dt </span><br><span class="line">-------------7200.01 s</span><br><span class="line">-------------120 min</span><br><span class="line">-------------2 h</span><br><span class="line">gyr z  freq 399.816</span><br><span class="line">gyr z  period 0.00250115</span><br><span class="line">Gyro X </span><br><span class="line">C    -2.87589     70.9924    -7.40893    0.642781 -0.00746316</span><br><span class="line"> Bias Instability 4.1718e-06 rad/s</span><br><span class="line"> Bias Instability 2.14632e-05 rad/s, at 361.957 s</span><br><span class="line"> White Noise 21.8314 rad/s</span><br><span class="line"> White Noise 0.00606455 rad/s</span><br><span class="line">  bias -0.15276 degree/s</span><br><span class="line">-------------------</span><br><span class="line">Gyro y </span><br><span class="line">C   -2.85711    70.9111   -5.49533   0.648136 -0.0109878</span><br><span class="line"> Bias Instability 1.40587e-05 rad/s</span><br><span class="line"> Bias Instability 1.93153e-05 rad/s, at 609.529 s</span><br><span class="line"> White Noise 22.6084 rad/s</span><br><span class="line"> White Noise 0.0062829 rad/s</span><br><span class="line">  bias 0.0119102 degree/s</span><br><span class="line">-------------------</span><br><span class="line">Gyro z </span><br><span class="line">C   -0.975676     27.4672    -4.80227    0.445228 -0.00711166</span><br><span class="line"> Bias Instability 1.5707e-06 rad/s</span><br><span class="line"> Bias Instability 1.59334e-05 rad/s, at 87.0977 s</span><br><span class="line"> White Noise 7.53363 rad/s</span><br><span class="line"> White Noise 0.00209385 rad/s</span><br><span class="line">  bias -0.0410812 degree/s</span><br><span class="line">-------------------</span><br><span class="line">==============================================</span><br><span class="line">==============================================</span><br><span class="line">acc x  numData 2878675</span><br><span class="line">acc x  start_t 1.70436e+09</span><br><span class="line">acc x  end_t 1.70436e+09</span><br><span class="line">acc x dt </span><br><span class="line">-------------7200.01 s</span><br><span class="line">-------------120 min</span><br><span class="line">-------------2 h</span><br><span class="line">acc x  freq 399.816</span><br><span class="line">acc x  period 0.00250115</span><br><span class="line">acc y  numData 2878675</span><br><span class="line">acc y  start_t 1.70436e+09</span><br><span class="line">acc y  end_t 1.70436e+09</span><br><span class="line">acc y dt </span><br><span class="line">-------------7200.01 s</span><br><span class="line">-------------120 min</span><br><span class="line">-------------2 h</span><br><span class="line">acc y  freq 399.816</span><br><span class="line">acc y  period 0.00250115</span><br><span class="line">acc z  numData 2878675</span><br><span class="line">acc z  start_t 1.70436e+09</span><br><span class="line">acc z  end_t 1.70436e+09</span><br><span class="line">acc z dt </span><br><span class="line">-------------7200.01 s</span><br><span class="line">-------------120 min</span><br><span class="line">-------------2 h</span><br><span class="line">acc z  freq 399.816</span><br><span class="line">acc z  period 0.00250115</span><br><span class="line">acc X </span><br><span class="line">C -4.98469e-06  0.000757756   3.7721e-05  2.22768e-05 -3.97843e-07</span><br><span class="line"> Bias Instability 0.000280485 m/s^2</span><br><span class="line"> White Noise 0.0162395 m/s^2</span><br><span class="line">-------------------</span><br><span class="line">acc y </span><br><span class="line">C -2.49845e-07  0.000834302 -1.96216e-05  1.89497e-05 -3.22867e-07</span><br><span class="line"> Bias Instability 0.000192201 m/s^2</span><br><span class="line"> White Noise 0.0171629 m/s^2</span><br><span class="line">-------------------</span><br><span class="line">acc z </span><br><span class="line">C -2.81212e-06  0.000594583  6.58393e-05  6.43312e-06 -1.03843e-07</span><br><span class="line"> Bias Instability 0.000179308 m/s^2</span><br><span class="line"> White Noise 0.0128838 m/s^2</span><br><span class="line">-------------------</span><br><span class="line">[imu_an-1] process has finished cleanly</span><br><span class="line"><span class="built_in">log</span> file: /home/changhe/.ros/log/965a1072-aad8-11ee-b508-a13a0030ff2c/imu_an-1*.<span class="built_in">log</span></span><br><span class="line">all processes on machine have died, roslaunch will <span class="built_in">exit</span></span><br><span class="line">shutting down processing monitor...</span><br><span class="line">... shutting down processing monitor complete</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#d435i_imu_param.yaml文件内容示例</span></span><br><span class="line">%YAML:1.0</span><br><span class="line">---</span><br><span class="line"><span class="built_in">type</span>: IMU</span><br><span class="line">name: d435i</span><br><span class="line">Gyr:</span><br><span class="line">   unit: <span class="string">&quot; rad/s&quot;</span></span><br><span class="line">   avg-axis:</span><br><span class="line">      gyr_n: 4.8137652096146783e-03</span><br><span class="line">      gyr_w: 1.8903981803128362e-05</span><br><span class="line">   x-axis:</span><br><span class="line">      gyr_n: 6.0645500436790623e-03</span><br><span class="line">      gyr_w: 2.1463185558878976e-05</span><br><span class="line">   y-axis:</span><br><span class="line">      gyr_n: 6.2828973927536100e-03</span><br><span class="line">      gyr_w: 1.9315340333546505e-05</span><br><span class="line">   z-axis:</span><br><span class="line">      gyr_n: 2.0938481924113613e-03</span><br><span class="line">      gyr_w: 1.5933419516959604e-05</span><br><span class="line">Acc:</span><br><span class="line">   unit: <span class="string">&quot; m/s^2&quot;</span></span><br><span class="line">   avg-axis:</span><br><span class="line">      acc_n: 1.5428717790802770e-02</span><br><span class="line">      acc_w: 2.1733118964279978e-04</span><br><span class="line">   x-axis:</span><br><span class="line">      acc_n: 1.6239510893649358e-02</span><br><span class="line">      acc_w: 2.8048486828980107e-04</span><br><span class="line">   y-axis:</span><br><span class="line">      acc_n: 1.7162885741267130e-02</span><br><span class="line">      acc_w: 1.9220055801685360e-04</span><br><span class="line">   z-axis:</span><br><span class="line">      acc_n: 1.2883756737491822e-02</span><br><span class="line">      acc_w: 1.7930814262174464e-04</span><br></pre></td></tr></table></figure><h3 id="双目标定">3. 双目标定</h3><ol type="1"><li>生成标定板并用A4纸打印</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/kalibr</span><br><span class="line"><span class="built_in">source</span> devel/setup.sh</span><br><span class="line"><span class="comment">#--type apriltag                标定板类型</span></span><br><span class="line"><span class="comment">#--nx [NUM_COLS]                列个数</span></span><br><span class="line"><span class="comment">#--ny [NUM_ROWS]                行个数</span></span><br><span class="line"><span class="comment">#--tsize [TAG_WIDTH_M]          二维码方格长度，单位m</span></span><br><span class="line"><span class="comment">#--tspace [TAG_SPACING_PERCENT] 小方格与二维码方格长度比例</span></span><br><span class="line">rosrun kalibr kalibr_create_target_pdf --<span class="built_in">type</span> apriltag --nx 6 --ny 6 --tsize 0.022 --tspace 0.3</span><br><span class="line"><span class="comment">#新建april_6x6_A4.yaml文件，内容如下</span></span><br><span class="line">target_type: <span class="string">&#x27;aprilgrid&#x27;</span> <span class="comment">#gridtype</span></span><br><span class="line">tagCols: 6               <span class="comment">#number of apriltags</span></span><br><span class="line">tagRows: 6               <span class="comment">#number of apriltags</span></span><br><span class="line">tagSize: 0.022           <span class="comment">#size of apriltag, edge to edge [m]</span></span><br><span class="line">tagSpacing: 0.3          <span class="comment">#ratio of space between tags to tagSize</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>关闭双目结构光发射器，避免图像产生斑点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roslaunch realsense2_camera rs_camera_for_calib.launch</span><br><span class="line">rviz</span><br><span class="line">rosrun rqt_reconfigure rqt_reconfigure</span><br><span class="line"><span class="comment">#将camera/stereo_module标签页右侧的emitter_enabled设置为Off(0)，即关闭发射器，此时rviz中的双目图像斑点消失</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>【请忽略该步骤】限制相机帧数（<ahref="https://github.com/ethz-asl/kalibr/wiki/multiple-camera-calibration">官方推荐4Hz</a>）因为出现Cameras are not connected through mutual observations, please check thedataset. Maybe adjust the approx. sync.tolerance.报错所以该步骤放弃。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rosrun topic_tools throttle messages /camera/infra1/image_rect_raw 4.0 /infra_left</span><br><span class="line">rosrun topic_tools throttle messages /camera/infra2/image_rect_raw 4.0 /infra_right</span><br><span class="line"><span class="comment">#可以通过rostopic hz /infra_left命令或者直接在rviz中检查</span></span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>录制ROS bag</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/kalibr</span><br><span class="line">rosbag record -O multicameras_calibration /camera/infra1/image_rect_raw /camera/infra2/image_rect_raw</span><br><span class="line"><span class="comment">#官方推荐标定板对着相机动，但是由于标定板是A4纸比较软，所以这里反过来(实际官方视频也是这么做的：https://www.youtube.com/watch?app=desktop&amp;v=puNXsnrYWTY)</span></span><br><span class="line"><span class="comment">#运动的方式为：先绕相机的各自三个轴，每个轴旋转三次，然后再沿着相机的三个轴，每个轴平移三次，基本就可以了，运动期间要保证相机基本能一直看到标定板的全部信息。</span></span><br><span class="line"><span class="comment">#录制完毕后kalibr目录下生成multicameras_calibration.bag文件</span></span><br><span class="line"><span class="comment">#可通过rosbag info multicameras_calibration.bag查看数据包信息,示例如下：</span></span><br><span class="line">changhe@changhe:~/kalibr$ rosbag info multicameras_calibration.bag </span><br><span class="line">path:        multicameras_calibration.bag</span><br><span class="line">version:     2.0</span><br><span class="line">duration:    1:11s (71s)</span><br><span class="line">start:       Jan 05 2024 09:44:41.37 (1704419081.37)</span><br><span class="line">end:         Jan 05 2024 09:45:52.49 (1704419152.49)</span><br><span class="line">size:        1.6 GB</span><br><span class="line">messages:    4268</span><br><span class="line">compression: none [2134/2134 chunks]</span><br><span class="line">types:       sensor_msgs/Image [060021388200f6f0f447d0fcd9c64743]</span><br><span class="line">topics:      /camera/infra1/image_rect_raw   2134 msgs    : sensor_msgs/Image</span><br><span class="line">             /camera/infra2/image_rect_raw   2134 msgs    : sensor_msgs/Image</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>使用<strong>Kalibr</strong>进行双目标定</li></ol><p><ahref="https://github.com/ethz-asl/kalibr/wiki/calibrating-the-vi-sensor">Reprojectionerrors should be in a normal range (0.1-0.2 px for a goodcalibration)</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/kalibr</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line"><span class="comment">#注：april_6x6_A4.yaml是3.1节生成的</span></span><br><span class="line"><span class="comment">#--target：标定板参数信息存放的路径，即我们上面的april_s.yaml的路径</span></span><br><span class="line"><span class="comment">#--bag：录制的Camera数据包的路径</span></span><br><span class="line"><span class="comment">#--bag-from-to：起始和终止时间，单位是秒。为了避免开始录制和结束录制时的抖动，这里取了第3秒到第65秒之间的信息</span></span><br><span class="line"><span class="comment">#--models：相机模型，一般为针孔模型，https://github.com/ethz-asl/kalibr/wiki/supported-models</span></span><br><span class="line"><span class="comment">#--topics：影像流发布的话题</span></span><br><span class="line"><span class="comment">#--show-extraction：显示检测特征点的过程</span></span><br><span class="line">rosrun kalibr kalibr_calibrate_cameras --target april_6x6_A4.yaml --bag multicameras_calibration.bag --bag-from-to 3 65 --models pinhole-radtan pinhole-radtan --topics /camera/infra1/image_rect_raw /camera/infra2/image_rect_raw --show-extraction</span><br><span class="line"><span class="comment">#执行成功后，生成三个文件，分别为：</span></span><br><span class="line">1. multicameras_calibration-results-cam.txt</span><br><span class="line">2. multicameras_calibration-camchain.yaml</span><br><span class="line">3. multicameras_calibration-report-cam.pdf</span><br><span class="line"></span><br><span class="line"><span class="comment">#附：</span></span><br><span class="line"><span class="comment">#使用3.3步骤时，会出现双目图像流时间戳不同步问题，所以放弃3.3步骤，以下是相关issues以及可能的解决措施</span></span><br><span class="line"><span class="comment">#https://github.com/ethz-asl/kalibr/issues/364</span></span><br><span class="line"><span class="comment">#https://github.com/ethz-asl/kalibr/issues/332</span></span><br><span class="line"><span class="comment">#命令后添加 --approx-sync 0.04 将时间同步容忍度增加到0.04秒</span></span><br><span class="line">rosrun kalibr kalibr_calibrate_cameras --target april_6x6_A4.yaml --bag multicameras_calibration.bag --bag-from-to 3 65 --models pinhole-radtan pinhole-radtan --topics /camera/infra1/image_rect_raw /camera/infra2/image_rect_raw --show-extraction --approx-sync 0.04</span><br></pre></td></tr></table></figure><h3 id="双目imu联合标定">4. 双目&amp;IMU联合标定</h3><ol type="1"><li><ahref="https://github.com/ethz-asl/kalibr/wiki/yaml-formats">新建camchain.yaml文件</a></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据3.5节得到的multicameras_calibration-camchain.yaml在~/kalibr目录创建camchain.yaml文件</span></span><br><span class="line"><span class="comment">#camchain.yaml内容参考如下</span></span><br><span class="line"><span class="attr">cam0:</span></span><br><span class="line">  <span class="attr">camera_model:</span> <span class="string">pinhole</span></span><br><span class="line">  <span class="attr">intrinsics:</span> [<span class="number">384.57401093793385</span>, <span class="number">384.77603230830897</span>, <span class="number">319.36432154640477</span>, <span class="number">236.5865796387184</span>]</span><br><span class="line">  <span class="attr">distortion_model:</span> <span class="string">radtan</span></span><br><span class="line">  <span class="attr">distortion_coeffs:</span> [<span class="number">0.000868210041633816</span>, <span class="number">-0.001536564418790415</span>, <span class="number">-0.0008338819079702226</span>, <span class="number">0.0005407357906101209</span>]</span><br><span class="line">  <span class="attr">rostopic:</span> <span class="string">/camera/infra1/image_rect_raw</span></span><br><span class="line">  <span class="attr">resolution:</span> [<span class="number">640</span>, <span class="number">480</span>]</span><br><span class="line"><span class="attr">cam1:</span></span><br><span class="line">  <span class="attr">camera_model:</span> <span class="string">pinhole</span></span><br><span class="line">  <span class="attr">intrinsics:</span> [<span class="number">384.71257117832874</span>, <span class="number">385.0226535924584</span>, <span class="number">319.9598090030288</span>, <span class="number">236.36875214589423</span>]</span><br><span class="line">  <span class="attr">distortion_model:</span> <span class="string">radtan</span></span><br><span class="line">  <span class="attr">distortion_coeffs:</span> [<span class="number">0.0027736443531086595</span>, <span class="number">-0.004051540794976078</span>, <span class="number">-0.0010880219876272697</span>, <span class="number">0.0006497706840705447</span>]</span><br><span class="line">  <span class="attr">T_cn_cnm1:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="number">0.999997213819325</span>, <span class="number">-6.564576770509914e-05</span>, <span class="number">-0.0023596703620665503</span>, <span class="number">-0.05009032712390797</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="number">6.840714919526547e-05</span>, <span class="number">0.9999993130009001</span>, <span class="number">0.0011701786988816156</span>, <span class="number">4.8368258872807713e-05</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="number">0.0023595919236960978</span>, <span class="number">-0.0011703368568748496</span>, <span class="number">0.9999965313127803</span>, <span class="number">-0.0001744522191402009</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>]</span><br><span class="line">  <span class="attr">rostopic:</span> <span class="string">/camera/infra2/image_rect_raw</span></span><br><span class="line">  <span class="attr">resolution:</span> [<span class="number">640</span>, <span class="number">480</span>]</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><ahref="https://github.com/ethz-asl/kalibr/wiki/yaml-formats">新建imu.yaml文件</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据第2节获得的d435i_imu_param.yaml文件在~/kalibr目录创建imu.yaml文件</span></span><br><span class="line"><span class="comment">#d435i_imu_param.yaml文件位于~/imu_calib/src/imu_utils/data/目录下</span></span><br><span class="line"><span class="comment">#imu.yaml内容参考如下：</span></span><br><span class="line"><span class="comment">#Accelerometers</span></span><br><span class="line">accelerometer_noise_density: 1.5428717790802770e-02   <span class="comment">#Noise density (continuous-time)</span></span><br><span class="line">accelerometer_random_walk:   2.1733118964279978e-04   <span class="comment">#Bias random walk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Gyroscopes</span></span><br><span class="line">gyroscope_noise_density:     4.8137652096146783e-03   <span class="comment">#Noise density (continuous-time)</span></span><br><span class="line">gyroscope_random_walk:       1.8903981803128362e-05   <span class="comment">#Bias random walk</span></span><br><span class="line"></span><br><span class="line">rostopic:                    /camera/imu       <span class="comment">#the IMU ROS topic</span></span><br><span class="line">update_rate:                 400.0             <span class="comment">#Hz (for discretization of the values above)</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>录制ROS bag数据</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#~/d435i_ros/src/realsense-ros/realsense2_camera/launch/rs_camera_imu_for_calib.launch文件相比rs_camera_for_calib.launch</span></span><br><span class="line"><span class="comment">#改动了以下代码，将双目帧率调整至40hz，并打开了同步开关</span></span><br><span class="line"><span class="comment">#  &lt;arg name=&quot;infra_fps&quot;           default=&quot;40&quot;/&gt;</span></span><br><span class="line"><span class="comment">#  &lt;arg name=&quot;enable_sync&quot;   default=&quot;true&quot;/&gt;</span></span><br><span class="line"><span class="comment">#启动相机驱动</span></span><br><span class="line">roslaunch realsense2_camera rs_camera_imu_for_calib.launch</span><br><span class="line"><span class="comment">#打开rviz，订阅双目话题，关闭结构光，仿照3.4节动作录制数据</span></span><br><span class="line">rviz</span><br><span class="line">rosrun rqt_reconfigure rqt_reconfigure</span><br><span class="line"><span class="comment">#将camera/stereo_module标签页右侧的emitter_enabled设置为Off(0)，即关闭发射器，此时rviz中的双目图像斑点消失</span></span><br><span class="line"><span class="comment">#开始录制数据包，注意拿起放下相机时的数据应尽可能排除，从而避免相机的抖动/振动</span></span><br><span class="line"><span class="built_in">cd</span> ~/kalibr/</span><br><span class="line">rosbag record -O imu_stereo.bag /camera/infra1/image_rect_raw /camera/infra2/image_rect_raw /camera/imu</span><br><span class="line"><span class="comment">#录制完成后~/kalibr/目录下产生imu_stereo.bag</span></span><br><span class="line">changhe@changhe:~/kalibr$ rosbag info imu_stereo.bag </span><br><span class="line">path:        imu_stereo.bag</span><br><span class="line">version:     2.0</span><br><span class="line">duration:    2:02s (122s)</span><br><span class="line">start:       Jan 05 2024 12:12:07.82 (1704427927.82)</span><br><span class="line">end:         Jan 05 2024 12:14:10.61 (1704428050.61)</span><br><span class="line">size:        2.1 GB</span><br><span class="line">messages:    56462</span><br><span class="line">compression: none [2457/2457 chunks]</span><br><span class="line">types:       sensor_msgs/Image [060021388200f6f0f447d0fcd9c64743]</span><br><span class="line">             sensor_msgs/Imu   [6a62c6daae103f4ff57a132d6f95cec2]</span><br><span class="line">topics:      /camera/imu                     49094 msgs    : sensor_msgs/Imu  </span><br><span class="line">             /camera/infra1/image_rect_raw    3684 msgs    : sensor_msgs/Image</span><br><span class="line">             /camera/infra2/image_rect_raw    3684 msgs    : sensor_msgs/Image</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line"><span class="comment">#附：</span></span><br><span class="line"><span class="comment">#由于rostopic hz topic_name检查时发现imu频率在125hz，很奇怪，故以下步骤跳过忽略（本文采取双目 40hz，imu 400hz的频率采集）</span></span><br><span class="line"><span class="comment">#cameras should run at 20 Hz and IMU at 200 Hz，from https://github.com/ethz-asl/kalibr/wiki/calibrating-the-vi-sensor</span></span><br><span class="line"><span class="comment">#检查频率可通过 rostopic hz topic_name</span></span><br><span class="line">rosrun topic_tools throttle messages /camera/infra1/image_rect_raw 20.0 /infra_left &amp; rosrun topic_tools throttle messages /camera/infra2/image_rect_raw 20.0 /infra_right &amp; rosrun topic_tools throttle messages /camera/imu 200.0 /imu</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>使用<strong>Kalibr</strong>进行双目+IMU联合标定</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>  ~/kalibr/devel/setup.bash</span><br><span class="line"><span class="comment">#使用rosrun kalibr kalibr_calibrate_imu_camera启动标定程序</span></span><br><span class="line">rosrun kalibr kalibr_calibrate_imu_camera --bag  imu_stereo.bag --cam  camchain.yaml --imu imu.yaml --target april_6x6_A4.yaml --bag-from-to 5 115 --show-extraction</span><br><span class="line"><span class="comment">#等待一段时间，获得结果，共四个文件</span></span><br><span class="line">1. imu_stereo-camchain-imucam.yaml</span><br><span class="line">2. imu_stereo-imu.yaml</span><br><span class="line">3. imu_stereo-results-imucam.txt</span><br><span class="line">4. imu_stereo-report-imucam.pdf</span><br><span class="line"><span class="comment">#注：reprojection errors should be in a normal range (0.1-0.2 px for a good calibration)</span></span><br></pre></td></tr></table></figure><h2 id="参考内容">参考内容</h2><ol type="1"><li>https://blog.csdn.net/qq_38364548/article/details/124917067</li><li>http://zhaoxuhui.top/blog/2020/09/09/kalibr-installation-and-use.html</li><li>http://zhaoxuhui.top/blog/2020/09/29/intel-realsense-D435i-calibration-kalibr.html</li><li>https://github.com/gaowenliang</li><li>https://github.com/ethz-asl/kalibr/wiki/calibrating-the-vi-sensor</li><li>https://www.youtube.com/watch?app=desktop&amp;v=puNXsnrYWTY</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;d435i双目imu联合标定&quot;&gt;d435i双目+IMU联合标定&lt;/h2&gt;
&lt;h3 id=&quot;build-kalibr-from-source-code&quot;&gt;1. build Kalibr from source
code&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="note" scheme="https://silencht.github.io/categories/robot/note/"/>
    
    
  </entry>
  
  <entry>
    <title>gdb</title>
    <link href="https://silencht.github.io/wiki/cs/compile&amp;debug/gdb/"/>
    <id>https://silencht.github.io/wiki/cs/compile&amp;debug/gdb/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="启动gdb调试">1. 启动gdb调试</h3><h4 id="编译程序">1. 编译程序</h4><p>程序编译时需要附加调试信息-g，并关闭优化-O0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o helloworld helloworld.c</span><br><span class="line">$ gdb helloworld</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">……</span><br><span class="line">Reading symbols from xxx/helloworld...done.</span><br><span class="line"><span class="comment">#如果不带-g，即gcc -o helloworld helloworld.c，则输出</span></span><br><span class="line">Reading symbols from xxx/helloworld...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line"><span class="comment">#编译命令带-g生成程序后，可以使用Linux的strip命令移除该程序的调试信息</span></span><br><span class="line"><span class="comment">#使用strip命令之前</span></span><br><span class="line">-rwxr-xr-x. 1 root root 12416 Sep 8 09:45 helloworld</span><br><span class="line"><span class="comment">#使用strip命令之后，文件大小变小（12416-&gt;6312），此时再用gdb启动该程序，则会返回no debugging symbols found</span></span><br><span class="line">$ strip helloworld</span><br><span class="line">-rwxr-xr-x. 1 root root 6312 Sep 8 09:55 helloworld</span><br></pre></td></tr></table></figure><h4 id="启动调试">2. 启动调试</h4><p>三种方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 直接启动程序进行调试</span></span><br><span class="line">$ gdb helloworld</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 如果程序已经启动在运行，使用attach命令将gdb附加到该程序进程ID上（gdb attach pid）</span></span><br><span class="line"><span class="comment">#进程ID可以使用ps命令获取</span></span><br><span class="line">$ ps -ef | grep helloworld</span><br><span class="line">changhe   217055  216643 99 10:43 pts/2  00:00:55 ./helloworld</span><br><span class="line">$ gdb attach 217055</span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 程序Crash后调试core文件</span></span><br><span class="line"><span class="comment">#Linux默认不开启程序Crash产生core文件机制，可以使用ulimit -c查看是否开启，输出0则是不开启</span></span><br><span class="line">$ <span class="built_in">ulimit</span> -c</span><br><span class="line"><span class="comment">#开启产生core机制可以使用ulimit -c unlimited命令，unlimited意为不限制core文件大小，也可改成具体数值，比如1024（即1024k字节大小）</span></span><br><span class="line"><span class="comment">#ulimit -c unlimited命令只在当前终端有效，关闭终端后失效。设置永久生效的方式有两种：</span></span><br><span class="line"><span class="comment">#一是在/etc/security/limits.conf 中增加一行</span></span><br><span class="line"><span class="comment">#&lt;domain&gt;    &lt;type&gt;  &lt;item&gt;  &lt;value&gt;</span></span><br><span class="line">*             soft    core   unlimited</span><br><span class="line"><span class="comment">#二是在/etc/proﬁle文件（所有用户）或~/.bashrc（当前用户）末尾加入该命令</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited （或 <span class="built_in">ulimit</span> -c 1024）</span><br><span class="line"><span class="comment">#程序崩溃生成core.pid文件（需要编译时添加-g）后，使用下面命令进行调试</span></span><br><span class="line">$ gdb filename corename</span><br></pre></td></tr></table></figure><p>程序崩溃后很难知道当时它运行的PID，所以也就不知道对应哪个core文件。以下是记录程序对应core文件的两个方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 程序启动时记录自己的PID，这样就可以根据core.pid去查找对应的core文件了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writePid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">uint32_t</span> curPid = (<span class="type">uint32_t</span>) <span class="built_in">getpid</span>();</span><br><span class="line">FILE* f = <span class="built_in">fopen</span>(<span class="string">&quot;helloworld.pid&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">assert</span>(f);</span><br><span class="line"><span class="type">char</span> szPid[<span class="number">32</span>];</span><br><span class="line"><span class="built_in">snprintf</span>(szPid, <span class="built_in">sizeof</span>(szPid), <span class="string">&quot;%d&quot;</span>, curPid);</span><br><span class="line"><span class="built_in">fwrite</span>(szPid, <span class="built_in">strlen</span>(szPid), <span class="number">1</span>, f);</span><br><span class="line"><span class="built_in">fclose</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 自定义生成core文件的目录名称</span></span><br><span class="line">mkdir ~/core_dump_directory</span><br><span class="line"><span class="comment">//%e是程序名，%p是PID，%t是文件生成时间</span></span><br><span class="line">echo <span class="string">&quot;~/core_dump_directory/core-%e-%p-%t&quot;</span> &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="comment">//最终会在 ~/core_dump_directory 目录下（需具备写入权限）生成的 test 的 core 文件名格式如下</span></span><br><span class="line">-rw-------. <span class="number">1</span> user user <span class="number">409600</span> Jan <span class="number">14</span> <span class="number">13</span>:<span class="number">54</span> core-helloworld<span class="number">-13154</span><span class="number">-1547445291</span></span><br></pre></td></tr></table></figure><h3 id="命令详解">2. 命令详解</h3><h4 id="run">run</h4><p>启动调试后，只是在程序上附加了gdb，并没有启动该程序，需要输入run命令启动这个程序。</p><p>程序启动后可使用Ctrl+C终端程序，再次输入run，可以重新启动该程序。</p><h4 id="continue">continue</h4><p>如果不想重新启动程序，而是想让中断的程序继续运行，可以输入continue命令</p><h4 id="breaktbreak">break、tbreak</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在名为function的函数入口出添加一个断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> <span class="keyword">function</span></span><br><span class="line"><span class="comment">#在gdb调试器所在的当前文件第num行处添加一个断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> num</span><br><span class="line"><span class="comment">#在filename文件第num行处添加一个断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> filename:num</span><br></pre></td></tr></table></figure><p>break命令是添加一个永久的断点，tbreak命令是添加一个临时断点，触发一次后自动删除。</p><h4 id="backtraceframe">backtrace、frame</h4><p>backtrace命令可以简写为bt，用来查看当前所在线程的调用堆栈。堆栈编号以#number表示。</p><p>如果在主线程，那么最顶层堆栈是main()函数。</p><p>切换到某堆栈，可以使用frame命令（可简写为f）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ frame number <span class="comment">#堆栈编号不用加“#”</span></span><br></pre></td></tr></table></figure><h4 id="info-breakenabledisabledelete">infobreak、enable、disable、delete</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看所有断点</span></span><br><span class="line">(gdb) info <span class="built_in">break</span> <span class="comment"># 或 info b</span></span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x000000000004d93a <span class="keyword">in</span> main at server.c:6147</span><br><span class="line">2       breakpoint     keep y   0x0000000000041593 <span class="keyword">in</span> dictSdsKeyCaseCompare at server.c:1269</span><br><span class="line">3       breakpoint     keep y   0x0000000000043589 <span class="keyword">in</span> beforeSleep at server.c:2364</span><br><span class="line"><span class="comment">#可见示例中一共存在3个断点，分别在6147、1269、2364行</span></span><br><span class="line"><span class="comment">#如果想禁用某个断点，使用 disable 断点编号 就可以禁用这个断点；同理，被禁用的断点也可以使用 enable 断点编号 重新开启</span></span><br><span class="line">(gdb) <span class="built_in">disable</span> 2</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x000000000004d93a <span class="keyword">in</span> main at server.c:6147</span><br><span class="line">2       breakpoint     keep y   0x0000000000041593 <span class="keyword">in</span> dictSdsKeyCaseCompare at server.c:1269</span><br><span class="line">3       breakpoint     keep y   0x0000000000043589 <span class="keyword">in</span> beforeSleep at server.c:2364</span><br><span class="line"><span class="comment">#可见，禁用断点2后，Enb下方的标志由y变为n. 同理，使用enable 2命令重启后，该标志又会回到y</span></span><br><span class="line"><span class="comment">#enable、disable命令后不加断点编号，即表示开启、禁用所有断点</span></span><br><span class="line"><span class="comment">#delete 断点编号，即表示删除某断点。同理，不加断点编号，即表示删除所有断点</span></span><br></pre></td></tr></table></figure><h4 id="list">list</h4><p>该命令可以查看当前断点前后的代码（默认范围为10行），可以简写为l.再次输入命令继续向后显示10行代码。</p><p>list +和list -分别表示向后和向前显示代码。</p><p>list 也可以显示其他文件某一行前后的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list FILE:LINENUM  <span class="comment">#to list around that line in that file,</span></span><br></pre></td></tr></table></figure><p>更多用法输入help list</p><h4 id="printptype">print、ptype</h4><p>print命令可以在调试过程中查看变量的值，也可以修改当前内存中的变量值，可以简写成p</p><p>print命令不仅可以输出变量值，也可以输出特定表达式计算结果值，甚至可以输出一些函数的执行结果值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印server.port变量的值 (gdb) print variable</span></span><br><span class="line">(gdb) p server.port</span><br><span class="line"><span class="variable">$1</span> = 6379</span><br><span class="line"><span class="comment">#打印server.port变量的类型</span></span><br><span class="line">(gdb) ptype server.port</span><br><span class="line"><span class="built_in">type</span> = int</span><br><span class="line"><span class="comment">#列出当前对象的各个成员变量值</span></span><br><span class="line">(gdb) p *this</span><br><span class="line"><span class="comment">#打印三个变量的和</span></span><br><span class="line">(gdb) p a+b+c</span><br><span class="line"><span class="comment">#打印函数执行结果</span></span><br><span class="line">(gdb) p <span class="keyword">function</span>()</span><br><span class="line"><span class="comment">#某个时刻，某个系统函数执行失败了，通过系统变量 errno 得到一个错误码，可以使用</span></span><br><span class="line">(gdb) p strerror(errno) </span><br><span class="line"><span class="comment">#将这个错误码对应的文字信息打印出来，这样就不用去 man 手册上查找这个错误码对应的错误含义</span></span><br><span class="line"><span class="comment">#修改变量的值</span></span><br><span class="line">(gdb) p server.port=6400</span><br><span class="line"><span class="variable">$4</span> = 6400</span><br><span class="line"><span class="comment">#打印变量时可以指定输出格式 (gdb) print /format variable</span></span><br><span class="line">(gdb) p /x server.port</span><br><span class="line"><span class="variable">$6</span> = 0x1900</span><br><span class="line"><span class="comment">#format常见取值</span></span><br><span class="line">o octal 八进制显示</span><br><span class="line">x hex 十六进制显示</span><br><span class="line">d decimal 十进制显示</span><br><span class="line">u unsigned decimal 无符号十进制显示</span><br><span class="line">t binary 二进制显示</span><br><span class="line">f <span class="built_in">float</span> 浮点值显示</span><br><span class="line">a address 内存地址格式显示(与十六进制相似)</span><br><span class="line">i instruction 指令格式显示</span><br><span class="line">s string 字符串形式显示</span><br><span class="line">z hex, zero padded on the left 十六进制左侧补0显示</span><br></pre></td></tr></table></figure><h4 id="infothread">info、thread</h4><ul><li>可以使用 info threads 来查看进程当前所有线程信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads </span><br><span class="line">  Id   Target Id                                           Frame </span><br><span class="line">* 1    Thread 0x7ffff79d57c0 (LWP 230901) <span class="string">&quot;redis-server&quot;</span>   0x00007ffff7c9046e <span class="keyword">in</span> epoll_wait (</span><br><span class="line">    epfd=5, events=0x5555557a1db0, maxevents=10128, <span class="built_in">timeout</span>=100)</span><br><span class="line">    at ../sysdeps/unix/sysv/linux/epoll_wait.c:30</span><br><span class="line">  2    Thread 0x7ffff6ba6700 (LWP 230905) <span class="string">&quot;bio_close_file&quot;</span> futex_wait_cancelable (</span><br><span class="line">    private=&lt;optimized out&gt;, expected=0, futex_word=0x5555557073e8 &lt;bio_newjob_cond+40&gt;)</span><br><span class="line">    at ../sysdeps/nptl/futex-internal.h:183</span><br><span class="line">  3    Thread 0x7ffff63a5700 (LWP 230906) <span class="string">&quot;bio_aof_fsync&quot;</span>  futex_wait_cancelable (</span><br><span class="line">    private=&lt;optimized out&gt;, expected=0, futex_word=0x555555707418 &lt;bio_newjob_cond+88&gt;)</span><br><span class="line">    at ../sysdeps/nptl/futex-internal.h:183</span><br><span class="line">  4    Thread 0x7ffff5ba4700 (LWP 230907) <span class="string">&quot;bio_lazy_free&quot;</span>  futex_wait_cancelable (</span><br><span class="line">    private=&lt;optimized out&gt;, expected=0, futex_word=0x555555707448 &lt;bio_newjob_cond+136&gt;)</span><br><span class="line">    at ../sysdeps/nptl/futex-internal.h:183</span><br><span class="line"><span class="comment">#一共有4个线程，当前gdb附加在1号线程（带星号）。</span></span><br><span class="line"><span class="comment">#【所有的线程ID在第三栏(LWP number)中。在早期的 Linux 系统的内核里面，不存在真正的线程实现</span></span><br><span class="line"><span class="comment"># 当时所有的线程都是用进程来实现，称之为LWP，即Light Weight Process（轻量级进程）】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#切换到其他线程，使用thread 线程编号</span></span><br><span class="line">(gdb) thread 3</span><br><span class="line">[Switching to thread 3 (Thread 0x7ffff63a5700 (LWP 231546))]</span><br><span class="line"><span class="comment">#0  futex_wait_cancelable (private=&lt;optimized out&gt;, expected=0, </span></span><br><span class="line">    futex_word=0x555555707418 &lt;bio_newjob_cond+88&gt;) at ../sysdeps/nptl/futex-internal.h:183</span><br><span class="line">183../sysdeps/nptl/futex-internal.h: No such file or directory.</span><br><span class="line">(gdb) info threads </span><br><span class="line">  Id   Target Id                                           Frame </span><br><span class="line">  1    Thread 0x7ffff79d57c0 (LWP 231538) <span class="string">&quot;redis-server&quot;</span>   0x00007ffff7c9046e <span class="keyword">in</span> epoll_wait (epfd=5, </span><br><span class="line">    events=0x5555557a1db0, maxevents=10128, <span class="built_in">timeout</span>=100) at ../sysdeps/unix/sysv/linux/epoll_wait.c:30</span><br><span class="line">  2    Thread 0x7ffff6ba6700 (LWP 231545) <span class="string">&quot;bio_close_file&quot;</span> futex_wait_cancelable (private=&lt;optimized out&gt;, </span><br><span class="line">    expected=0, futex_word=0x5555557073e8 &lt;bio_newjob_cond+40&gt;) at ../sysdeps/nptl/futex-internal.h:183</span><br><span class="line">* 3    Thread 0x7ffff63a5700 (LWP 231546) <span class="string">&quot;bio_aof_fsync&quot;</span>  futex_wait_cancelable (private=&lt;optimized out&gt;, </span><br><span class="line">    expected=0, futex_word=0x555555707418 &lt;bio_newjob_cond+88&gt;) at ../sysdeps/nptl/futex-internal.h:183</span><br><span class="line">  4    Thread 0x7ffff5ba4700 (LWP 231547) <span class="string">&quot;bio_lazy_free&quot;</span>  futex_wait_cancelable (private=&lt;optimized out&gt;, </span><br><span class="line">    expected=0, futex_word=0x555555707448 &lt;bio_newjob_cond+136&gt;) at ../sysdeps/nptl/futex-internal.h:183</span><br></pre></td></tr></table></figure><ul><li>如何找到main函数所在的主线程，并切换过去？</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_start 是C程序的入口函数，可以设置断点在入口函数内，然后运行程序，查看当前线程：</span></span><br><span class="line">(gdb) <span class="built_in">break</span> _start</span><br><span class="line">Breakpoint 1 at 0x55555558bb80</span><br><span class="line">(gdb) run</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/changhe/gdb/redis-6.2.4/src/redis-server </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x000055555558bb80 <span class="keyword">in</span> _start ()</span><br><span class="line">(gdb) info threads </span><br><span class="line">  Id   Target Id                                         Frame </span><br><span class="line">* 1    Thread 0x7ffff79d57c0 (LWP 231538) <span class="string">&quot;redis-server&quot;</span> 0x000055555558bb80 <span class="keyword">in</span> _start ()</span><br></pre></td></tr></table></figure><ul><li>info 命令还可以用来查看当前堆栈处函数的参数值：info args</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0 0x00007ffff71e2603 in epoll_wait () from /usr/lib64/libc.so.6</span></span><br><span class="line"><span class="comment">#1 0x0000000000428a9e in aeApiPoll (eventLoop=0x5e5770, tvp=0x7fffffffe140) at ae_epoll.c:112</span></span><br><span class="line"><span class="comment">#2 0x00000000004297e2 in aeProcessEvents (eventLoop=0x5e5770, flags=27) at ae.c:447</span></span><br><span class="line"><span class="comment">#3 0x0000000000429ab6 in aeMain (eventLoop=0x5e5770) at ae.c:539</span></span><br><span class="line"><span class="comment">#4 0x00000000004372bb in main (argc=1, argv=0x7fffffffe308) at server.c:5175</span></span><br><span class="line">(gdb) f 2 <span class="comment">#切换到堆栈 #2,堆栈 #2 调用处的函数是 aeProcessEvents(),一共有两个参数</span></span><br><span class="line"><span class="comment">#2 0x00000000004297e2 in aeProcessEvents (eventLoop=0x5e5770, flags=27) at ae.c:447</span></span><br><span class="line">447 numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line">(gdb) info args <span class="comment">#使用该命令输出当前函数的两个参数值，指针类型的参数，gdb 默认会输出该变量的指针地址值</span></span><br><span class="line">eventLoop = 0x5e5770</span><br><span class="line">flags = 27</span><br><span class="line">(gdb) p *eventLoop <span class="comment">#要想输出指针指向的对象的值，可以使用print命令，</span></span><br><span class="line"><span class="comment">#如果还要查看其成员值，继续使用 变量名-&gt;字段名 即可（如 p eventLoop-&gt;maxfd ）</span></span><br></pre></td></tr></table></figure><h4id="nextstepuntilfinishreturnjump">next、step、until、finish、return、jump</h4><table><colgroup><col style="width: 8%" /><col style="width: 5%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th style="text-align: center;">命令</th><th style="text-align: center;">缩写</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">next</td><td style="text-align: center;">n</td><td style="text-align: center;">stepover，单步步过，不进入函数体内部</td></tr><tr class="even"><td style="text-align: center;">step</td><td style="text-align: center;">s</td><td style="text-align: center;">step into，单步步入，进入函数体内部</td></tr><tr class="odd"><td style="text-align: center;">until</td><td style="text-align: center;">u</td><td style="text-align: center;">until程序行号，指定程序运行到某一行代码处停下</td></tr><tr class="even"><td style="text-align: center;">finish</td><td style="text-align: center;"></td><td style="text-align: center;">立即执行当前函数剩余代码并正常返回</td></tr><tr class="odd"><td style="text-align: center;">return</td><td style="text-align: center;"></td><tdstyle="text-align: center;">立即结束执行当前函数并返回（如果当前函数还有剩余的代码未执行，也不会执行）</td></tr><tr class="even"><td style="text-align: center;">jump</td><td style="text-align: center;">j</td><td style="text-align: center;">jump location，location可以是程序行号或者函数地址，jump 会让程序执行流跳转到指定位置执行</td></tr></tbody></table><ul><li><p>until 注意</p><p>与 <code>break</code> 命令不同，<code>until</code> 命令中的行号是 GDB中显示的行号，而不是源代码文件中的行号。这里的行号以 gdb调试器中的行号为准（可以通过list查看），不是源码文件中的行号，由于存在条件编译，部分代码可能不会被编译进可执行文件中，所以实际的调试符号文件中的行号与源码文件中的行号可能会不完全一致。</p></li><li><p>jump 注意：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">somefunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//代码A</span></span><br><span class="line"> <span class="comment">//代码B</span></span><br><span class="line"> <span class="comment">//代码C</span></span><br><span class="line"> <span class="comment">//代码D</span></span><br><span class="line"> <span class="comment">//代码E</span></span><br><span class="line"> <span class="comment">//代码F</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假设断点初始位置在行号 3 处（代码 A），这个时候使用 jump 6，那么程序会跳过代码 B</span></span><br><span class="line"><span class="comment">//和 C 的执行，执行完代码 D（ 跳转点），程序并不会停在代码 6 处，而是继续执行后续代码，因此如</span></span><br><span class="line"><span class="comment">//果想查看执行跳转处的代码后的结果，需要在行号 6、7 或 8 处设置断点。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jump命令有一个妙用就是可以执行一些想要执行的代码，而这些代码在正常的逻辑下可能并不会执行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (a != <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;if condition\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;else condition\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在行号 4 、14 处设置一个断点，当触发行号 4 处的断点后，正常情况下程序执行流会走 else 分</span></span><br><span class="line"><span class="comment">//支，可以使用 jump 7 强行让程序执行 if 分支，接着 gdb 会因触发行号 14 处的断点而停下来，此</span></span><br><span class="line"><span class="comment">//时接着执行 jump 11，程序会将 else 分支中的代码重新执行一遍</span></span><br></pre></td></tr></table></figure><h4 id="disassemble">disassemble</h4><p>在一些高级调试时，我们可能要查看某段代码的汇编指令去排查问题，或者是在调试一些没有调试信息的发布版程序时，也只能通过反汇编代码去定位问题。</p><p>disassemble 会输出当前所在函数的汇编指令，假设我们现在在 redis 的initServer() 中执行该命令会输出 initServer() 函数的汇编指令.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b initServer</span><br><span class="line">Breakpoint 2 at 0x555555599666: file server.c, line 3137.</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/changhe/gdb/redis-6.2.4/src/redis-server </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line">235674:C 12 Oct 2023 16:00:36.542 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">235674:C 12 Oct 2023 16:00:36.542 <span class="comment"># Redis version=6.2.4, bits=64, commit=00000000, modified=0, pid=235674, just started</span></span><br><span class="line">235674:C 12 Oct 2023 16:00:36.542 <span class="comment"># Warning: no config file specified, using the default config. In order to specify a config file use /home/changhe/gdb/redis-6.2.4/src/redis-server /path/to/redis.conf</span></span><br><span class="line"></span><br><span class="line">Breakpoint 2, initServer () at server.c:3137</span><br><span class="line">3137void initServer(void) &#123;</span><br><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> initServer:</span><br><span class="line">=&gt; 0x0000555555599666 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x000055555559966a &lt;+4&gt;:push   %rbp</span><br><span class="line">   0x000055555559966b &lt;+5&gt;:mov    %rsp,%rbp</span><br><span class="line">   0x000055555559966e &lt;+8&gt;:push   %rbx</span><br><span class="line">   0x000055555559966f &lt;+9&gt;:sub    <span class="variable">$0x18</span>,%rsp</span><br><span class="line">   ……</span><br></pre></td></tr></table></figure><p>gdb 默认反汇编为 AT&amp;T 格式的指令，可以通过 show disassembly-ﬂavor查看。如果习惯 intel 汇编 格式的，用命令 set disassembly-flavor intel来设置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show disassembly-ﬂavor</span><br><span class="line">The disassembly flavor is <span class="string">&quot;att&quot;</span>.</span><br><span class="line">(gdb) <span class="built_in">set</span> disassembly-flavor intel</span><br><span class="line">(gdb) disassemble </span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> initServer:</span><br><span class="line">=&gt; 0x0000555555599666 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x000055555559966a &lt;+4&gt;:push   rbp</span><br><span class="line">   0x000055555559966b &lt;+5&gt;:mov    rbp,rsp</span><br><span class="line">   0x000055555559966e &lt;+8&gt;:push   rbx</span><br><span class="line">   0x000055555559966f &lt;+9&gt;:sub    rsp,0x18</span><br><span class="line">   ……</span><br></pre></td></tr></table></figure><p>这个命令在我们只有程序崩溃后产生 core文件，且无对应的调试符号时非常有用，我们可以通过分析汇编代码定位一些错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;启动gdb调试&quot;&gt;1. 启动gdb调试&lt;/h3&gt;
&lt;h4 id=&quot;编译程序&quot;&gt;1. 编译程序&lt;/h4&gt;
&lt;p&gt;程序编译时需要附加调试信息-g，并关闭优化-O0&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="cs" scheme="https://silencht.github.io/categories/cs/"/>
    
      <category term="compile&amp;debug" scheme="https://silencht.github.io/categories/cs/compile-debug/"/>
    
    
  </entry>
  
  <entry>
    <title>性能分析工具之perf</title>
    <link href="https://silencht.github.io/wiki/cs/compile&amp;debug/perf/"/>
    <id>https://silencht.github.io/wiki/cs/compile&amp;debug/perf/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介">1. 简介</h3><p><strong>perf</strong> 是 Linux内核提供的性能分析工具，可以分析程序运行的性能瓶颈和优化点。通常随着Linux 内核的安装而自动安装。它通常包含在 <code>linux-tools</code> 或<code>perf-tools</code> 包中，具体取决于你所使用的 Linux 发行版。</p><p>使用<code>perf --version</code>便可以查看perf的软件版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> perf --version</span></span><br><span class="line">perf version 5.15.111</span><br></pre></td></tr></table></figure><p>如果提示找不到该命令，可通过以下命令进行安装（Ubuntu发行版）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install linux-tools-common</span><br></pre></td></tr></table></figure><h3 id="使用">2. 使用</h3><h4 id="分析正在运行的程序">2.1 分析正在运行的程序</h4><p>如果要分析的程序可执行文件名称为 grid_map，使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看目录下的文件，可见存在可执行文件grid_map，运行之</span></span><br><span class="line">ls </span><br><span class="line">grid_map grid_map.cpp CMakeLists.txt</span><br><span class="line">./grid_map</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">假设该程序正在运行中，通过ps命令查看它的进程号，可得PID进程号为880154</span></span><br><span class="line">ps -ef | grep grid_map</span><br><span class="line">changhe   880154  880083 99 18:01 pts/5    00:00:24 ./grid_map</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用perf命令分析该程序</span></span><br><span class="line">sudo perf record -F 99 -p 880154 -g  -- sleep 30</span><br><span class="line">[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.522 MB perf.data (4534 samples) ]</span><br><span class="line">ls</span><br><span class="line">grid_map grid_map.cpp CMakeLists.txt perf.data</span><br></pre></td></tr></table></figure><p>命令说明</p><ul><li><code>sudo</code>: 以超级用户权限运行命令，因为 <code>perf</code>需要访问内核信息</li><li><code>perf record</code>: 用于收集性能数据</li><li><code>-F 99</code>: 设置采样的频率为 99 Hz。这意味着<code>perf</code> 将每秒对正在运行的程序进行99次采样</li><li><code>-p 880154</code>: 指定要监视的进程的进程 ID(PID)。在这个例子中，<code>880154</code>是希望分析的grid_map进程PID。</li><li><code>-g</code>:启用堆栈跟踪，记录每个采样时的调用堆栈信息，以便更详细地了解程序的执行路径</li><li><code>-- sleep 30</code>: 持续采集30秒</li></ul><p>采集完成后，输出一个<code>perf.data</code>文件</p><h4 id="分析可执行文件">2.2 分析可执行文件</h4><p>使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -F 99 -g ./grid_map --sleep 30</span><br><span class="line">[ perf record: Woken up 2 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.606 MB perf.data (5112 samples) ]</span><br></pre></td></tr></table></figure><p>命令说明</p><ul><li>其实同2.1，就是将-p PID替换为了可执行文件路径</li></ul><h3 id="使用火焰图可视化结果">3. 使用火焰图可视化结果</h3><p>FlameGraph是由<ahref="http://www.brendangregg.com/index.html">BrendanGregg</a>开发的一款开源可视化性能分析工具，形象的称为火焰图。其基于perf 结果产生的SVG 图片，用来展示 CPU 的调用栈。</p><p>要使用火焰图可视化perf分析结果，首先下载FlameGraph</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意：FlameGraph仓库下载的目录影响下面代码./FlameGraph/stackcollapse-perf.pl的执行路径</span></span><br><span class="line">git clone https://github.com/brendangregg/FlameGraph</span><br></pre></td></tr></table></figure><p>分析结果可视化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">现在要对分析结果文件perf.data进行火焰图可视化</span></span><br><span class="line">ls</span><br><span class="line">grid_map grid_map.cpp CMakeLists.txt perf.data</span><br><span class="line">sudo perf script -i perf.data &gt; perf.unfold</span><br><span class="line">sudo ./FlameGraph/stackcollapse-perf.pl perf.unfold &gt; perf.folded</span><br><span class="line">sudo ./FlameGraph/flamegraph.pl perf.folded &gt; perf.svg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">现在目录下便有一个名为perf.svg的文件了</span></span><br></pre></td></tr></table></figure><p>命令说明</p><ul><li><p><code>perf script</code>: 从 <code>perf.data</code>文件中生成可读的文本格式的性能数据。该命令会将数据写入标准输出</p></li><li><p><code>-i perf.data</code>: 指定 <code>perf</code> 工具读取<code>perf.data</code> 文件</p></li><li><p><code>&gt; perf.unfold</code>: 将标准输出重定向到名为<code>perf.unfold</code> 的文件中。这个文件包含了可读的性能数据</p></li><li><p><code>./FlameGraph/stackcollapse-perf.pl</code>: 该脚本将<code>perf</code> 的输出进行处理</p></li><li><p><code>&gt; perf.folded</code>: 将处理后的输出重定向到名为<code>perf.folded</code>的文件中。这个文件包含了折叠后的性能数据</p></li><li><p><code>./FlameGraph/flamegraph.pl</code>:该脚本将<code>perf.folded</code>转换为 Flame Graph 的 SVG图形。</p></li></ul><p>使用浏览器将perf.svg文件打开便可以查看结果图，示例图如下：</p><p><img src="/image/性能分析工具perf/perf.png" /></p><ul><li><p>y轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p></li><li><p>x 轴表示抽样数，如果一个函数在 x轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p></li></ul><p>也可以实时查看当前系统程序性能分析数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf record -F 999 -a -g -- sleep 60</span><br><span class="line">perf script | ./stackcollapse-perf.pl | ./flamegraph.pl &gt; out.svg</span><br></pre></td></tr></table></figure><p><strong><code>perf script</code>：</strong></p><ul><li>这个命令从实时数据中读取。它会连接到正在运行的<code>perf record</code>进程（如果有的话）或者当前的系统事件，然后输出相应的性能数据。</li><li>这个命令通常用于实时查看当前系统的性能数据，而不是读取之前保存的数据文件。</li></ul><p>由火焰图可见，grid_map::MedianFilter::update和grid_map::NormalVectorsFilter::update两个函数是程序性能的关键所在。继续向上回溯便可以逐渐发现程序的执行的“热点函数”。</p><p>有了这些分析，便可以针对性的对程序提出一些优化。</p><h3 id="参考资料">4. 参考资料</h3><blockquote><ul><li><ahref="https://www.ruanyifeng.com/blog/2017/09/flame-graph.html">如何读懂火焰图？</a></li><li><ahref="https://www.bilibili.com/video/BV1hg4y1o7Sb/?share_source=copy_web&amp;vd_source=32cbeca2ce39d95a4b3686678d95dc87">LinuxC/C++性能优化分析工具Perf使用教程</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;1. 简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;perf&lt;/strong&gt; 是 Linux
内核提供的性能分析工具，可以分析程序运行的性能瓶颈和优化点。通常随着
Linux 内核的安装而自动安装。它通常包含在 &lt;code&gt;linux-tools&lt;/code&gt; 
      
    
    </summary>
    
      <category term="cs" scheme="https://silencht.github.io/categories/cs/"/>
    
      <category term="compile&amp;debug" scheme="https://silencht.github.io/categories/cs/compile-debug/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://silencht.github.io/wiki/cs/database/MySQL/"/>
    <id>https://silencht.github.io/wiki/cs/database/MySQL/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装mysql">1.安装mysql</h2><h3 id="windows环境">1.1 WINDOWS环境</h3><p>参考微信读书《MySQL8从零开始学》</p><h3 id="linux环境-5.7">1.2 LINUX环境 5.7</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get install mysql-client</span><br><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>安装过程中会提示设置密码什么的，记住密码不要忘。</p><ul><li>第三条命令出现 正在读取软件包列表... 完成 正在分析软件包的依赖关系树正在读取状态信息... 完成 有一些软件包无法被安装。如果您用的是 unstable发行版，这也许是因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件包尚未被创建……错误，根据博客解决之，网址为：https://www.cnblogs.com/mliudong/p/4217945.html</li></ul><p>安装完成之后可以使用如下命令来检查是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><ul><li>检查命令出现“sudo:netstat：找不到命令”，查找博客https://blog.csdn.net/weixin_41931602/article/details/83211455，输入命令:sudoapt-get install net-tools 后解决问题。</li></ul><h3 id="linux环境-8.0">1.3 LINUX环境 8.0</h3><p>https://blog.csdn.net/iehadoop/article/details/82961264</p><h3 id="mysql常用命令">1.4 MySQL常用命令</h3><h4 id="登陆">1.4.1 登陆：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p </span><br><span class="line">root用户本地登陆</span><br><span class="line"></span><br><span class="line">mysql –u用户名 [–h主机名或者服务器IP地址] –p;</span><br><span class="line">输入密码;</span><br><span class="line">一般用户远程登陆</span><br></pre></td></tr></table></figure><h4 id="mysql命令">1.4.2 MySQL命令：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br><span class="line">列出 MySQL 数据库管理系统的数据库列表。</span><br><span class="line"></span><br><span class="line">USE 数据库名 ;</span><br><span class="line">选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</span><br><span class="line"></span><br><span class="line">SHOW TABLES;</span><br><span class="line">显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。</span><br><span class="line"></span><br><span class="line">SHOW COLUMNS FROM 数据表;</span><br><span class="line">显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</span><br><span class="line"></span><br><span class="line">select * from 数据表;</span><br><span class="line">获取该数据表的所有记录的数据。</span><br></pre></td></tr></table></figure><h2 id="创建数据库">2.创建数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure><h2 id="创建用户">3.创建用户</h2><p>创建可以访问数据库gesture的yoloyolo用户，密码为silencht</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP</span><br><span class="line">ON gesture.*</span><br><span class="line">TO &#x27;yoloyolo&#x27;@&#x27;192.168.1.%&#x27;</span><br><span class="line">IDENTIFIED BY &#x27;silencht&#x27;;</span><br></pre></td></tr></table></figure><h2 id="创建数据表">4.创建数据表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE gesture_tbl(</span><br><span class="line">gesture_id INT UNSIGNED AUTO_INCREMENT,</span><br><span class="line">c1 INT,</span><br><span class="line">p1 FLOAT,</span><br><span class="line">c2 INT,</span><br><span class="line">p2 FLOAT,</span><br><span class="line">fps FLOAT,</span><br><span class="line">PRIMARY KEY (gesture_id)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h2 id="插入原始的3行初始化数据">5.插入原始的3行初始化数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO gesture_tbl(c1,p1,c2,p2,fps)</span><br><span class="line">VALUES</span><br><span class="line"> (&#x27;2&#x27;,&#x27;98.654874&#x27;,&#x27;6&#x27;,&#x27;46.544648&#x27;,&#x27;26.7684&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO gesture_tbl(c1,p1,c2,p2,fps)</span><br><span class="line">VALUES</span><br><span class="line"> (&#x27;18&#x27;,&#x27;96.4564534&#x27;,&#x27;9&#x27;,&#x27;0&#x27;,&#x27;19.6574&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO gesture_tbl(c1,p1,c2,p2,fps)</span><br><span class="line">VALUES</span><br><span class="line"> (&#x27;9&#x27;,&#x27;83.65546564&#x27;,&#x27;20&#x27;,&#x27;36.456464&#x27;,&#x27;24.4864&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2id="示例命令行更新表格第二行数据">6.（示例）命令行更新表格第二行数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE gesture_tbl SET c1 = &quot;6&quot;, p1 = &quot;96.8586&quot;, c2 =&quot;18&quot;, p2 =&quot;16.67452&quot;, fps = &quot;21.4186&quot;  WHERE gesture_id = 2;</span><br></pre></td></tr></table></figure><h2 id="c语言调用mysql的接口进行增删改查操作">7.C语言调用MySQL的接口，进行增删改查操作</h2><p>代码位于此仓库：https://github.com/silencht/Use-C-language-to-call-Mysql</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装mysql&quot;&gt;1.安装mysql&lt;/h2&gt;
&lt;h3 id=&quot;windows环境&quot;&gt;1.1 WINDOWS环境&lt;/h3&gt;
&lt;p&gt;参考微信读书《MySQL8从零开始学》&lt;/p&gt;
&lt;h3 id=&quot;linux环境-5.7&quot;&gt;1.2 LINUX环境 5.7&lt;/h3&gt;
&lt;
      
    
    </summary>
    
      <category term="cs" scheme="https://silencht.github.io/categories/cs/"/>
    
      <category term="database" scheme="https://silencht.github.io/categories/cs/database/"/>
    
    
  </entry>
  
  <entry>
    <title>组合电路</title>
    <link href="https://silencht.github.io/wiki/ee/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF/"/>
    <id>https://silencht.github.io/wiki/ee/数字电子技术/组合电路/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序">0. 序</h2><p><strong>1.</strong>我常常在想，数字电子技术和程序设计基础C是何等的相似，以至于我总想把数电理解为电路中的c语言。组合逻辑电路中的译码器，编码器，数据选择器等等可以看做C语言中的各种函数，电路输入即为函数形参，电路输出即为函数返回值。我们在设计电路时，可以把各种封装器件按照它们的功能运用在不同的位置，我们编写程序时，把各种函数按照功能放在main函数中的不同行，在运用器件or函数的时候，我们不会考虑它内部的运作情况，仅仅关注它的输入与输出的关系。</p><p><strong>2.</strong>数字电路按照逻辑功能的不同可分为组合逻辑电路与时序逻辑电路。其中，组合逻辑电路的本质即为:<strong>任意时刻输出仅取决于该时刻的输入</strong>。高度概括为:<strong>无反馈、无记忆</strong>。</p><hr /><h2 id="电路的设计方法">1. 电路的设计方法</h2><p><strong>方法就像是一纸蓝图，常用的组合电路、器件就像是依靠蓝图建造的幢幢房屋。</strong></p><p><strong>设计方法:</strong></p><blockquote><p>1逻辑抽象:分析事件因果，确定输入输出。一般将因作为输入，果作为输出2定义逻辑状态0/1的含义 3根据因果关系列写真值表 4将真值表转化为逻辑函数5选定器件类型 6根据实际，化简函数或变换成适当形式 7画出电路图8工艺设计</p></blockquote><h2 id="常用电路器件的罗列">2. 常用电路、器件的罗列</h2><p>这部分内容有迹可循，大多按照器件(每类器件选一到几个典型实际器件)<strong>功能/定义/目的，真值表，逻辑表达式，内部电路图，封装原件图，原件外部拓展</strong>等来介绍。</p><p><strong>常用器件:</strong></p><ol type="1"><li><strong>编码器:</strong>为了区分一系列不同事物，将其中每个事物用一个二进制代码表示，这就是编码。首先介绍<strong>普通编码器</strong>，之后由于普通编码器任何时刻只允许输入一个编码器信号，否则输出将发生混乱的缺点，将输入信号按照优先顺序排好队，改进为<strong>优先编码器</strong>，于是便允许同时输入两个以上的编码信号，容错率大大增加。</li><li><strong>译码器:</strong>将每个输入的二进制代码译成对应的输出高低电平信号或另外一个代码首先介绍结构简单的适用于大规模集成电路内部的<strong>二极管与门译码器</strong>，但其有输入电阻较低，输出电阻较高、输出的高低电平信号发生偏移等缺点。于是又介绍<strong>CMOS门译码器</strong>，最后介绍一些<strong>显示译码器</strong>(半导体数码管与液晶显示器)</li><li><strong>数据选择器:</strong>又称多路开关。在选择输入(地址输入)的作用下，从多个数据输入通道中选择某一通道的数据传至输出端。</li></ol><ul><li><p>此时，局部总结一下这三个器件的关系。我们其实可以把译码器(以74HC138为例)看做一个数据分配器，将片选输入端S1作为数据输入端，将A2A1A0作为地址输入端，功能是将S1输入端的信号输出到A2A1A0所选定的输出线上去。于是便有这样两种关系:</p><p><strong>(1)将S视为开关时，译码器与编码器可以看做互为反操作。</strong><ahref="https://www.zhihu.com/question/24369751"><strong>一组高低电平经过编码输出为二进制码，再经过译码又输出为一组高低电平</strong></a><strong>。</strong></p><p><strong>(2)将S视为数据时，译码器看作数据分配器，其与数据选择器可以看做互为反操作。1个数据经过数据分配输出为n个数据，再经过数据选择又输出为1个数据。</strong></p><p>最后，我想了很久，倒是没发现编码器与数据选择器的强烈联系。(因为我觉得按照不同角度来看，译码器可以看做分配器并分别与编码器与选择器互逆的话，编码器与选择器应该有某种角度的相似。)</p></li></ul><ol start="4" type="1"><li><strong>加法器:</strong>能够完成两数之间的相加运算，是构成运算器的基本单元。</li></ol><p>首先介绍极为简单的<strong>半加器</strong>，由于半加器不考虑来自低位进位的缺陷，将两个半加器和一个或门组成了可以考虑来自低位进位的<strong>全加器</strong>。由于全加器只能进行一位数据之间的运算，因此将多个全加器扩展为电路结构简单的可以进行多位数据加法的<strong>串行进位加法器</strong>，由于串行进位加法器运算速度慢，因此改进原理，设计成以提高电路复杂程度为代价的运算速度快的<strong>超前进位加法器</strong>。</p><ol start="5" type="1"><li><strong>数值比较器:</strong>比较两个数值的大小。</li></ol><p>首先介绍最简单的<strong>一位数值比较器</strong>，进而扩展为从高位到低位逐位比较的<strong>多位数值比较器</strong>。</p><h2 id="竞争-冒险现象">3. 竞争-冒险现象</h2><p>由于竞争而在电路输出端可能产生尖峰脉冲的现象的产生原因，检查方法，消除手段，至此组合逻辑电路到了尾声。</p><h2 id="总结">4. 总结</h2><p>从组合电路介绍的元器件来看，编码译码，数据选择，加法，比较等五花八门。但这些<strong>器件</strong>都脱离不开组合电路的设计方法，<strong>器件</strong>的灵魂都源于<strong>设计方法</strong>的宏伟蓝图。</p><p>这也使得，<strong>每个电路模块(器件)都可以仅用一张真值表来表达任何功能类型。</strong></p><p><strong>所以，依据真值表，我们可以把输出数据看成输入数据所对应的编码，那么所有组合电路模块的功能都可以看成是一种译码行为。所以我们可以把所有的组合电路的元器件归结为一般意义上的译码电路，称之为广义译码器。</strong></p><p>由此，在组合逻辑电路的范畴中，无论设计出何种功能迥异的器件，我们都可以直指其本质:</p><p><strong>按照真值表设计的“译码器”！</strong></p><h2 id="参考资料">参考资料</h2><p><strong>《数字电子技术基础》第五版，阎石主编，高等教育出版社</strong></p><p><strong>《数字电子技术基础》第二版，潘松、陈龙、黄继业编著，科学出版社</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;0. 序&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;我常常在想，数字电子技术和程序设计基础C是何等的相似，以至于我总想把数电理解为电路中的c语言。组合逻辑电路中的译码器，编码器，数据选择器等等可以看做C语言中的各种函数，电路输入即为函数形参，电路
      
    
    </summary>
    
      <category term="ee" scheme="https://silencht.github.io/categories/ee/"/>
    
      <category term="数字电子技术" scheme="https://silencht.github.io/categories/ee/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>触发器</title>
    <link href="https://silencht.github.io/wiki/ee/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>https://silencht.github.io/wiki/ee/数字电子技术/触发器/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序">0. 序</h2><blockquote><p>逻辑电路可分为“组合”与“时序”两大类。上节的介绍的“组合逻辑电路”，可高度概括为:<strong>无反馈、无记忆</strong>。自然，与其对应的“时序逻辑电路”便是：<strong>有反馈、有记忆</strong>。即时序逻辑电路的输出不仅取决于其<strong>当前</strong>的输入，还与<strong>过去</strong>的“状态”有关。</p></blockquote><h2 id="时序电路的灵魂记忆">1. 时序电路的灵魂——“记忆”</h2><p>设计电路，完成我们所需要的各种复杂功能，很多时候不可能进行<strong>一次操作</strong>就得到我们想要的结果。因此，期间要对很多中间结果进行“记忆”，这就<strong>需要一系列能够存储“状态”的电路模块</strong>。就像组合电路中的与或非门基本单元构成一样，这种具有<strong>存储记忆</strong>功能的模块是组成时序电路的基本单元。</p><p>存储元件的记忆功能决定了其必须具备两个最基本的特点：</p><ol type="1"><li>具有两个相对稳定的输出状态，表示逻辑状态0和1，即“<strong>双稳态</strong>”</li><li>能够通过外加触发信号，设置或改变元件的状态，即“<strong>可更改</strong>”</li></ol><p>满足这两个特点的<strong>最简单</strong>的存储电路结构之一，便是<strong>基本SR锁存器</strong>（Set-ResetLatch）</p><h2 id="基本记忆元件锁存器latch">2. 基本记忆元件——锁存器（latch）</h2><h3 id="基本sr锁存器-电平触发1">2.1 基本SR锁存器 电平触发<a href="#fn1"class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a></h3><p>首先介绍最简单的存储单元电路——<strong>基本SR锁存器</strong>的物理结构、四种输入下的工作原理，然后列出其逻辑功能的两种描述方法：</p><ol type="1"><li>状态转移真值表及特征方程</li><li>状态转移图和激励表</li></ol><blockquote><p>锁存器一个非常重要的特性是输出值只在输入值发生改变时，才会跟着变化。新的输出值的延迟仅受门电路传输延迟时间的影响。这是锁存器的“透明性”，所以有时称锁存器为<strong>透明锁存器</strong>（Transparentlatches）.</p></blockquote><p><strong>缺陷</strong>：S和R端同时有效时，输出的新状态不能确定，因此实际应用需要满足一定的约定条件。</p><h3 id="同步sr锁存器-电平触发">2.2 同步SR锁存器 电平触发</h3><p>而在实际应用中，常常<strong>需要使各基本SR锁存器的逻辑状态在同一时刻更新（多个锁存器需要同时动作）</strong>，为此在SR锁存器基础上引入一个同步信号CLK来控制电路，这个同步信号也称为使能信号、时钟脉冲，简称时钟。这种引入受时钟控制的锁存器便称为<strong>同步SR锁存器。</strong></p><p>通过物理结构和工作原理的介绍，得知：</p><ol type="1"><li>同步SR锁存器仅当CLK信号有效时，功能与基本SR锁存器相同（透明性：输出信号随时随输入信号状态的改变而跳转）</li><li>当CLK信号无效时，该锁存器状态一直保持不变</li></ol><p>在使用过程中，有时候<strong>还需要在CLK的有效电平到达之前预先将锁存器置成指定的状态。</strong>为此，在电路上往往还加入<strong>异步置1/置0端</strong>。</p><p>然后常规介绍其逻辑功能的两种描述方法。</p><p><strong>缺陷</strong>：S和R端同时有效时，输出的新状态不能确定，因此实际应用需要满足一定的约定条件。</p><h3 id="d锁存器-电平触发">2.3 D锁存器 电平触发</h3><p>同步SR锁存器的输入有两个端，但在一些系统中，数据只有一路信号，因而<strong>只需要一个数据输入端</strong>。最简单的解决办法就是将同步SR锁存器的S端作为数据输入端，然后用一个非门将S端信号反向后作为R端的输入信号。这种结构的电路就叫做<strong>D锁存器。</strong>D锁存器也有透明性。</p><p><strong>注</strong>：D锁存器不存在约束条件。</p><p>由同步锁存器的动作特点，可以想到，如果在CLK有效期间，输入信号的状态多次发生变化，那么锁存器的输出状态也将发生多次翻转，这种现象称为<strong>空翻</strong>。即“CLK有效电平持续期间”的透明性<strong>降低了触发器的抗干扰能力</strong>。</p><p>所以，<strong>为了提高锁存器工作的可靠性，增强抗干扰能力，改善空翻问题，希望器件在每个CLK周期内输出端的状态只能改变一次，由此便有了触发器。</strong></p><h2 id="同步的双稳态器件触发器flip-flop">3.同步的双稳态器件——触发器（Flip-Flop）</h2><p>先解决一个问题，</p><p><strong>问：锁存器和触发器有什么区别？</strong></p><p><strong>答：</strong>它们从一个状态变为另一个状态的方式不同。触发器在特定时段内对输入进行采样，并只在时钟信号所确定的时刻改变其输出；锁存器则不断监测其所有的输入，在任何时刻输出都可能发生变化<strong>。</strong>触发器利用了锁存器的存储原理，但是加上了触发功能，可以控制保存的时间。<strong>简单总结为：</strong></p><ul><li><strong>锁存器</strong>对时钟脉冲电平（有效电平期间）敏感，为<strong>电平触发</strong>方式，在有效电平期间都工作</li><li><strong>触发器</strong>对时钟脉冲边沿（上升沿下降沿）敏感，为<strong>脉冲和边沿触发</strong>方式，在边沿来临时变化状态</li></ul><p>在锁存器的基础上<strong>，</strong>设计出主从触发器、维持阻塞触发器、利用门电路传输延迟时间的边沿触发器以及利用二极管进行电平配置的边沿触发器等。</p><h3 id="主从sr触发器-脉冲触发">3.1 主从SR触发器 脉冲触发</h3><p>主从S-R触发器由两个同步SR锁存器<strong>级联</strong>（Cascade）而成。通过主从锁存器与时钟脉冲加上非门的级联，使得<strong>主触发器</strong>在脉冲有效期间采集S和R端的状态，在脉冲边沿到达之后，主触发器保存最后边沿瞬间的状态，然后将此状态传递给<strong>从触发器</strong>。</p><p>所以<strong>主从SR触发器每个CLK周期内输出端的状态只能改变一次</strong>。</p><p><strong>缺陷</strong>：</p><ol type="1"><li>主触发器本身是一个电平触发的S-R锁存器，所以主触发器依然有在时钟脉冲有效电平持续期间的“<strong>一次翻转<ahref="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>”问题</strong> ；</li><li>S和R端同时有效时，主触发器输出的新状态不能确定，而且<strong>输入信号仍需遵守一定的约束条件</strong>。</li></ol><h3 id="主从jk触发器-脉冲触发">3.2 主从JK触发器 脉冲触发</h3><p>为了主从S-R触发器即便出现S、R同时有效情况，依然能确定触发器的次态。即<strong>解决主从S-R触发器第二个缺陷</strong>，需要进一步改进触发器的电路结构。</p><p>将主从S-R触发器两个输出端“交叉”接回到输入端形成反馈，称之为：<strong>主从JK触发器。</strong></p><p>形成反馈回路的<strong>主从JK触发器</strong>在S和R端同时有效时，输出信号是上个输出信号的<strong>反相</strong>，而不是主从S-R触发器的未确定状态。</p><p><strong>缺陷</strong>：由主从S-R触发器改进不彻底带来的主触发器“<strong>一次翻转”问题</strong>。</p><p>主从结构的SR与JK触发器的 主触发器<strong>依然避免不了由锁存器原理天生的透明性带来的</strong>“<strong>一次翻转”问题。</strong></p><p><strong>为了进一步提高触发器的可靠性，增强抗干扰能力，彻底解决第一个缺陷——</strong>“<strong>一次翻转”问题</strong>（使得触发器的输出状态与CLK边沿之前和之后的输入状态的变化无关），设计出了各种<strong>边沿触发</strong>的触发器电路。</p><h3 id="主从边沿d触发器-边沿触发">3.3 主从边沿D触发器 边沿触发</h3><p>由两个D锁存器<strong>级联</strong>（Cascade）而成，为CMOS集成电路的主从结构的触发器<strong>。</strong></p><p>由于来自D锁存器改进，因此其<strong>天生没有约束条件的缺陷</strong>；而且由于边沿D触发器其输出和输入的直接对应关系，所以除了在边沿升降的建立时间内发生的输入变化将导致输出状态不可预知以外<strong>，没有</strong>“<strong>一次翻转”问题</strong>。</p><p>为了实现异步置位和复位功能，又引入了SD和RD置位端和复位端。</p><h3 id="维持阻塞d触发器-边沿触发">3.4 维持阻塞D触发器 边沿触发</h3><p>采用六个与非门组成，可以做到更快更小，为TTL型电路的维持阻塞结构的触发器。同样没有<strong>“一次翻转”问题</strong>。</p><h3 id="延迟边沿jk触发器-边沿触发">3.5 延迟边沿JK触发器 边沿触发</h3><p>即利用门电路传输延迟时间的边沿触发器就是边沿JK触发器。通过门电路的传输延迟时间，解决了“<strong>一次翻转”问题</strong>。</p><h2 id="总结与分类">4. 总结与分类</h2><p><strong>触发器的电路结构与逻辑功能之间不存在固定的对应关系；电路的触发方式由电路结构形式决定，所以电路结构与触发方式之间有固定的对应关系</strong>。</p><p><strong>凡是采用同步SR结构的触发器，一定是电平触发方式；凡是采用主从SR结构的触发器，一定是脉冲触发方式；凡是采用两个电平触发D触发器结构、维持阻塞结构或利用门电路延迟时间结构的触发器，一定是边沿触发方式。</strong></p><blockquote><p><strong>1.电平触发</strong>触发信号为有效电平（高或低）时，输入信号进入触发器电路，置触发器为相应状态。触发信号变为无效电平后，输入信号被封锁，触发器状态保持。状态随有效信号全过程改变。</p><p><strong>2.脉冲触发</strong>常用主从结构实现，即主、从触发器串联，触发信号反相。以正脉冲触发为例，当触发信号为高时，输入信号进入主触发器，置主触发器状态；触发器变低后，输入信号被封锁，主触发器状态保持，同时，从触发器的状态根据主触发器状态确定。信号只可能改变一次。</p><p><strong>3.边沿触发</strong> 指的是接收时钟脉冲CP的某一约定跳变(正跳变或负跳变)来到时的输入数据。在CP=l 及CP=0期间以及CP非约定跳变到来时，触发器不接收数据的触发器。仅与该时刻的状态有关。</p><p><ahref="https://blog.csdn.net/qq_40272342/article/details/92222062">原出处链接</a></p></blockquote><p>不管锁存器与触发器的触发方式如何，有无各种缺陷，只要触发器的逻辑功能（特性表）相同，就将之归为一类。通常将时钟控制的触发器分为SR触发器、JK触发器、D触发器、T触发器等几种类型。</p><p>从JK、SR、T三种触发器比较，可以看出JK触发器逻辑功能最强，包含了SR、T触发器的所有逻辑功能，因此使用SR和T触发器的场合可以完全用JK触发器替代。所以，目前生产的触发器定型产品中只有JK触发器和D触发器两大类。</p><p><strong>扩展</strong>：</p><ul><li><ahref="https://www.zhihu.com/question/21129356">JK触发器JK这两个字母有什么含义？</a></li><li><ahref="https://qastack.cn/electronics/79884/what-is-the-meaning-of-jk-flip-flops-j-and-k">JK触发器的J和K是什么意思？</a></li></ul><h2 id="导图">5. 导图</h2><p>暂略.</p><h2 id="参考资料">参考资料</h2><p><strong>1.《数字电子技术基础》第五版，阎石主编，高等教育出版社</strong></p><p><strong>2.《数字逻辑设计及应用》姜书艳主编，电子科技大学出版社</strong></p><p><strong>3.《数字逻辑设计学习指导与题解》曾洁、李会勇编著，电子科技大学出版社</strong></p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><liid="fn1"><p>【】后面的文字说明触发器的触发方式，触发方式的说明见第四部分——总结与分类中<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>主从JK触发器中也存在类似的问题，即CLK =1的全部时间里主触发器都可以接收输入信号。而且，由于Q 、Q'端接回到了输入门上， 所以在Q =0 时主触发器只能接受置1 输入信号，在Q =1时主触发器只能接受置 0 信号。其结果就是在CLK =1期间主触发器只有可能翻转一次，一旦翻转了就不会翻回原来的状态。但在主从SR触发器中，由于没有Q 、Q' 端接到输入端的反馈线，所以CLK=1期间S 、R状态多次改变时主触发器状态也会随着多次翻转。<a href="#fnref2"class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;序&quot;&gt;0. 序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;逻辑电路可分为“组合”与“时序”两大类。上节的介绍的“组合逻辑电路”，可高度概括为:&lt;strong&gt;无反馈、无记忆&lt;/strong&gt;。自然，与其对应的“时序逻辑电路”便是：&lt;strong&gt;有反馈、有记忆&lt;/
      
    
    </summary>
    
      <category term="ee" scheme="https://silencht.github.io/categories/ee/"/>
    
      <category term="数字电子技术" scheme="https://silencht.github.io/categories/ee/%E6%95%B0%E5%AD%97%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>电路原理脉络</title>
    <link href="https://silencht.github.io/wiki/ee/%E7%94%B5%E8%B7%AF/%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/"/>
    <id>https://silencht.github.io/wiki/ee/电路/电路原理/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h1id="线性电阻电路的分析方法和电路定理">线性电阻电路的分析方法和电路定理</h1><h2 id="装备">1.装备</h2><p>（注：从根本上说，电荷q和能量w是描述电现象的原始变量，为便于描述电路，从q和w引入电路变量i，u和p。其中电流、电压、功率的微积分定义式以及p=ui这四个式子是集总电路问题中最基本、普遍适用的公式，不论电路是线性的还是非线性的，时不变的还是时变的。）</p><p>电流i（<span class="math inline">\(i=\frac{dq}{dt}\)</span> ），电压u（<span class="math inline">\(u=\frac{dw}{dq}\)</span> ）</p><p>电荷q、能量w、磁链<span class="math inline">\(\psi\)</span>、时间t</p><h2 id="强化装备">2.强化装备</h2><p>电阻R（<span class="math inline">\(r=\frac{u}{i}\)</span>）&amp;电导G（<span class="math inline">\(g=\frac{i}{u}\)</span>）、功率P（<span class="math inline">\(p=\frac{dw}{dt} =\frac{dw}{dq}\cdot \frac{dq}{dt} =ui\)</span>）</p><h2 id="基本规则">3.基本规则</h2><p>（注：基尔霍夫定律与元件的VCR是解决一切集总电路的基本依据，理论上可以解决所有电路的电压电流问题）</p><p>基尔霍夫定律（KCL+KVL）、欧姆定律（$i= $）</p><h2 id="内容">4.内容</h2><p>（注1：尽管大多数专业书都厚如砖头，但是其中的各种繁杂公式可能追本溯源都是那么几个最基本最原始的公式再加上使用条件，适用范围、或者是与其他知识互相结合而推导出来的。按我的拙见，电路原理无乱如何也离不开欧姆与基尔霍夫两大定律，这两个定律就是支撑这门课程的树干一般的存在。）</p><p>（注2：电路分析三大基本方法：相量法，叠加方法（理论基础即叠加定理），分解方法（替代定理在这一方法中起着重要作用））</p><h3 id="电路等效变换">4.1 电路等效变换</h3><p>（两个单口（二端）网络N1和N2，如果N1端钮的VCR（电压电流关系）与N2端钮的VCR完全相同，则N2就和N1是相互等效的。至于N1和N2的内部结构可以完全不同。）</p><p>（串并联电阻，电源等效，戴维南、诺顿定理都是由前面的基本定义导出的，Y-<imgsrc="https://www.zhihu.com/equation?tex=%5Ctriangle%20"alt="" />变换是等效概念运用于三端网络的结果）。</p><p><strong>电阻等效变换</strong>： 串联（R总=R1+R2+R3+……）、并联（<imgsrc="https://www.zhihu.com/equation?tex=\frac%7B1%7D%7BR%7D%20%3D\frac%7B1%7D%7BR1%7D%20%2B\frac%7B1%7D%7BR2%7D%20%2B\frac%7B1%7D%7BR3%7D%20%2B"alt=" = + + +" />……）、Y-<imgsrc="https://www.zhihu.com/equation?tex=\triangle" alt="" /> 变换；</p><p><strong>电源等效变换</strong>：电压源和电阻串联与电流源和电阻并联电路之间的变换</p><h3 id="线性电阻电路分析方法">4.2 线性电阻电路分析方法</h3><p>（两类约束是解决集总电路的基本依据。但是由基本依据求解电路参数大多时候方程式的数量繁多，我们当然希望求解一个电路问题所需联立方程越少越好。联立方程是独立的。因此我们采取一些“前置、限制条件”总结归纳出几种求解电路的基本方法，由此求解具有某些特征的电路，运用不同的方法使得运算量大大减少。但是值得注意的是，我们在将方法改进的同时，也增添了许多限制因素，使得改进的方法拥有局限性，局限性即下图中的缺点，这同时也是我们在解题的同时应该注意的。）</p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/电路原理方法框架20200410173155.jpg" /></p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/2b支路电路法20200410173232.png" /></p><h3 id="叠加定理">4.3 叠加定理</h3><p>反应线性电路最根本性质的原理。在线性电路中，电路的响应（即任一支路的电压u或电流i）=比例常数<em>电路的激励（即作用的电路的电压源电压us或者电流源电流is）的叠加和。（举不恰当的数学例子，正比例函数y=k</em>x，k是常数，二次函数y=kx<em>x，第一个kx（与正比例函数中的k做比较）是变量。所以u=r</em>i类比正比例函数，p=ri*i类比二次函数。根据数学函数性质，p的求解就不符合“叠加”的要求，因为它不具有正比例函数那种线性关系。但是求解电路功率，可以先分别求出每一电源单独作用时对电路提供的功率，再进行叠加）</p><h3 id="戴维南与诺顿定理">4.4 戴维南与诺顿定理</h3><p>作用都是如何化简含源线性单口网络的。戴维南定理最大的功劳在于论证了含源线性单口网络，在端口处u、i为关联参考方向的前提下，其VCR具有u=Ai+B这一普遍形式。诺顿定理的功劳实质上是论证了这一形式的i=u/A-B/A。（其中B是开路电压，A是单口网络内部电源置零时的等效电阻）</p><h3 id="替代定理">4.5 替代定理</h3><p>在一个给定的电路中，若已知某一支路（或单口网络）的电压u和电流i，则该支路（或单口网络整体）可以用一个电压源u，或一个电流源i，或一个电阻R=u/i来置换。**注意，替代并非等效！！！这是两个不同的概念！！！（另一种定义表述方法：替代定理表述，在任意一个具有唯一解的电路中，若已知某支路k的电压uk、电流ik，并且该支路与电路中的其他支路不存在着耦合作用，则无论该支路由什么元件构成，都可以用一个端电压为us=uk的独立电压源或电流为is=ik的独立电流源来替代，电压源的极性与原支路电压极性相同，电流源的电流方向则与原支路电流方向相同。）</p><h3 id="替代定理与等效变换的区别与联系">4.6替代定理与等效变换的区别与联系</h3><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/1替代定理20200410173313.png" /></p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/2替代定理20200410173330.png" /></p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/3替代定理20200410173409.png" /></p><h3 id="替代定理基本要点">4.7 替代定理基本要点</h3><ol type="1"><li><p>应用替代定理的必要前提是应用该定理以前和之后所得到的电路中的所有支路电压和电流均应具有唯一解，这一点对非线性电路应特别加以注意</p></li><li><p>被替代支路k与电路中其他支路不可存在着耦合关系，即支路k中不能有其控制量在支路k以外的受控源，支路k以外的受控源，其控制量也不可在支路k中，支路k也不能与其以外支路存在着磁耦合关系。</p></li><li><p>替代定理适用于集总参数电路，他们可以是线性，非线性，时不变或时变的，在线性时不变的电路分析问题中，应用尤为普遍，当电路中的非线性元件的电压或电流已知时，可以应用替代定理，从而把非线性电路变为线性电路来求解。</p></li><li><p>应用替代定理不会改变原电路的任意支路电压或支路电流，即替代前后电路中各支路电压和电流均保持不变。替代定理不是电路的一种等效替换。替代定理和第二章的等效变换是不同的。例如若被替代电路的外部情况发生变化，则原替代可能会失效。</p></li></ol><h2 id="参考资料">参考资料</h2><ul><li>《电路分析 习题精解》孙瀚荪 编，科学出版社</li><li>《电子电气工程师必知必会》【美】Darren Ashby著，尹华杰译，人民邮电出版社</li><li>《电路原理》编者：于歆杰、朱桂萍、陆文娟，清华大学出版社，2007年3月第一次印刷</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1
id=&quot;线性电阻电路的分析方法和电路定理&quot;&gt;线性电阻电路的分析方法和电路定理&lt;/h1&gt;
&lt;h2 id=&quot;装备&quot;&gt;1.装备&lt;/h2&gt;
&lt;p&gt;（注：从根本上说，电荷q和能量w是描述电现象的原始变量，为便于描述电路，从q和w引入电路变量i，u和p。其中电流、电压、功率的微积分定
      
    
    </summary>
    
      <category term="ee" scheme="https://silencht.github.io/categories/ee/"/>
    
      <category term="电路" scheme="https://silencht.github.io/categories/ee/%E7%94%B5%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>相量法</title>
    <link href="https://silencht.github.io/wiki/ee/%E7%94%B5%E8%B7%AF/%E7%9B%B8%E9%87%8F%E6%B3%95/"/>
    <id>https://silencht.github.io/wiki/ee/电路/相量法/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>观看此文应具备基础知识：学习电路至正弦激励下动态电路的稳态分析一章、微积分基础、微分方程等</p></blockquote><blockquote><p>约定正文符号如下：（①②③…等为公式标识符；❶❷❸…等为文末注释标识符），相关量后面的‘h’是homogeneous通解的首字母，‘p’是particular特解的首字母，数学中的虚数i 为了避免在电路中与电流 i 混淆，所以虚数 i在此记作j，相量法中I头上的点由于这里不好编辑，所以用头上的~表示</p></blockquote><p>首先，先来看一道简单的电路习题：</p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/0相量法20200410173936.png" /></p><p><strong>题目：</strong> 如图<spanclass="math inline">\(Us\)</span>为正弦电压源，其值为<spanclass="math inline">\(Umsin｛wt+\varphi u｝\)</span>，其中<spanclass="math inline">\(\varphiu\)</span>是电压源的初相位。设电感初始值<spanclass="math inline">\(iL｛0^{-} ｝=0\)</span>安培，<spanclass="math inline">\(t=0\)</span>时，开关S从1合向2，求换路后电感电流<spanclass="math inline">\(iL｛t｝（t≥0）\)</span>.</p><p><strong>解1（</strong>对比之前直流电压源<spanclass="math inline">\(Us\)</span>做法，这是我一开始想到的方法，但是理解到后面，我认为这个方法应该是不通的）：</p><p><strong>一阶RC/RL电路经典法求解一般步骤：</strong></p><ol type="1"><li><strong>建立描述电路的微分方程</strong></li><li><strong>求齐次微分方程的通解和非齐次微分方程的一个特解</strong></li><li><strong>将齐次微分方程的通解与非齐次微分方程的的一个特解相加，得到非齐次微分方程的通解，利用初始条件确定通解的系数</strong></li></ol><p>1.描述换路后电路的微分方程为（实质为KVL）：</p><p><span class="math inline">\(L\frac{di_{L} }{dt} +Rdi_{L}=U_{m}sin｛wt+\varphi u｝\)</span>----①</p><p>令<span class="math inline">\(\frac{di_{L}}{dt} =y^{&#39;}\)</span>,<span class="math inline">\(iL=y\)</span>,代入①式有：</p><p><span class="math inline">\(Ly^{&#39;} +Ry=U_{m} sin｛wt+\varphiu｝\)</span> ----②</p><p>2.列写特征方程（P算子解法❶）：<spanclass="math inline">\(LP+R=0\Rightarrow P=-\frac{R}{L}\)</span>,</p><p>因而齐次微分方程的通解为：$yh=ke^{- t} $（其中k为待确定量），</p><p>自由项<span class="math inline">\(f｛t｝=U_{m} sin｛wt+\varphiu｝\)</span>，</p><p>设特解<span class="math inline">\(yp=A\)</span>，<spanclass="math inline">\(y^{&#39;}=0\)</span>（A为常数）代入原方程②，有</p><p><span class="math inline">\(yp=A=\frac{U_{m} }{R}sin[wt+\varphi u]=I_{m} sin[wt+\varphi u]\)</span>,</p><p>3.方程通解为：<span class="math inline">\(y=yh+yp=i_{L}[0^{+}]=k\cdot e^{-\frac{L}{R} \cdot t} +I_{m} sin[wt+\varphiu]\)</span>，</p><p>代入初始条件：<span class="math inline">\(y|_{t=0^{+} } =i_{L}[0^{+}]=i_{L}[0^{-}]=0\)</span>,</p><p>求得系数<span class="math inline">\(k=-I_{m} sin[wt+\varphiu]\)</span>，</p><p>最后可求得题目结果：</p><p>$i_{L}[t]=I_{m}sin[wt+u]-I_{m}sin[wt+u]e^{-t } $③(t≥0)</p><p>乍一看似乎并没有错，但这个式子应该是错误的。学过高中物理知识即可知道，电感对于交流电是有阻碍作用的（通直流阻交流），这个阻碍作用在R中并不能体现出来（因为电阻的电阻为R，也就变相说明电路中阻碍电流的只有线性电阻），而且在学习了后续课程之后可以知道，电感电容这类电学器件是有感抗与容抗的<em>【在求解一阶动态电路三要素法中：时间常数RiC，L/Ri中Ri的含义是从电路的储能原件两端看进去的戴维南等效电阻】</em>；</p><p>式子中的<span class="math inline">\(\varphiu\)</span>也是错误的，学过后续课程之后也可以知道，<ahref="http://wenku.baidu.com/link?url=HPYHCgGlSfH-NWasUNfFEW3Axamq_IbyXEORx5yv3RmJLq393cCccFIDtmuaNRM941OTAdw1XILdHzLxoA61A48dV8u_KnGZOCk_dYRBXd_">电感上的电流是落后与电压90°相位的（同样地，电容上的电流也是超前电压90°相位的）</a>。</p><p>所以这个方法行不通（可能有解决、改进的办法，但是我没有想出）。</p><p><strong>解2（</strong>此为《电路原理》书中解法，有删减、补充、改动<strong>）：</strong></p><p>1.描述换路后电路的微分方程为：$L +Ri_{L}=U_{m}sin[wt+u] $----④</p><p>2.齐次微分方程的通解仍为指数形式：<span class="math inline">\(i_{Lh}=Ae^{-\frac{R}{L} \cdot t}（t≥0）\)</span></p><p>非齐次微分方程的一个特解与外加激励应具有同样的形式，设为：</p><p><span class="math inline">\(i_{Lp} =I_{m} sin[wt+\varphi i]（t≥0）\)</span></p><p>将上式代入式子④，有：</p><p><span class="math inline">\(wLI_{m}cos[wt+\varphii]+RI_{m}sin[wt+\varphi i]=U_{m}sin[wt+\varphi u]\)</span>,</p><p>对等号左边进行三角变换（<ahref="http://baike.baidu.com/link?url=tVXNP_sCZzR1wdbkNwroyqy23dWHr04HngwbNf09CYo-BNQFnsd3noG625AUM55sIXgcEqNSwpaJeRO3VWNZgq">辅助角公式❷</a>）：</p><p><span class="math inline">\(\sqrt{[wL]^{2} +R^{2} } \cdot I_{m}sin[wt+\varphi i+\varphi ]=U_{m} sin[wt+\varphi u]\)</span>⑤,</p><p>其中<span class="math inline">\(\varphi\)</span>称为电路的<strong>阻抗角</strong>，$tan= $，</p><p>比较⑤中等号左右两边的对应项：</p><p><span class="math inline">\(\sqrt{[wL]^{2} +R^{2} } \cdotI_{m}\Leftrightarrow U_{m}\)</span> 与<spanclass="math inline">\(sin[wt+\varphi i+\varphi ]\Leftrightarrowsin[wt+\varphi u]\)</span>，</p><p>可求得：$I_{m} = <span class="math inline">\(与\)</span>i=u-=u-arctan$，</p><p>因此，式子④的一个特解为：<span class="math inline">\(i_{Lp}=\frac{U_{m} }{\sqrt{[wL]^{2} +R^{2} } } sin[wt+\varphi u-\varphi](t≥0)\)</span>，</p><p>3.电感电流的全响应为：<span class="math inline">\(i=i_{Lh}+i_{Lp}=Ae^{-\frac{R}{L} \cdot t}+\frac{U_{m} }{\sqrt{[wL]^{2} +R^{2} }} sin[wt+\varphi u-\varphi ]（t≥0）\)</span></p><p>代入初始条件：<span class="math inline">\(i_{L} [0^{+} ]=i_{L} [0^{-}]=0\)</span>，</p><p>有：<span class="math inline">\(A+\frac{U_{m} }{\sqrt{[wL]^{2} +R^{2}} } sin[\varphi u-\varphi ]=0\Rightarrow A=-\frac{U_{m} }{\sqrt{[wL]^{2}+R^{2} } } sin[\varphi u-\varphi ]\)</span>,</p><p>因此，电感电流为：</p><p><span class="math inline">\(i_{L} =\frac{U_{m} }{\sqrt{[wL]^{2}+R^{2} } } sin[wt+\varphi u-\varphi ]-\frac{U_{m} }{\sqrt{[wL]^{2}+R^{2} } } sin[\varphi u-\varphi ]e^{-\frac{R}{L} \cdott}\)</span>⑥（t≥0）.</p><p>【总结】</p><p>1.比较解1、解2结果③（现将Im按照解1变形）与⑥：</p><p><span class="math inline">\(i_{L}[t]=\frac{U_{m} }{R} sin[wt+\varphiu]-\frac{U_{m} }{R}sin[wt+\varphi u]\cdot e^{-\frac{R}{L}t }\)</span>③</p><p><span class="math inline">\(i_{L} =\frac{U_{m} }{\sqrt{[wL]^{2}+R^{2} } } sin[wt+\varphi u-\varphi ]-\frac{U_{m} }{\sqrt{[wL]^{2}+R^{2} } } sin[\varphi u-\varphi ]e^{-\frac{R}{L} \cdot t}\)</span>⑥</p><p>可见，解1后面分析是正确的：</p><p>◆sin[这里的值是有相位变换的]</p><p>◆比较分子$U_{m} <spanclass="math inline">\(下面的分母，可见解1中的R的确不是单纯的电路电阻值。含储能元件的此电路中对电流阻力的表现形式是这样的：\)</span>{} $。</p><p>可预见的是：电感元件在电路中对电流阻力作用是与电源的角频率w与其本身电感值L共同决定的。这些便是接下来的感抗方面的内容了。</p><p>2.通过解2我们发现：上例仅仅是最简单的一阶动态电路，其复杂程度已经令人咂舌。</p><p>可以预见，如果在各种大型电路网络中利用此类方法求解，是比较困难的（请允许我用了“比较”这个词汇，鄙见：因为在计算机飞速发展的时代，求解一些普通点的微分方程似乎并不是什么难事？）。由此：</p><p>我们不禁想象，是不是有一种方法，可以<strong>不用求解微分方程，仅仅像之前直流电源那样，利用线性方程求解</strong>，那该多好啊？</p><p>于是，天才工程师<ahref="http://baike.baidu.com/link?url=uIj8VldxFKt2c00E6Wgq-SaWEAmbtOA03IMmJcRA1XOQECLTBrv0xQOcaWDHj0T-01xwmr51M68xBZrCzqj0ea">斯泰因梅茨</a>疯狂的在电压电流上加了个点，一个伟大的方法诞生了——<strong>相量法</strong>！</p><h2 id="开始">开始</h2><p>我们盯住上述题目中：电压源<span class="math inline">\(U_{s}=Umsin｛wt+\varphi u｝\)</span>以及用微分方程求解电路过程中的各个方程式。其中有各种各样的已知量、未知量：电压、电流的幅值$U_{m}/I_{m} <span class="math inline">\(，初相角\)</span>u/i<spanclass="math inline">\(，以及激励的频率\)</span>w$等等。</p><p>帅的人可能已经发现：无论是题设、过程、结果，我们如此多的方程式中只要含有三角函数的式子，其中的频率无一不是<spanclass="math inline">\(w\)</span>！显然，在给定频率的正弦电压电源中，其<strong>电路的频率保持不变</strong>。可以预见的，正弦电流电源同样如此。</p><p>那么，我们想：我们在题目中关注的量（也可以理解为：其中参与方程式变换的量）一般为三个：电压、电流的幅值$U_{m}/I_{m} <span class="math inline">\(；初相角\)</span>u/i<spanclass="math inline">\(；激励的频率\)</span>w<spanclass="math inline">\(。既然电路中自始至终频率\)</span>w$死活不变【可以理解为：方程式中参与实际运算的量仅仅为幅值与初相角】，那么我们是不是可以残忍的抛弃这个好吃懒做的家伙、仅仅关心真正的两位劳模：幅值与初相角呢？</p><p>如何将频率<code>*</code>时间从三角函数的大别墅【在此将三角函数如<spanclass="math inline">\(sin[wt+\varphi]\)</span>中的[]戏称为别墅，其中的频率<code>*</code>时间、初相角为别墅中的成员】中拖出来扔到大街？在抛弃频率<code>*</code>时间这个好吃懒做的家伙之后，运算过程能否得以简化？让我们拭目以待。</p><p>常规的三角函数变换手段似乎难以将别墅中阴险的频率小伙子诱骗出来，是时候发大招了——欧拉的愤怒！</p><p><strong>欧拉公式❸【请阅读下文之前务必阅读此注释，重要！重要！重要！】：</strong></p><p><span class="math inline">\(e^{jx} =cosx+j\cdot sinx\)</span></p><p>仔细观察公式，将之与$ Umsin｛wt+u｝$比较、分析。还是没有启发？</p><p>那么我们将欧拉公式进一步变换：<spanclass="math inline">\(e^{j[wt+\varphi ]} =cos[wt+\varphi ]+j\cdotsin[wt+\varphi ]\Rightarrow e^{jwt+j\varphi } =cos[wt+\varphi ]+j\cdotsin[wt+\varphi ]\)</span>，</p><p>再变：<span class="math inline">\(e^{jwt } \cdot e^{j\varphi }=｛coswt+jsinwt ]\cdot ｛cos\varphi +jsin\varphi｝\)</span>，现在呢，是不是有点眉目了？</p><p>我们思考：正弦电压源表达式三角函数大别墅中的两个成员不就可以<strong>运用欧拉公式变换为两个e指数函数的乘积形式</strong>，<strong>从而</strong>将之从别墅中<strong>分离</strong>吗？</p><p>按照这个思路，根据：<span class="math inline">\(k\cdot sinx=k\cdotIM[e^{jx} ]=IM[k\cdot e^{jx} ]\)</span>，</p><p>于是，电流源<span class="math inline">\(i=I_{m} sin[wt+\varphii]\)</span>可以表示为：<span class="math inline">\(I_{m} \cdotIM[e^{j[wt+\varphi i]} ]=IM[I_{m} \cdot e^{j[wt+\varphi i]}]\)</span>⑦，</p><p>高中的时候（嗯，电路原理课程前面也推到过的，在此不细说），我们就知道：正弦交流电的幅值是有效值的$<span class="math inline">\(倍，即\)</span>I_{m} = I$。</p><p>⑦式又可以表示为：<span class="math inline">\(IM[\sqrt{2} I\cdote^{j\varphi i}\cdot e^{jwt} ]\)</span>⑧，现在总算将<spanclass="math inline">\(IM[ e^{jwt} ]\)</span>，也就是<spanclass="math inline">\(wt\)</span>这个家伙拖出来了！【——来人呐，帮朕把这个刁民拖出去，打一百二十大板！——嗻！】</p><p>再继续之前，还要介绍一个概念：<strong>旋转因子❹。</strong></p><p>那让我们乘胜追击，单独看剩下的两个劳模（幅值与初相角）：<spanclass="math inline">\(\sqrt{2} I\cdot e^{j\varphii}\)</span>，乘号$$左侧代表幅值，右侧代表初相角。</p><p>那么我们之后的运算全都建立在⑧式中的两个劳模 <spanclass="math inline">\(I\cdot e^{j\varphii}\)</span>，等到运算完成之后，再把<spanclass="math inline">\(wt\)</span>这个家伙塞进来，反向逆推算子，不就可以得到结果了吗？</p><p>为了简便起见，我们约定：<span class="math inline">\(\tilde{I} =I\cdote^{j\varphi i} =I\cdot ∠\varphi i\)</span></p><p>小结：</p><p><span class="math inline">\(I_{m} sin[wt+\psi i]=IM[\sqrt{2}I\cdote^{\psi i} \cdot e^{jwt} ]\)</span>,<span class="math inline">\(e^{jx}=cosx+j\cdot sinx\)</span></p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/1相量法20200410173718.jpg" /></p><h2 id="结束">结束</h2><p><strong>1.</strong>将<span class="math inline">\(i（t）\)</span>变成$$的过程称为<strong>从时域到频域的相量变换：</strong> <spanclass="math display">\[i[t]=I_{m} cos[wt+\varphi ]\Rightarrow i[t]=IM[I_{m}e^{j[wt+\varphi ]}]\Rightarrow \tilde{I} =I_{m}e^{j\varphi } \Rightarrow \tilde{I}=I_{m}\]</span> <strong>2.大体流程图：</strong></p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/2相量法20200410173750.jpg" /></p><p><strong>3</strong>.以下是知友【<ahref="https://zhuanlan.zhihu.com/people/b635647b41a2edc8634bed7606c83569"><spanclass="citation" data-cites="frente">@frente</span> nemo</a>】对相量法的相关理解，供参考：</p><blockquote><p>我想他用的就是以不变应万变的道理吧，所有量都以一个频率在变，其效果就更想对静止差不多了吧，但是他们对电容和电感产生了新的影响，因为他们的电流电压之间有微分和积分的关系。在新的思路下你可以将电感变成jwl，将电容变成1/jwc，接下来你又改思考为什么可以这样变。这是在极坐标下的电流电压关系可以推导出来的。你要再追根溯源说，为什么可以用复数来代替正弦？那是因为欧拉公式将正弦转化成了复数表达。你还问欧拉公式又是什么？它是迈克劳林（泰勒）公式得到的。你必须不断地思考，不断地提问才能明白这一起是怎么回事。</p><p>链接：https://www.zhihu.com/question/19851763/answer/37465084</p></blockquote><p>4.接下来，按照思路，可以推导“元件约束与基尔霍夫定律下的相量形式”，然后就可以求解相关习题了！~</p><p>最后引用这位知友的一句话作为本文的结束：</p><blockquote><p>伟大的人类用自己的智慧把交流量头上打个点，然后一切又归于平静了。</p></blockquote><h2 id="注释">注释</h2><p><em>【约定注释部分符号如下：（ⅠⅡⅢ…等为公式标识符】</em></p><p>❶列写特征方程求解一阶微分方程（在我看来，电路求解中的P算子解法接近于高等数学微分方程的特征方程解法，三要素解法接近于高等数学中的通解公式解法。）</p><p>下面给出【高等数学一阶微分方程知识以及其特征方程解法】与【直流电压源动态电路中P算子解法】的互相对照：</p><p><strong>高等数学一阶线性微分方程基础知识：</strong></p><p>对于形如：</p><p><imgsrc="https://pic1.zhimg.com/c500ff3b97aa039ad927a2d3769cc4b0_b.png" /></p><p>----Ⅰ的方程，叫做<strong>一阶线性微分方程</strong>。</p><p>如果对于Ⅰ中，若：</p><p><imgsrc="https://pic4.zhimg.com/55ada3580653136fecd8c71c8eb9806f_b.png" /></p><p>，那么方程：</p><p><imgsrc="https://pic1.zhimg.com/83cef79fd8e2c2ebc00fdd91c76d8024_b.png" /></p><p>----Ⅱ称为<strong>齐次</strong>的；否则，方程Ⅰ称为<strong>非齐次</strong>的。</p><p><strong>一阶非齐次线性微分方程特征方程解法（部分过程参考自文献）：</strong></p><blockquote><p>如果一阶常系数非齐次线性微分方程的一般形式是：$my^{'} +py=qe^{x} $(m、p、q为常数，一般情况下<span class="math inline">\(\lambda=0\)</span>)。</p><p>对于此方程,一般先求出对应的齐次方程的通解,再用常数变易法求原方程的通解。对应的齐次方程的通解：列写对应特征方程<spanclass="math inline">\(mr+p=0\)</span>（r为未知量），求解得出$r=- <spanclass="math inline">\(，则齐次通解为：\)</span>yh=k e^{-x }$，下面求非齐次特解。 特解应设为<span class="math inline">\(yp=x^{k}\cdot e^{\lambda x} Rm[x]\)</span>,求解步骤：</p></blockquote><ol type="1"><li><p><spanclass="math inline">\(Rm[x]\)</span>是与q同次的多项式，因<spanclass="math inline">\(q\)</span>为常数，所以<spanclass="math inline">\(Rm[x]\)</span>取<spanclass="math inline">\(x=1\)</span>的常数，在此我们约定为常数A</p></li><li><p><span class="math inline">\(\lambda=0\)</span>与r对照比较，一般情况下<span class="math inline">\(\lambda\ne r\)</span>，因此<span class="math inline">\(\lambda=0\)</span>不是特征方程的根，所以特解表达式中k取0</p></li><li><p>把特解表达式（此时特解表达式应为<span class="math inline">\(yp=A\)</span>，<span class="math inline">\(y^{&#39;}=0\)</span>[常数A求导为0]）代入（需要求导的求导之后代入）一般形式的原方程（此时原方程应为<spanclass="math inline">\(my^{&#39;} +py=q）\)</span>，得：</p><p><span class="math inline">\(pA=q\Rightarrowyp=A=\frac{q}{p}\)</span></p></li></ol><p>原方程的通解等于其对应的齐次方程的通解与其一个特解的和：</p><p><span class="math inline">\(y=yh+yp=k \cdot e^{-\frac{p}{m}x}+\frac{q}{p}\)</span></p><p>❷在数学中，辅助角是指三角变换中收缩变换的代表<strong>辅助角公式</strong>：<spanclass="math inline">\(asinx+bcosx=\sqrt{(a^2+b^2)} sin(x+\varphi)\)</span>，其中<span class="math inline">\(tan\varphi=\frac{b}{a}\)</span></p><p><strong>❸欧拉公式与复数：</strong></p><p>在介绍欧拉公式之前，先要说明的是虚数。经历过高考的我们都知道，复数这个词可以用一个形如<spanclass="math inline">\(a+jb\)</span>的整体来表示，这里a、b都是通常的实数且b≠0，而<spanclass="math inline">\(j\)</span>和通常实数不同，具有<spanclass="math inline">\(j^{2}=-1\)</span>这个性质。虽然看起来很难理解，但是在此只能强迫读者默认这个事实。如果想对复数有更深入的认识，不妨读一下《复分析可视化方法》这本书。</p><p><strong>1. 复数及其运算：</strong>设A为一复数，a和b分别是它的实部和虚部，则复数A的代数形式（又称直角坐标形式）为：<spanclass="math inline">\(A=a+jb\)</span>，上式中，<spanclass="math inline">\(j=\sqrt{-1}\)</span> 为虚数单位。</p><p><strong>2.复数的</strong>实部和虚部分别用下列<strong>符号表示</strong>：<spanclass="math inline">\(Re[A]=a,Im[A]=b\)</span>。在此不用纠结于Re与Im，可以看作一种算子（就像高中做的那些新定义题目一样，如：定义a#b=ab，那么我们遇到2#3就等于2×3=6）。</p><p><strong>【但是为了防止算子<spanclass="math inline">\(Im\)</span>与电流幅值</strong><spanclass="math inline">\(I_{m}\)</span><strong>混淆，在本文中我们约定用<spanclass="math inline">\(IM\)</span>做取虚部算子写法】</strong></p><p>复数经过它们的运算后分别得到该复数的实部和虚部。</p><p>复数A还可以表示为三角形式：<spanclass="math inline">\(A=|A|[cos\Theta +jsin\Theta ]\)</span>，</p><p>根据欧拉公式又可进一步写成指数形式：$A=|A|e^{j} $，</p><p>还可以改写为极坐标形式：<spanclass="math inline">\(A=|A|∠\Theta\)</span> 。</p><p>其中：若$A=a+jb=|A|∠$，则 <span class="math inline">\(a=|A|cos\Theta,b=|A|sin\Theta\)</span> ,<span class="math inline">\(|A|=\sqrt{a^{2}+b^{2} } ,\Theta =arctan[\frac{b}{a} ]\)</span></p><p><strong>几何表示</strong>：</p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/3相量法20200410173815.png" /></p><p><strong>3.复数的运算：</strong>【图片来源：《电路原理》P390-392】</p><p><imgsrc="https://pic1.zhimg.com/d7407e50ddee346fcdaacf43e831c850_b.png" /></p><p><imgsrc="https://pic3.zhimg.com/b0dbd0472cbdbe4571e8e4a8cbc41b9e_b.png" /></p><p><imgsrc="https://pic1.zhimg.com/ac978ab1d88c4924035f5f45c24eae64_b.png" /></p><p><imgsrc="https://pic1.zhimg.com/a97c023835d0b4282d6ac81d28cf9dc0_b.png" /></p><p><strong>文字浓缩：</strong></p><ul><li><strong>两个复数之和A+B由通常向量加法的平行四边形法则给出</strong></li><li><strong>两个复数的乘法：AB之长是A之长与B之长的乘积，AB的幅角是A与B的幅角之和</strong></li></ul><p><strong>4. 欧拉公式的猜想式推导（非严格）：</strong> 设<spanclass="math inline">\(f(x)=\cos x+j\sin x\)</span>,有：<spanclass="math inline">\(f(x)f(y)=f(x+y)\)</span>， 猜知：<spanclass="math inline">\(f(x)\)</span>为指数函数，设： <spanclass="math inline">\(f(x)=e^{kx} =\cos x+j\sinx\)</span>（其中k为常数，j为虚数单位） 两边求导，得: <spanclass="math inline">\(k\cdot e^{kx} =-\sin x+j\cos x=j^{2}\sin x+j\cosx=j[\cos x+j\sin x]\)</span>， 其中[]中便是<spanclass="math inline">\(e^{kx}\)</span>,即：<spanclass="math inline">\(k\cdot e^{kx} =j\cdot e^{kx}\)</span>， 消去<spanclass="math inline">\(e^{kx}\)</span>（其不为0）, 则<spanclass="math inline">\(k=j\)</span>, 因此我们有：<spanclass="math inline">\(e^{jx} =\cos x+j\sin x\)</span></p><p><strong>5.</strong></p><p><ahref="http://baike.baidu.com/link?url=0PTGJ6d5x50smMrxUugmumGqxjaJG9blyMs2Qa7t1hE-MIsFOZDZeew74UE8KKzi3i5tWDhOMJ4O9-wvbSWP2a">欧拉公式</a></p><p>更加有趣的是，在《复分析》这本书的注释中，有这样一句话：</p><blockquote><p>我们相信，现在的证法支持一个观点，即这种恒等式只是复数乘法的简单法则的复杂化了的表现形式。</p></blockquote><p>被誉为<strong>上帝公式</strong>的欧拉公式，仅仅是复数乘法法则的表现形式！有兴趣的可以读一读这本书的前面几章内容~</p><p><strong>❹旋转因子：</strong></p><p>我们假设初值：<span class="math inline">\(A=|A|\cdot e^{j\Theta}\)</span> <strong>，</strong>如图：</p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/4相量法20200410173836.png" /></p><p>然后做运算：<span class="math inline">\(A\cdot e^{j\psi } =|A|\cdote^{j\Theta } \cdot e^{j\psi }=|A|\cdot e^{j[\Theta +\psi ]}\)</span><strong>，</strong></p><p>我们可以想象，A的初值是A的绝对值乘e的<spanclass="math inline">\(j\Theta\)</span>次方，当它再乘e的$j$次方时，几何直观看来为：</p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/5相量法20200410173853.png" /></p><p><strong>总结为：任何一个复数乘以<span class="math inline">\(e^{j\psi}\)</span></strong><strong>之后，等于这个复数模不变，相角逆时针增加<spanclass="math inline">\(\psi\)</span></strong> <strong>度</strong></p><p><span class="math inline">\(e^{jwt}\)</span><strong>是以角速度w逆时针方向旋转的单位长度的有向线段，称之为旋转因子。</strong></p><h2 id="参考文献">参考文献</h2><ul><li>《一阶常系数线性微分方程的某些求法的比较》，作者：汤文菊、胡荣、简志宏.文章编号:1008-8458(2005)04-0009-02</li><li>《高等数学》第七版上册，同济大学数学系编，高等教育出版社，2015年6月第五次印刷</li><li>《电路原理》编著：于歆杰、朱桂萍、陆文娟，清华大学出版社，2007年3月第一次印刷</li><li>《工程电路分析》（engineering circuitanalysis）第七版，作者：【美】William H. Hayt，Jr. Jack E.KemmerlySteven M.Durbin 编著 ，周玲玲、蒋乐天等译.，电子工业出版社，2007年7月第一次印刷</li><li>《复分析 可视化方法》（visual complex analysis）作者：【美】TristanNeedhan 著，齐民友译，人民邮电出版社，2009年7月北京第一次印刷</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;观看此文应具备基础知识：学习电路至正弦激励下动态电路的稳态分析一章、微积分基础、微分方程等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;约定正文符号如下：（①②③…等为公式标识符；❶❷❸…等为文末注释标识符），相关量后面的‘
      
    
    </summary>
    
      <category term="ee" scheme="https://silencht.github.io/categories/ee/"/>
    
      <category term="电路" scheme="https://silencht.github.io/categories/ee/%E7%94%B5%E8%B7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>视觉SLAM:搞定坐标系、三角测量、PnP</title>
    <link href="https://silencht.github.io/wiki/robot/note/%E8%A7%86%E8%A7%89SLAM%E6%90%9E%E5%AE%9A%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8FPnP_%E8%A1%8C%E7%9F%A5SLAM/"/>
    <id>https://silencht.github.io/wiki/robot/note/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h1id="视觉slam搞定坐标系三角测量pnp">视觉SLAM:搞定坐标系、三角测量、PnP</h1><p><strong>Author:</strong> [行知SLAM]</p><p><strong>Link:</strong> [https://zhuanlan.zhihu.com/p/80921759]</p><h2 id="正文">1.正文</h2><p>四个坐标系：世界坐标系、相机坐标系、图像坐标系、像素坐标系。</p><p>世界坐标系：机器人或相机运动过程中，肯定需要知道它的位置，因此需要设定世界坐标系，认定固定不动，作为参考坐标系，描述世界中的任何一点P（Xw,Yw,Zw)。</p><p>相机坐标系：相机或机器人运动的一个坐标系，通过世界坐标系的变换（旋转R,平移T）计算得到。因此主要是将世界坐标系描述的点坐标P（Xw,Yw,Zw)转换成相机坐标系下描述P（Xc,Yc,Zc)，方便计算得到在成像坐标系的坐标。</p><p>图像（成像）坐标系：描述点在图像坐标系的成像点位置。</p><p>像素坐标：在相机中得到的是一个像素，因此主要将图像坐标系的点转换成像素坐标系下。</p><p><strong>1.1.将世界坐标系转换得到相机坐标系</strong></p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-ae9e4fa1277b0391a87a7e4d0f5a6468_r.jpg" /><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-1359ecc81b77c1d15002626a498f7cd3_r.jpg" />旋转 平移</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-4f6a8a9ea9616815aed638e808710b0f_r.jpg" />旋转矩阵：R，三维旋转矩阵构成特殊正交群SO(3)。知道它的物理意义就是表示旋转即可。</p><p>变换矩阵：T,旋转+平移.变换矩阵构成特殊欧式群SE(3)。</p><p>旋转向量（轴角）：一个旋转轴+一个旋转角，外积表示旋转，</p><p>欧拉角：绕z轴旋转，得到偏航角yaw,绕旋转之后Y轴旋转，得到俯仰角pitch,绕旋转之后X轴旋转，得到滚转角roll。</p><p>四元数，q=a+bi+cj+dk，类比虚数，同样用来表示旋转。</p><p>a.欧式变换：有6个自由度，在变换前后，保持不变的性质是长度、夹角、体积。</p><p>b.相似变换：有7个自由度，在变换前后，保持不变的性质是体积比。</p><p>c.仿射变换：有12个自由度，在变换前后，保持不变的性质是平行性、体积比。</p><p>d.射影变换：有16个自由度，在变换前后，保持不变的性质是接触平面的相交和相切。</p><p>计算旋转矩阵</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-9d1b08866587d26e3954ff16656e8328_r.jpg" /><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-79f44af37ab7e960f762ea13e340ea37_r.jpg" />旋转矩阵有9个量，3*3.</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-b27812cd1663a5c55f4a2b43ce8017fd_r.jpg" /><strong>1.2相机坐标系与图像坐标系</strong></p><p>从相机坐标系到图像坐标系，属于透视投影关系，从3D转换到2D。</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-1359ecc81b77c1d15002626a498f7cd3_r.jpg" /></p><p>此时P点已由上面经过世界坐标系转换成相机坐标系下表述P(Xc,Yc,Zc)。</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-328fe56d856e8d3be5a3664e947d597b_r.jpg" /><strong>1.3图像坐标系与像素坐标系</strong></p><p>像素坐标系和图像坐标系都在成像平面上，只是各自的原点和度量单位不一样。图像坐标系的原点为相机光轴与成像平面的交点，通常情况下是成像平面的中点或者叫principalpoint。图像坐标系的单位是mm，属于物理单位，而像素坐标系的单位是pixel，我们平常描述一个像素点都是几行几列。所以这二者之间的转换如下：其中dx和dy表示每一列和每一行分别代表多少mm，即1pixel=dx mm .</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-1359ecc81b77c1d15002626a498f7cd3_r.jpg" /><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-cc629f6426770774344f75b8ba516e3d_r.jpg" />那么通过上面四个坐标系的转换就可以得到一个点从世界坐标系如何转换到像素坐标系的。</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-88114f33783c08a711b507d8d0c8e3ec_b.jpg" />高翔十四讲简洁描述：K表示相机内参，T表示相机外参，即旋转平移。</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-3fc23445859015c3a5e07631c5d6d5de_r.jpg" /><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-7c10ee9a420b2dcee73bb5f226c3b12a_r.jpg" /><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-83223fbf8f980069874b3a4baa074def_r.jpg" /><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-59ae5d123135254bada20e877854227f_b.jpg" /></p><p>其中相机的内参和外参可以通过张正友标定获取（戳这里查看张正友标定的资料)。通过最终的转换关系来看，一个三维中的坐标点，的确可以在图像中找到一个对应的像素点，但是反过来，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-9a3b41b5cf4500518a0397ad06c301cd_b.jpg" /><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-c7fd3481997eb55590937aef898dfd1d_b.jpg" /></p><p><strong>2.视觉里程计</strong></p><p>视觉里程计的任务是估算相邻图相间的运动，以及局部地图的样子。由上面的像素坐标系间的关系，我们可以通过对极约束、三角测量、pnp求得相机的运动。</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-1359ecc81b77c1d15002626a498f7cd3_r.jpg" /></p><p><strong>2D-2D对极约束</strong></p><p>预备知识：</p><blockquote><p>A为n维方阵，若有A'=-A，则称矩阵A为反对称矩阵。对于反对称矩阵，它的主对角线上的元素全为零，而位于主对角线两侧对称的元反号。<br />外积：axb=a<sup>b。将</sup>记成一个反对称符号，这样就把外积axb写成了矩阵与向量的乘法a^b。<br />向量的外积结果就是一个和原来两个向量垂直的向量，更为熟知的叫法是法向量，该向量垂直于a和b向量构成的平面。<br />点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影。<br />对极约束求相机运动，由于我们通过特征点匹配确定了像素点p2的位置，可以推断p的空间位置，以及相机的运动。</p></blockquote><p>世界坐标：</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-e45180cc45bf63b736bff35b15889182_b.jpg" />两个像素点p1,p2的位置：</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-691c3853ac014e2375165804d84e3abf_b.jpg" /><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-4c86f57f6ce491dd1dcfa62795e95d72_b.jpg" />本质矩阵E（Essential Matrix)</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-719e1d3fe9b45a4dcad6925a1906434e_r.jpg" />基础矩阵F(Fndamental)</p><p>单应矩阵(Homography)</p><p><strong>求解步骤：</strong></p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-a578b33f52e376fb6678b94359b93871_r.jpg" /></p><p>1.根据配对点的像素位置求出E或者F.</p><p>2.根据E或者F求出R,t。</p><p>也就是只要知道配对点的像素位置就可以通过对极约束求出相机位姿。</p><p><strong>三角测量</strong></p><p>估计了相机运动后，需要用相机的运动估计特征点的空间位置。</p><p>单目SLAM中，通过三角测量估计地图的深度。</p><p><strong>3D-2D:PnP（Perspective-n-Point）</strong></p><p>描述了当知道n个3D空间点及其投影位置时，如何估计相机的位姿。</p><p>特征点的3D位置可以由三角化或RGB-D相机的深度图确定。</p><p>在双目或RGB-D的视觉里程计中，我们可以直接使用PnP估计相机运动。</p><p>单目视觉里程计中，必须先进行初始化，然后才能使用PnP。</p><p>3D-2D方法不需要使用对极约束，又可以在很少的匹配点中获得较好的运动估计。PnP问题有，用3对点估计位姿的P3P、直接线性变换、EPnP、非线性优化(BA)。</p><p>直接线性变换</p><p><strong>P3P</strong></p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-8d7b3c65b695b875d626e85412f128ed_r.jpg" /></p><p>目的是求相机位姿。输入数据为3对3D-2D匹配点。3D点为A,B,C,2D点为a,b,c。</p><p>知道3D点的世界坐标系中的坐标和2D点的图像位置，不知道相机坐标系的坐标。（之前的是根据已知外参和世界坐标系的坐标可以求得相机坐标系的坐标，现在不知道相机位姿)。</p><p>利用三角形对应关系，求出得到A,B,C相机坐标系下的3D坐标。最后把问题转换成一个3D（世界坐标系）到3D(相机坐标系)下的位姿估计问题。</p><p>Bundle Adjustment</p><p>重投影误差的问题。</p><p>3D-3D:ICP（Iterative,Closet Point,迭代最近点）</p><p>3D-3D的位姿估计问题，假设有一组配对好的3D点。</p><p>ICP位姿估计没有出现相机模型，和相机没关系。</p><p>在RGBD SLAM中，可以用这种方式估计相机位姿。</p><p>求解方式主要两种：线性代数求解（主要是SVD),非线性优化方式求解（类似于BA).</p><p>SVD方法</p><p><imgsrc="/image/视觉SLAM搞定坐标系三角测量PnP_行知SLAM/v2-6e4b94d90c239a83b0fa41bcb9795a58_r.jpg" /></p><p>以上部分参考高博PPT及相关博客：<ahref="https://link.zhihu.com/?target=https%3A//blog.csdn.net/sunshine_zoe/article/details/73457686%3Futm_source%3Dblog">https://blog.csdn.net/sunshine_zoe/article/details/73457686?utm_source=blog</a>xgwz0</p><p>注：未经授权，请勿转载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1
id=&quot;视觉slam搞定坐标系三角测量pnp&quot;&gt;视觉SLAM:搞定坐标系、三角测量、PnP&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Author:&lt;/strong&gt; [行知SLAM]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Link:&lt;/strong&gt; [https://zhuanlan.
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="note" scheme="https://silencht.github.io/categories/robot/note/"/>
    
    
  </entry>
  
  <entry>
    <title>贝叶斯滤波（Bayes Filter）推导</title>
    <link href="https://silencht.github.io/wiki/robot/note/%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2%E6%8E%A8%E5%AF%BC/"/>
    <id>https://silencht.github.io/wiki/robot/note/贝叶斯滤波推导/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="约定">约定</h3><p>$t时刻的状态记为x_t $</p><p><span class="math inline">\(t 时刻的测量数据记为 z_t\)</span></p><p><span class="math inline">\(t_1到t_2时刻的观测数据流（t_1\leqt_2）记为z_{t1:t2}=z_{t1},z_{t1+1},z_{t1+2},…,z_{t2}\)</span></p><p><spanclass="math inline">\((t-1,t]时间内的控制数据记为u_t\)</span></p><p><span class="math inline">\(t_1到t_2时刻的控制数据流（t_1\leqt_2）记为u_{t1:t2}=u_{t1},u_{t1+1},u_{t1+2},…,u_{t2}\)</span></p><p><spanclass="math inline">\(状态变量x_t的置信度记为bel(x_t)\)</span></p><p><spanclass="math inline">\(执行控制量u_t后，进行观测z_t之前的状态变量x_t的置信度记为\overline{be l}(x_t)\)</span></p><hr /><h3 id="引用">引用</h3><ul><li><span class="math inline">\(\begin{array}{l} \mathrm{P}(\mathrm{x}\mid \mathrm{y}, \mathrm{z})\\ =\frac{\mathrm{p}(\mathrm{y}, \mathrm{z}\mid \mathrm{x}) \mathrm{p}(\mathrm{x})}{\mathrm{p}(\mathrm{y},\mathrm{z})} \\ =\frac{\mathrm{p}(\mathrm{x}, \mathrm{y},\mathrm{z})}{\mathrm{p}(\mathrm{y}, \mathrm{z})} \\=\frac{\mathrm{p}(\mathrm{x}, \mathrm{y},\mathrm{z})}{\mathrm{p}(\mathrm{y} \mid \mathrm{z})\mathrm{p}(\mathrm{z})} \\ =\frac{\mathrm{p}(\mathrm{x}, \mathrm{y},\mathrm{z}) \mathrm{p}(\mathrm{x}, \mathrm{z})}{\mathrm{p}(\mathrm{y}\mid \mathrm{z}) \mathrm{p}(\mathrm{z}) \mathrm{p}(\mathrm{x},\mathrm{z})} \\ \because \frac{\mathrm{p}(\mathrm{x}, \mathrm{y},\mathrm{z})}{\mathrm{p}(\mathrm{x}, \mathrm{z})}=\mathrm{P}(\mathrm{y}\mid \mathrm{x}, \mathrm{z}), \frac{\mathrm{p}(\mathrm{x},\mathrm{z})}{\mathrm{p}(\mathrm{z})}=\mathrm{P}(\mathrm{x} \mid\mathrm{z}) \\ \therefore \mathrm{p}(\mathrm{x} \mid \mathrm{y},\mathrm{z})=\frac{\mathrm{p}(\mathrm{y} \mid \mathrm{x}, \mathrm{z})\mathrm{p}(\mathrm{x} \mid \mathrm{z})}{\mathrm{p}(\mathrm{y} \mid\mathrm{z})} \end{array}\)</span></li><li><span class="math inline">\(p(x)=\int p(x \mid y) p(y) dy\)</span></li><li><span class="math inline">\(p(x \mid y)=\frac{p(x,y)}{p(y)}\)</span></li></ul><hr /><h3 id="推导">推导</h3><p>前提：正确初始化初始时刻 <span class="math inline">\(t=0\)</span>的置信度 <span class="math inline">\(bel(x_0)\)</span> 。</p><p><span class="math inline">\(\begin{array}{l}\operatorname{bel}\left(x_{t}\right)\\ =p\left(x_{t} \mid z_{t}, z_{1:t-1}, u_{1: t}\right)\\ =p\left(z_{t} \mid x_{t}, z_{1: t-1}, u_{1:t}\right) \cdot p\left(x_{t} \mid z_{1: t-1}, u_{1: t} \right) \cdot(p\left(z_{t} \mid z_{1: t-1}, u_{1: t}\right))^{-1}\\ =\eta \cdotp\left(z_{t} \mid x_{t}, z_{1: t-1}, u_{1: t}\right) \cdot p\left(x_{t}\mid z_{1: t-1}, u_{1: t}\right) \end{array}\)</span></p><p>如果状态 $x_t $ 能很好的预测未来，那么就说状态 <spanclass="math inline">\(x_t\)</span>是完备complete的。状态的完备性意味着历史状态、测量值以及控制量都不再能够提供使我们更准确预测未来的额外信息。</p><p>关于完备性的定义并不要求未来是状态的一个确切的函数。未来是随机的，但除了状态<spanclass="math inline">\(x_t\)</span>，之前的任何状态都不能对未来产生影响。满足这一特性的过程就是人们常说的马尔可夫链<em>Markov chains</em>。</p><p>若状态 <span class="math inline">\(x_t\)</span>是完备complete的，有：</p><p><span class="math inline">\(p\left(z_{t} \mid x_{t}, z_{1: t-1},u_{1: t}\right)=p\left(z_{t} \mid x_{t}\right)\)</span></p><p>即，</p><p><span class="math inline">\(\begin{array}{l}\operatorname{bel}\left(x_{t}\right)\\ =\eta \cdot p\left(z_{t} \midx_{t}\right) \cdot p\left(x_{t} \mid z_{1: t-1}, u_{1: t}\right)\\ =\eta\cdot p\left(z_{t} \mid x_{t}\right) \cdot \overline{b e l}(x_t)\\\begin{array}{l} =\eta \cdot p\left(z_{t} \mid x_{t}\right) \cdot\frac{p\left(x_{t} \cdot z_{1: t-1} \cdot u_{1: t}\right)}{p\left(z_{1:t-1} \cdot u_{1: t}\right)}\\ \begin{array}{l} =\eta \cdot p\left(z_{t}\mid x_{t}\right) \cdot \frac{\int_{x_{t-1}} p\left(x_{t} \cdot z_{1:t-1} \cdot u_{1: t} \mid x_{t-1}\right) \cdot p\left(x_{t-1}\right) dx_{t-1}}{p\left(z_{1: t-1} \cdot u_{1: t}\right)} \\ =\eta \cdotp\left(z_{t} \mid x_{t}\right) \cdot \frac{\int_{x_{t-1}} p\left(x_{t}\cdot z_{1: t-1} \cdot u_{1: t} \cdot x_{t-1}\right) dx_{t-1}}{p\left(z_{1: t-1} \cdot u_{1: t}\right)} \end{array}\\ =\eta\cdot p\left(z_{t} \mid x_{t}\right) \cdot \int_{x_{t-1}}\frac{p\left(x_{t} \cdot z_{1: t-1} \cdot u_{1: t} \cdotx_{t-1}\right)}{p\left(z_{1: t-1} \cdot u_{1: t} \cdot x_{t-1}\right)}\cdot \frac{p\left(z_{1: t-1} \cdot u_{1: t} \cdotx_{t-1}\right)}{p\left(z_{1: t-1} \cdot u_{1: t}\right)} d x_{t-1}\\=\eta \cdot p\left(z_{t} \mid x_{t}\right) \cdot \int_{x_{t-1}}p\left(x_{t} \mid x_{t-1}, z_{1: t-1}, u_{1: t}\right) \cdotp\left(x_{t-1} \mid z_{1: t-1}, u_{1: t}\right) d x_{t-1}\\ \end{array}\end{array}\)</span></p><ul><li>全概率公式 P(x)=∫P(x|y)P(y)dy</li><li>贝叶斯公式 P(x|y)=P(xy) / P(y)</li></ul><p>因为假设了状态具有完备性，所以如果我们知道了 $x_{t-1} $，过去的观测量和控制量将不携带关于状态 <spanclass="math inline">\(x_t\)</span> 的信息。因此，有：</p><p><span class="math inline">\(p\left(x_{t} \mid x_{t-1}, z_{1: t-1},u_{1: t}\right)=p\left(x_{t} \mid x_{t-1}, u_{t}\right)\)</span></p><p>且，考虑到t时刻的控制量 <span class="math inline">\(u_t\)</span>与t-1时刻的状态 <span class="math inline">\(x_{t-1}\)</span>无关，则：</p><p><span class="math inline">\(\begin{array}{l}\operatorname{bel}\left(x_{t}\right)\\ =\eta \cdot p\left(z_{t} \midx_{t}\right) \cdot \int_{x_{t-1}} p\left(x_{t} \mid x_{t-1},u_{t}\right) \cdot p\left(x_{t-1} \mid z_{1: t-1}, u_{1: t}\right) dx_{t-1}\\ =\eta \cdot p\left(z_{t} \mid x_{t}\right) \cdot\int_{x_{t-1}} p\left(x_{t} \mid x_{t-1}, u_{t}\right) \cdotp\left(x_{t-1} \mid z_{1: t-1}, u_{1: t-1}\right) d x_{t-1}\\ =\eta\cdot p\left(z_{t} \mid x_{t}\right) \cdot \int_{x_{t-1}} p\left(x_{t}\mid x_{t-1}, u_{t}\right) \cdot b e l\left(x_{t-1}\right) d x_{t-1}\end{array}\)</span></p><hr /><h3 id="结论">结论</h3><p><span class="math inline">\(\begin{array}{l}\overline{\operatorname{bel}}\left(x_{t}\right)=\int p\left(x_{t} \midx_{t-1},u_{t}\right) \text { bel }\left(x_{t-1}\right) d x_{t-1} \\\operatorname{bel}\left(x_{t}\right)=\eta \cdot p\left(z_{t} \midx_{t}\right) \overline{\operatorname{bel}}\left(x_{t}\right)\end{array}\)</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;约定&quot;&gt;约定&lt;/h3&gt;
&lt;p&gt;$t时刻的状态记为x_t $&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(t 时刻的测量数据记为 z_t&#92;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;(t_1到t_2
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="note" scheme="https://silencht.github.io/categories/robot/note/"/>
    
    
  </entry>
  
  <entry>
    <title>2006-slam-review</title>
    <link href="https://silencht.github.io/wiki/robot/paper/2006-slam-review/"/>
    <id>https://silencht.github.io/wiki/robot/paper/2006-slam-review/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="part-i-the-essential-algorithms">Part I The EssentialAlgorithms</h2><h3 id="摘要">0、摘要</h3><p>本教程介绍了同时定位和建图(SLAM)，以及在过去十年中对SLAM进行的广泛研究。SLAM是移动机器人可以构建环境地图，同时使用该地图来计算其自身位置的过程。在过去的十年里，在解决SLAM问题和许多令人信服的SLAM方法的实现方面，已经取得了快速而令人兴奋的进展。本教程的第一部分（本文），描述了SLAM问题的概率形式、基本的解决方法和重要的实现。本教程的第二部分将关注大规模和复杂环境的SLAM问题的最新进展和新公式。</p><h3 id="介绍">1、介绍</h3><p>SLAM问题：移动机器人被放置在未知环境中的未知位置，然后逐步构建环境一致地图，同时确定自己在该地图中的位置。因为SLAM问题的解决方案将提供使机器人真正自主的手段，因此被视为移动机器人社区的“圣杯”。</p><p>SLAM问题的“解决方案”是过去十年机器人社区的显著成果之一。SLAM问题已经通过许多不同形式的理论所表述和解决。SLAM也在许多不同的领域实现，从室内机器人，到室外、水下和空中系统。在理论和概念层面上，SLAM现在可以被认为是一个已解决的问题。然而，在实际实现更通用的SLAM解决方案方面，特别是在构建和使用感知丰富的地图作为SLAM算法的一部分方面，仍然存在实质性的问题。</p><p><strong>第一部分结构：</strong></p><ul><li><p>第二节首先提供了SLAM早期发展的简要历史</p></li><li><p>第三节介绍了现在的标准贝叶斯形式的SLAM问题的结构，并解释了SLAM过程的演变</p></li><li><p>第四节描述了SLAM问题的两个关键计算解决方案：通过使用扩展卡尔曼滤波器(EKF-SLAM)和Rao布莱威尔德粒子滤波器(RaoBlackwellisedparticle fifiltersFastSLAM)。其他最近（相对于2006年而言）的解决方案将在的第二部分中讨论</p></li><li><p>第五节描述了SLAM的一些重要的现实实现，强调了那些可以供学者自由下载和研究的传感器数据和软件</p><p>本教程的第二部分描述了SLAM中计算、收敛性和数据关联中的主要问题。在过去的五年里，这些主题一直是SLAM研究社区的主要焦点。</p></li></ul><h3 id="slam早期历史">2、SLAM早期历史</h3><h4 id="起源">2.1 起源</h4><p>SLAM问题<strong>起源于1986年</strong>在旧金山举行的IEEE机器人和自动化会议上。这时，概率方法才刚刚开始被引入机器人技术和人工智能。许多研究人员一直在研究将估计理论的方法应用于建图和定位问题；这些人包括彼得·切斯曼、吉姆·克劳利和休·杜兰特-怀特。在会议过程中，充满了关于一致建图的长期讨论。在这个过程中，拉贾·查蒂拉、奥利弗·弗杰拉斯、兰德尔·史密斯和其他人也为这次对话做出了有用的贡献。</p><h4 id="发展受阻">2.2 发展受阻</h4><p>这次对话的结果是认识到一致概率建图是机器人技术中的一个基本问题。在接下来的几年里，人们产生了一些关键的论文。史密斯和切斯曼[39]和Durrant-Whyte[17]的工作为描述地标和操纵几何不确定性之间的关系建立了一个统计基础。这项工作的一个关键要素表明了<strong>地图中不同地标的位置的估计之间一定有高度的相关性，而这些相关性确实会随着连续的观测而增长。</strong></p><p>与此同时，阿亚奇和福杰拉斯[1]正在从事早期的视觉导航工作，Crowley[9]和Chatila和Laumond[6]正在使用卡尔曼滤波型算法进行移动机器人基于声纳的导航。这两股研究有很多共同点，不久之后就在史密斯、赛尔夫和芝士曼[40]的具有里程碑意义的论文中发表。这篇论文表明：<strong>当移动机器人在未知环境中对地标进行相对观察时，由于估计机器人位置[27]的共同误差，对这些地标的估计也都必然相互相关</strong>。这一点的含义是深远的，这说明全局一致定位与建图问题的<strong>解决方案将由机器人姿态和每一个地标位置组成联合状态，在每个地标观察之后更新</strong>。反过来说，这将需要估计器使用一个巨大的状态向量（在地图中维护地标的数量顺序），计算规模也将是地标数量的平方级。</p><p>至关重要的是，这项工作并<strong>没有研究地图的收敛特性或其稳态行为</strong>。事实上，当时人们普遍认为，地图估计的误差不会收敛，而是会表现出具有无限误差增长的随机游走行为。因此，出于定位问题的计算复杂性以及对地图的敛散性的无知，研究人员反而专注于一系列近似一致的建图问题解决方案，这些方案假设甚至强制使地标之间的相关性最小化，把完整的滤波器filter简化成了机器人filter上一系列解耦的地标landmarks（例如[28]，[38]）。同样出于这些原因，关于同步结合定位和建图问题的理论工作暂时停止，工作通常集中在定位或建图的独立问题上。</p><h4 id="理论突破">2.3 理论突破</h4><p><strong>随着意识到同步结合定位和建图问题一旦被表述为一个单一的估计问题实际是收敛的，理论上也就出现了突破</strong>。最重要的是，人们认识到，大多数研究人员试图最小化的地标之间的相关性实际上是问题的关键部分，相反，这些相关性增长得越多，解决方案就越好。在1995年[16]机器人研究国际研讨会上发表的一篇移动机器人调查论文中，有关SLAM问题的结构、收敛结果和“SLAM”缩写等首次亮相。Csorba[11]，[10]提出了关于收敛的基本理论和许多初步结果。已经有几个在地图和定位方面工作的小组，特别是在麻省理工学院的[29]、萨拉戈萨[5]，[4]、悉尼[20]的ACFR、[45]以及其他人[7]，[13]，开始认真研究SLAM在室内、室外和海底环境中的应用。</p><h4 id="理论改进">2.4 理论改进</h4><p>此时，<strong>工作集中于提高计算效率和解决数据关联或“回路闭环”中的问题</strong>。1999年的机器人研究国际研讨会(ISRR‘99)[23]是一个重要的会议点，在这里举行了第一次SLAM会议，并在基于卡尔曼滤波器的SLAM方法与Thrun[42]引入的概率定位和建图方法之间实现了一定程度的收敛性。2000年IEEEICRA关于SLAM的研讨会吸引了15名研究人员，并重点关注了算法复杂性、数据关联和实现挑战等问题。接下来在2002年ICRA举办的SLAM研讨会吸引了150名具有广泛兴趣和应用的研究人员。2002年，由斯德哥尔摩的亨里克·克里斯汀森在KTH举办的大满贯夏季学校吸引了所有关键研究人员和来自世界各地的大约50名博士生，在建设该领域方面取得了巨大的成功。近年来，人们对SLAM的兴趣呈指数级增长，研讨会继续在ICRA和IROS举行。SLAM暑期学校也于2004年在托卢斯，2006年在牛津大学开办。</p><h3 id="slam公式和结构">3、SLAM公式和结构</h3><p>SLAM是指移动机器人可以构建环境地图，同时使用此地图来推断其自身位置的一个过程。在SLAM中，平台的轨迹和所有地标的位置都是在线估计的，其不需要任何先验的位置知识。</p><h4 id="前期">3.1 前期</h4><p>考虑一个移动机器人在一个环境中移动，使用位于机器人上的传感器对一些未知地标进行观测，如下图所示。在时间时刻$ k$ ，定义以下变量：</p><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210518195408354.png" alt="image-20210518195408354" style="zoom: 80%;" /></p><ul><li><p>$ x_{k} $：状态向量，描述机器人在时间 $ k$时的位置和姿态的向量</p></li><li><p>$ u_{k} $：控制向量，驱动机器人由 $ k-1$ 时刻 $ x_{k-1}$ 姿态 至$ k$ 时刻 $ x_{k}$ 姿态</p></li><li><p>$ m_{i}$：描述第 $ i^{th}$个地标位置的向量，其真实位置假设为时不变的</p></li><li><p>$ z_{ik}$：机器人在 $ k$ 时刻"观测"到第 $ i^{th}$个地标时产生的观测数据（当任意时刻有多个地标被观测到或当特定地标与此次讨论discussion无关时，观测数据被简写为$ z_{k}$ ）</p><p>此外，还定义了以下集合：</p></li></ul><p><span class="math display">\[\mathbf{X}_{0: k}=\left\{\mathbf{x}_{0}, \mathbf{x}_{1}, \cdots,\mathbf{x}_{k}\right\}=\left\{\mathbf{X}_{0: k-1},\mathbf{x}_{k}\right\}：机器人轨迹历史\]</span></p><p><span class="math display">\[\mathbf{U}_{0: k}=\left\{\mathbf{u}_{1}, \mathbf{u}_{2}, \cdots,\mathbf{u}_{k}\right\}=\left\{\mathbf{U}_{0: k-1},\mathbf{u}_{k}\right\}：控制输入历史\]</span></p><p><span class="math display">\[\mathbf{m}=\left\{\mathbf{m}_{1}, \mathbf{m}_{2}, \cdots,\mathbf{m}_{n}\right\} ：路标集合\]</span></p><p><span class="math display">\[\mathbf{Z}_{0: k}=\left\{\mathbf{z}_{1}, \mathbf{z}_{2}, \cdots,\mathbf{z}_{k}\right\}=\left\{\mathbf{Z}_{0: k-1},\mathbf{z}_{k}\right\}：所有的路标观测集合\]</span></p><h4 id="概率slam">3.2 概率SLAM</h4><p>​ 在概率形式中，同时定位和地图构建(SLAM)问题要求计算所有时间 $ k$的概率分布： <span class="math display">\[P\left(\mathbf{x}_{k}, \mathbf{m} \mid \mathbf{Z}_{0: k}, \mathbf{U}_{0:k}, \mathbf{x}_{0}\right)\]</span> 这种概率分布描述了地标位置 $ m$ 和机器人位姿 $ x_{k}$ (在时间$ k$ 时)的<strong>联合后验密度</strong>（后验：其实也就是知道了控制输入和观测数据的结果，反过来推测地标和位姿），给定传感器记录的观测数据集合$ <em>{0: k}$和从时间 $ 0$ 到 $ k$ 的控制输入历史 $U</em>{0:k}$，以及机器人的初始位姿 $ x_{0}$。一般来说，对SLAM问题的递归解是可取的：从时刻 $ k-1$ 的分布 $P(<em>{k-1}, </em>{0: k-1}, <em>{0: k-1})$ 开始，根据控制 $ u</em>{k} $和观测数据 $ z_{k} $，用贝叶斯定理进行计算。该计算需要定义一个<strong>运动模型</strong>（statetransition model）和一个<strong>观测模型</strong>（observationmodel），分别描述控制输入和观测数据的影响。</p><p><strong>观测模型</strong>描述了在知道机器人位姿和地标位置时观测 $z_{k} $ 的概率，并且通常以下式进行描述： <span class="math display">\[P\left(\mathbf{z}_{k}\mid \mathbf{x}_{k},\mathbf{m}\right)\]</span>可以合理地假设，一旦定义了机器人的位姿和地标集，那么给定地图和当前的机器人位姿，观测结果是有条件地相互独立（independent）的。</p><p><strong>运动模型</strong>可以用状态转换形式的概率分布来描述： <spanclass="math display">\[P\left(\mathbf{x}_{k}\mid \mathbf{x}_{k-1},\mathbf{u}_{k}\right)\]</span> 也就是说，状态转换被假设是一个马尔可夫过程，其下一个状态 $x_{k}$ 只依赖于立即进行的状态 $ x_{k-1}$ 和所应用的控制向量 $ u_{k}$，并且独立于观测结果和地标。</p><p>SLAM算法现在以标准的有序两步递归：预测（时间更新）+校正（测量更新）形式实现：</p><ul><li>时间更新（运动模型）</li></ul><p><span class="math display">\[\begin{array}{l}P\left(\mathbf{x}_{k}, \mathbf{m} \mid \mathbf{Z}_{0: k-1},\mathbf{U}_{0: k}, \mathbf{x}_{0}\right) \\=\int P\left(\mathbf{x}_{k} \mid \mathbf{x}_{k-1}, \mathbf{u}_{k}\right)\times P\left(\mathbf{x}_{k-1}, \mathbf{m} \mid \mathbf{Z}_{0: k-1},\mathbf{U}_{0: k-1}, \mathbf{x}_{0}\right) \mathrm{d} \mathbf{x}_{k-1}\end{array}\]</span></p><ul><li>测量更新（观测模型）</li></ul><p><span class="math display">\[\begin{array}{l}P\left(\mathbf{x}_{k}, \mathbf{m} \mid \mathbf{Z}_{0: k}, \mathbf{U}_{0:k}, \mathbf{x}_{0}\right) \\=\frac{P\left(\mathbf{z}_{k} \mid \mathbf{x}_{k}, \mathbf{m}\right)P\left(\mathbf{x}_{k}, \mathbf{m} \mid \mathbf{Z}_{0: k-1},\mathbf{U}_{0: k}, \mathbf{x}_{0}\right)}{P\left(\mathbf{z}_{k} \mid\mathbf{Z}_{0: k-1}, \mathbf{U}_{0: k}\right)}\end{array}\]</span></p><p>两个等式提供了一个递归程序，用于计算机器人位姿 $ x_{k}$ 和 $ x_{k}$在时间 $ k$ 上的联合后验概率 $ P(<em>{k}, </em>{0: k}, <em>{0: k},</em>{0})$。</p><p>值得注意的是，<strong>建图问题</strong>可以表述为计算条件密度： <spanclass="math display">\[P\left(\mathbf{m} \mid \mathbf{X}_{0: k}, \mathbf{Z}_{0: k},\mathbf{U}_{0:k}\right)\]</span> 这假设机器人 $ x_{k}$的位置在服从初始位置的知识上，一直以来都是已知的（或至少是确定性的）。然后通过融合来自不同位置的观测结果来构造一个地图$ $。</p><p>反之，<strong>定位问题</strong>可以表述为计算概率分布： <spanclass="math display">\[P\left(\mathbf{x}_{k} \mid \mathbf{Z}_{0: k},\mathbf{U}_{0:k},\mathbf{m}\right)\]</span>这假设地标位置是确定已知的，其目标是基于这些地标来计算机器人位置的估计。</p><h4 id="概率slam的结构">3.3 概率SLAM的结构</h4><p>为了简化本节中的讨论，我们将删除方程式 $ P(<em>{k}, </em>{0: k},<em>{0: k}, </em>{0})$中对历史变量的条件处理，并在上下文允许的情况下，将地标和机器人位姿上所需的联合后验写为$ P(<em>{k}, </em>{k})$ ，甚至写成$ P(_{k},)$ 。</p><p>观测模型 $ P(<em>{k}</em>{k},)$明确说明了观测结果对机器人和地标位置两者的依赖性。由此可见，联合后验不能以如下所示的明显方式进行分割：<span class="math display">\[P\left(\mathbf{x}_{k}, \mathbf{m} \mid \mathbf{z}_{k}\right) \neqP\left(\mathbf{x}_{k} \mid \mathbf{z}_{k}\right) P\left(\mathbf{m} \mid\mathbf{z}_{k}\right)\]</span>事实上，从关于一致建图[39]，[17]的早期论文中就知道，这样的分割会导致不一致的估计。然而，SLAM问题的结构比这些方程更明显。</p><p>再次参考3.1节的机器人位姿地标观测图，可以看出，估计地标和真实地标位置之间的共同误差在地标之间很常见，而且误差的来源比较单一；在机器人进行地标位置的观测时，误差就产生了。反过来说，这意味着地标位置估计中的误差是高度相关的。实际上，这意味着任何两个地标之间的相对位置，如$ <em>{i}-</em>{j}$ ，可以高精度的测量，即使其中的一个地标（如$<em>{i}$）的绝对位置可能相当不确定。在概率形式中，这意味着即使边缘密度 $P(</em>{i})$ 可能相当分散，但一对地标 $ P(<em>{i},</em>{j})$的联合概率密度也会达到峰值。</p><p>在SLAM中最重要的认识是，随着越来越多的观察结果的出现，地标估计之间的相关性在单调增加。实际上，这意味着地标的相对位置的估计总是不断改善，永远不会发散，不管机器人的运动如何。在概率术语中，这意味着随着地标观测结果的增加，所有地标$ P()$ 上的联合概率密度将单调地达到峰值。</p><p>这种收敛的原因是机器人的观测地标之间相对位置的是“<strong>几乎独立</strong>”的测量。再次参考3.1节的机器人位姿地标观测图，考虑机器人在位置$ x_{k} $ 观察两个地标 $ <em>{i}$ 和 $ </em>{j}$。此时，观察到的地标的相对位置显然与机器人的坐标系无关，从这个固定位置进行的连续观测将产生进一步<strong>独立</strong>的地标之间的相对关系的测量。现在，当机器人移动到位置$ x_{k+1} $ 时，它再次观察到地标 $ <em>{j}$，这允许机器人和地标的估计位置相对于之前的位置 $ x</em>{k} $进行更新。反过来，即使 $ <em>{i}$地标没有从新的位置看到，信息也会传播回来，以此更新地标 $ </em>{i}$。这是因为从之前的测量结果相比，这两个地标是高度相关的（它们的相对位置是已知的）。</p><p>此外，相同的测量数据被用来更新这两个地标，这一事实使它们更加具有相关性。术语“<strong>几乎独立</strong>”的测量是合适的，因为观测误差将通过连续的机器人运动相关联。还要注意，在图中位置$ x_{k+1} $ 中，机器人观察到两个相对于 $ <em>{j}$的新地标。这些新的地标也立即与地图的其他部分联系或相关。稍后更新这些地标时也将更新地标$ </em>{j}$ ，在更新到 $ _{i}$等等。也就是说，所有的地标最终都形成了一个由相对位置或相关性连接起来的网络，每当观察到它们时，其精度或值都会增加。</p><p>此过程可视为将所有地标连接在一起的弹簧网络，或者作为嵌入所有地标的橡胶板，如下图：</p><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210520160948818.png" alt="image-20210520160948818" style="zoom: 67%;" /></p><p>在某地附近的观测行为就像对弹簧系统或橡胶板的位移，因此它在某地附近的效果很大，并且依赖于局部刚度（相关性）特性，效果又随着与其他地标的距离增大而减小。当机器人在这个环境中移动并观察地标时，弹簧将变得越来越（而且单调地）坚硬。在观测次数极多至极限条件下，就得到了刚性的地标图或准确的相对环境图。在构建地图时，机器人相对于地图测量的位置精度仅受地图质量和相对测量传感器的限制。在理论极限下，机器人的相对位置精度等于给定地图所可实现的定位精度。</p><h3 id="slam解决方案">4、SLAM解决方案</h3><p>概率SLAM问题的解决方案包括为观测模型方程（6）和运动模型方程（7）寻找一个适当的表示，该表示允许有效和一致地计算方程（8）和（9）中的先验分布和后验分布。</p><p>到目前为止，最常见的表示形式是具有加性高斯噪声的状态空间模型，由此便有了使用扩展的卡尔曼滤波器(EKF)来解决4.1节的SLAM问题；</p><p>一个重要的替代表示形式是将方程式（7）中的运动模型描述为一组更一般的非高斯概率分布的样本，这导致了使用Rao-Blackwellised粒子滤波器或FastSLAM算法来解决4.2节中所述的SLAM问题。</p><p>虽然EKF-SLAM和FastSLAM是两种最重要的解决方法，但较新的替代方案也提供了很大的潜力，包括使用信息状态形式的[43]。本教程的第二部分将进一步讨论这些问题。</p><h4 id="ekf-slam">4.1 EKF-SLAM</h4><p>待看</p><h4 id="rao-blackwellised-滤波器">4.2 Rao-Blackwellised 滤波器</h4><p>待看</p><h3 id="slam的实现">5、SLAM的实现</h3><p>近年来，概率SLAM的实际实现越来越令人印象深刻，其在更具有挑战性的环境中覆盖了更大的领域。在这里，我们将讨论两个有代表性的实现，并提到了其他值得注意的应用程序。</p><p>待看</p><h3 id="结论">6、结论</h3><p>本文描述了SLAM问题，解决SLAM问题的基本方法，并总结了方法的关键实现和演示。虽然还有许多实际问题需要克服，特别是在更复杂的户外环境中。一般的SLAM方法现在是机器人技术的一个被充分理解和确立的一部分。本教程的第二部分将总结最近解决SLAM中一些剩余问题的工作，包括；计算、特征表示和数据关联。</p><h3 id="pdf原文">7、PDF原文</h3><div><p><iframe src="/pdfjs/web/viewer.html?file=/pdf/robot/2006-Simultaneous-Localisation-and-Mapping-PartI.pdf" width="100%" height="1280px" frameborder="0"></iframe></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;part-i-the-essential-algorithms&quot;&gt;Part I The Essential
Algorithms&lt;/h2&gt;
&lt;h3 id=&quot;摘要&quot;&gt;0、摘要&lt;/h3&gt;
&lt;p&gt;本教程介绍了同时定位和建图(SLAM)，以及在过去十年中对SLAM进行的广
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="paper" scheme="https://silencht.github.io/categories/robot/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>2016-slam-review</title>
    <link href="https://silencht.github.io/wiki/robot/paper/2016-slam-review/"/>
    <id>https://silencht.github.io/wiki/robot/paper/2016-slam-review/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="slam概念">1. SLAM概念</h2><h3 id="slam是什么">1.1 SLAM是什么？</h3><p><strong>同时定位与地图构建</strong>（英语：Simultaneous localizationand mapping，一般直接称SLAM）是一种概念：</p><blockquote><p>希望机器人从未知环境的未知地点出发，在运动过程中通过重复观测到的地图特征（比如，墙角，柱子等）定位自身位置和姿态，再根据自身位置增量式的构建地图，从而达到同时定位和地图构建的目的。</p></blockquote><ul><li><p>localization：我在什么地方？——<strong>定位</strong></p></li><li><p>mapping：周围环境什么样子？——<strong>建图</strong></p></li><li><p>simultaneous：先做什么？——<strong>同时</strong></p><blockquote><p>simultaneous map building and localization can be seen to present aquestion of which came fifirst, the chicken or the egg? (The map or themotion?)</p></blockquote><blockquote><p>starting from the unknown location of the unknown environment, therobot locates its own position and attitude through repeated observationof environmental features in the movement process, and then builds anincremental map of the surrounding environment according to its ownposition, so as to achieve the purpose of simultaneous positioning andmap construction.</p></blockquote><p><strong>同时</strong>建立地图和定位可以被视为一个是先有鸡还是先有蛋的问题。</p><p>从未知环境的未知地点出发，通过运动过程中对环境特征的反复观察，定位自身位置和姿态，然后根据自身位置来构建周围环境的<strong>增量地图</strong>，实现同时 定位和地图构造的目的。</p><p><strong>SLAM问题的本质：对运动主体自身和周围环境空间不确定性的估计</strong></p></li></ul><h3 id="slam用在哪">1.2 SLAM用在哪？</h3><h4 id="适用场景">1.2.1 适用场景</h4><blockquote><p>SLAM finds applications in all scenarios in which a prior map is notavailable and needs to be built.</p></blockquote><p>那些没有办法构建先验地图且需要构建地图的所有场景。</p><h4 id="不适用场景">1.2.2 不适用场景</h4><blockquote><p>SLAM may not be required if localization can be done reliably withrespect to the known landmarks.</p></blockquote><p>那些能依靠已知地标进行有效定位的场景。</p><h3 id="slam为何兴起">1.3 SLAM为何兴起？</h3><blockquote><p>The popularity of the SLAM problem is connected with the emergence ofindoor applications of mobile robotics.</p></blockquote><p>与室内移动机器人的兴起息息相关。</p><blockquote><p>The popularity of SLAM in the last 30 years is not surprising if onethinks about the manifold aspects that SLAM involves.</p><p>At the lower level (called the <em>front-end</em> ) SLAM naturallyintersects other research fifields such as computer vision and signalprocessing;</p><p>At the higher level (that we later call the <em>back-end</em> ), SLAMis an appealing mix of geometry, graph theory, optimization, andprobabilistic estimation.</p></blockquote><p>如果考虑到SLAM涉及的多方面问题，那么它在这三十年的流行也就不足为奇。</p><p>从低层次，即SLAM前端来说，它与计算机视觉和信号处理等领域很自然的交叉作用；</p><p>从高层次，即SLAM后端来说，它是一个吸引人的几何、图论、优化和概率估计的组合。</p><h3 id="slam有研究意义吗">1.4 SLAM有研究意义吗？</h3><h4 id="自动机器人需要slam吗">1.4.1 自动机器人需要SLAM吗？</h4><h5 id="引言">1.4.1.0 引言</h5><blockquote><blockquote><p>SLAM aims at building a globally consistent representation of theenvironment, leveraging both ego-motion measurements and loop closures.The keyword here is “<strong>loop closure</strong>”: if we sacrifificeloop closures, SLAM reduces to <strong>odometry</strong>. In earlyapplications, odometry was obtained by integrating wheel encoders. Thepose estimate obtained from wheel odometry quickly<strong>drifts</strong>, making the estimate unusable after fewmeters.</p></blockquote><p>SLAM旨在利用自我运动测量和闭环检测来构建整体一致的环境表示。这里的关键词是“闭环检测”：如果我们丢弃闭环检测，那么SLAM将会退化为里程测量/里程计。在早期的应用中，可以通过积分车轮编码器来获得里程。然而，从车轮里程测量所获得的姿态估计快速<strong>漂移</strong>，使得估计数在短短几米之内就不可用。</p><ul><li>A. Kelly. Mobile Robotics: Mathematics, Models, and Methods .Cambridge University Press, 2013.</li></ul><blockquote><p>this was one of the main thrusts behind the development of SLAM: theobservation of external landmarks is useful to reduce the trajectorydrift and possibly correct it.</p></blockquote><p>这个是SLAM发展背后的主要推动力之一：对于外部地标的观测有助于减少轨迹漂移并可能纠正之。</p><ul><li>P. Newman, J. J. Leonard, J. D. Tardos, and J. Neira. Explore andReturn: Experimental Validation of Real-Time Concurrent Mapping andLocalization. In <em>Proceedings of the IEEE International ConferenceonRobotics and Automation (ICRA)</em>, pages 1802–1809. IEEE, 2002.</li></ul><blockquote><p>However, more recent odometry algorithms are based on visual andinertial information, and have very small drift (<em>&lt;</em>0<em>.</em>5% of the trajectory length).</p></blockquote><p>然而，很多最近的基于视觉和惯性信息的测速方法漂移越来越小。</p><ul><li>C. Forster, L. Carlone, F. Dellaert, and D. Scaramuzza. On-ManifoldPreintegration for Real-Time Visual–Inertial Odometry. <em>IEEETransactions on Robotics (TRO)</em>, PP(99):1–21, 2016.</li></ul><p>那么问题来了，</p><p><strong>我们真的还需要SLAM这个算法吗？</strong></p><p><strong>答案有三方面</strong></p></blockquote><h5 id="odometry就是slam的一部分">1.4.1.1 Odometry就是SLAM的一部分</h5><ul><li><strong>视觉-惯性导航（VIN）就是一个简化版SLAM</strong></li></ul><p>​首先，在过去十年的SLAM发展中，研究本身就产生了基于视觉-惰性测量算法，这种算法目前代表了最先进的水平[163,175]。在这种意义上，视觉-惯性导航（visual-inertialnavigation）就是SLAM：<strong>VIN可以被看作一个简化版SLAM系统，只不过这个系统的闭环检测（loopclosure）或者位置识别（place recongnition）模块没有开启</strong>。</p><p>​ 更一般的，SLAM直接导致了在相比以前文献（如航空航天工程中的<ahref="../note/inertial_navigation.md">惰性导航</a>）更有挑战性的设置下（如没有GPS,低质量传感器等）关于传感器融合的研究。</p><h5 id="odometry-和-loop-closure-缺一不可">1.4.1.2 Odometry 和 LoopClosure 缺一不可</h5><ul><li><p><strong>单纯的里程计会无限探索新区域，加入位置识别有助于理解环境真实拓扑</strong></p><p>第二个回答是关于环境的真实拓扑结构（truetopology）的。一个只运行里程计（odometry）而关闭闭环检测（loopclosure）的机器人会将世界解释为一个“无限走廊（infinitecorridor）”，在这个“走廊”里，机器人一直保持着探索未定义的新区域，如图1左侧。回路闭环事件会通知机器人这个走廊与它自身发生相交（intersect），如图1右侧。闭环检测的优势现在开始变得清晰：<strong>加入闭环检测后，机器人可以理解环境的真实拓扑，也就有能力找到位置之间的最短路径</strong>（比如地图上的点B和点C）。</p></li></ul><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210331092855678.png" /></p><center>图1</center><p><em>图一：<strong>左图</strong>：利用里程计构建的地图。这个地图可看作是一条从起始位置A 到最终位置 B的一条长走廊。在现实中实际距离很近的点（例如 B和C）可能在测距图（odometricmap）中是任意远的。<strong>右图</strong>：利用SLAM构建的地图。通过充分利用回路闭环（loopclosures），SLAM可以估计环境的实际拓扑结构（topology）并在地图中发现（discovers）最短路径（shortcuts）。</em></p><ul><li><strong>单纯的位置识别有可能被位置不同而场景相似的数据关联所欺骗</strong></li></ul><p>​那么，既然获得正确的环境拓扑是SLAM的优点之一，那为什么不简单删掉度量信息（metricinformation）就只做位置识别呢？答案很简单：度量信息可以使得位置识别更简单和鲁棒；度量的重建会通知机器人有关闭环检测的机会，并允许丢弃虚假的回路闭环[150]。因此，尽管SLAM在原理上可能是冗余的（一个甲骨文位置识别模块足以胜任构建拓扑地图），但是SLAM（中的度量信息）为那些错误的数据关联和感知混叠提供了自然的防御（此时，对于环境中的实际位置不同而场景却相似的情况将不会欺骗到位置识别）。</p><p>​从这个意义上来说，<strong>SLAM地图提供了一种既预测又验证未来测量结果的方法</strong>：我们相信这个机制将是机器人稳定运行的关键。</p><h5 id="在要求全局一致地图中slam是必须的">1.4.1.3在要求全局一致地图中，SLAM是必须的</h5><p>​ 对于许多无论是内在还是外在需求全局一致（globallyconsistent）的地图（map）来说，SLAM是必需的。例如，在许多军用和民用应用中，机器人的目标是探索一个（未知）环境，然后向人类操作员报告一张确保全覆盖该环境的地图。另外一个例子是，机器人必须可以（对建筑、桥梁等）进行结构性检查；同样，在这种情况下，一个全局一致的三维重建是获得成功的需要。</p><h4 id="slam在学术上已经被解决了吗">1.4.2SLAM在学术上已经被解决了吗？</h4><p>​这个问题很难回答。因为SLAM已经成为一个很广泛的话题，所以这个问题适合在<strong>给定的 机器人/环境/性能 三者组合的情况下</strong> 提问。</p><h5 id="比较成熟的领域提高系统的精度鲁棒性">1.4.2.1比较成熟的领域：提高系统的精度、鲁棒性</h5><ul><li>配备 车轮编码器和激光扫描仪 的构建 二维地图 的室内机器人已经有了相当的精度（&lt;10cm）和足够的鲁棒性（如低故障率），可以被认为在很大程度上已经得到解决；</li><li>配备 基于视觉SLAM 的缓慢移动机器人（例如火星漫游者、家用机器人等），以及视觉惯性里程计（visual-inertialodometry）可以被视为是比较成熟的领域；</li></ul><h5 id="尚不成熟的领域高速时失效">1.4.2.2尚不成熟的领域：高速时失效</h5><ul><li>当机器人的 运动 或者 所处环境具有挑战性的时候，SLAM算法很容易失效。例如，快速机器人动力学 、高度动态的环境；</li><li>SLAM算法往往无法满足严格性能要求场合。例如，快速闭环控制下的高速率估计（highrate estimation for fast closed-loop control）</li><li>如何平衡实时性和准确性是一个问题；</li><li>有关动态、非结构化、复杂、不确定和大规模的环境的解决方案仍有待探索；</li></ul><h3 id="视觉slam的相机决策">1.5 视觉SLAM的相机决策</h3><table><colgroup><col style="width: 6%" /><col style="width: 46%" /><col style="width: 46%" /></colgroup><thead><tr class="header"><th style="text-align: center;">相机</th><th style="text-align: center;">优点</th><th style="text-align: center;">缺点</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">单目相机</td><td style="text-align: center;">结构简单，成本特别低</td><tdstyle="text-align: center;">平移之后才能计算深度，无法确定真实尺度</td></tr><tr class="even"><td style="text-align: center;">双目相机</td><td style="text-align: center;">克服了单目相机的缺点</td><tdstyle="text-align: center;">配置与标定较为复杂，深度量程和精度受双目基线与分辨率所限，视差计算非常消耗计算资源</td></tr><tr class="odd"><td style="text-align: center;">深度相机</td><td style="text-align: center;">相比双目相机节省大量计算资源</td><tdstyle="text-align: center;">测量范围窄、噪声大、视野小、易受日光干扰、无法测量透射材质等。主要用于室内，室外较难应用。</td></tr><tr class="even"><td style="text-align: center;">事件相机</td><tdstyle="text-align: center;">相比传统相机具有更小的时间延迟，更快的更新速率、更强的动态范围、更低的功耗和更小的存储空间要求。有望成为继深度相机后的新型视觉传感器</td><tdstyle="text-align: center;">完全依赖于场景动态,低动态环境下性能反而不如传统相机</td></tr></tbody></table><h2 id="slam的发展阶段">2. SLAM的发展阶段</h2><h3 id="classical-age古典时期">2.1 1986—2004：classicalage（古典时期）</h3><h4 id="研究内容">2.1.1 研究内容</h4><blockquote><p>the introduction of <strong>the main probabilisticformulations</strong> for SLAM , including approaches based on<strong>Extended Kalman Filters</strong>, <strong>Rao-BlackwellisedParticle Filters</strong>, and <strong>maximum likelihoodestimation</strong>.</p></blockquote><p>引入了SLAM主要的概率公式，其中包括 扩展卡尔曼滤波、粒子滤波 和最大似然估计</p><h4 id="论文">2.1.2 论文</h4><blockquote><p>A thorough historical review of the first 20 years of the SLAMproblem</p></blockquote><p>详细论述SLAM发展前二十年的review</p><ul><li>H. F. Durrant-Whyte and T. Bailey. Simultaneous Localisation andMapping (SLAM): Part I. <em>IEEE Robotics and Automation Magazine</em>,13(2):99–110, 2006.</li><li>T. Bailey and H. F. Durrant-Whyte. Simultaneous Localisation andMapping (SLAM): Part II. <em>Robotics and Autonomous Systems (RAS)</em>,13(3):108–117, 2006.</li></ul><blockquote><p>Two other excellent references describing the <strong>three main SLAMformulations</strong> of the classical age</p></blockquote><p>描述三大SLAM主要公式的论文</p><ul><li>S. Thrun, W. Burgard, and D. Fox. Probabilistic Robotics. MITPress,2005.</li><li>C. Stachniss, S. Thrun, and J. J. Leonard. Simultaneous Localizationand Mapping. In B. Siciliano and O. Khatib, editors, Springer Handbookof Robotics, chapter 46, pages 1153–1176. Springer, 2nd edition,2016.</li></ul><h4 id="挑战">2.1.3 挑战</h4><blockquote><p>the basic challenges connected to efficiency and robust dataassociation.</p></blockquote><p>效率和鲁棒的数据关联的挑战 。</p><h3 id="algorithmic-analysis-age算法分析时期">2.22004—2015：algorithmic-analysis age（算法分析时期）</h3><h4 id="研究内容-1">2.2.1 研究内容</h4><blockquote><p>the study of fundamental properties of SLAM, including observability,convergence, and consistency. In this period, the key role of<strong>sparsity</strong> towards effificient SLAM solvers was alsounderstood, and the main open-source SLAM libraries were developed.</p></blockquote><p>研究SLAM的基本特性，包括可观测性、收敛性和一致性。在这一时期，（人们）理解了对SLAM的高效率解决器？起到关键作用的<strong>稀疏性</strong>，并开发了主要的开源SLAM库。</p><h4 id="论文-1">2.2.2 论文</h4><blockquote><p>partially covered</p></blockquote><p>覆盖部分该时期内容的review</p><ul><li>G. Dissanayake, S. Huang, Z. Wang, and R. Ranasinghe. A review ofrecent developments in Simultaneous Localization and Mapping. InInternational Conference on Industrial and Information Systems*, pages477–482. IEEE, 2011.</li></ul><h4 id="挑战-1">2.2.3 挑战</h4><h3 id="至今robust-perception-age稳健感知时期">2.32015—至今：robust-perception age（稳健感知时期）</h3><h4 id="研究内容-2">2.3.1 研究内容</h4><h5 id="稳健的性能">2.3.1.1 稳健的性能</h5><blockquote><p>the SLAM system operates with low failure rate for an extended periodof time in a broad set of environments; the system includes fail-safemechanisms and has self-tuning capabilities in that it can adapt theselection of the system parameters to the scenario.</p></blockquote><p>系统在广泛的环境中长期运行且具有低故障率；系统包括故障-安全机制和自调整功能，可以针对适应场景修改参数。</p><h5 id="高级的理解">2.3.1.2 高级的理解</h5><blockquote><p>the SLAM system goes beyond basic geometry reconstruction to obtain ahigh-level understanding of the environment</p></blockquote><p>系统超越基本的几何重建来获得对环境的更高级别的理解。（高级图形学、语义学、物理学、affordances）</p><h5 id="资源意识">2.3.1.3 资源意识</h5><blockquote><p>the SLAM system is tailored to the available sensing andcomputational resources, and provides means to adjust the computationload depending on the available resources</p></blockquote><p>系统针对可用传感器与计算资源进行裁剪，提供根据可用资源调整计算负载的方法</p><h5 id="任务驱动感知">2.3.1.4 任务驱动感知</h5><blockquote><p>the SLAM system is able to select relevant perceptual information andfifilter out irrelevant sensor data, in order to support the task therobot has to perform; moreover, the SLAM system produces adaptive maprepresentations, whose complexity may vary depending on the task athand</p></blockquote><p>系统有 选择 相关感知信息 和 滤除 不相关传感数据 的能力来支持机器人需要执行的任务。此外，系统产生自适应的根据手头任务不同而复杂性不同的地图表示。</p><h4 id="论文-2">2.3.2 论文</h4><h4 id="挑战-2">2.3.3 挑战</h4><blockquote><p>Visual SLAM still face some important obstacles like the illuminationcondition, high dynamic environment, fast motion, vigorous rotation andlow texture environment.</p></blockquote><p>视觉SLAM仍然面临着光照条件、高动态环境、运动快、旋转剧烈、低纹理环境等重要阻碍。</p><h4 id="未来">2.3.4 未来</h4><ul><li>基于智能手机、嵌入式平台（如无人机）的SLAM</li><li>详细的三维重建，使用深度学习的场景理解</li><li>多传感器融合问题</li><li>语义SLAM：还可以支持全局优化、闭环检测和重新定位；传统的SLAM依赖于点线面等几何特征来推断环境结构，而语义SLAM是使机器人像人类一样思考，从而在大规模场景中实现高精度实时定位的目标。</li><li>算法和传感器的深度融合，集成、专用的传感器将发挥出巨大的潜力</li><li>端到端</li></ul><h2 id="英文名词翻译解释">0.1 英文名词翻译/解释</h2><ul><li>metric 度量</li><li>semantic 语义 Semantic is used to describe things that deal with themeanings of words and sentences.</li><li>pose 姿态，这里一般指机器人的位置和姿势 position andorientation</li><li>topology 拓扑the way the parts of sth are arranged and related</li></ul><h2 id="pdf原文">3. PDF原文</h2><div><p><iframe src="/pdfjs/web/viewer.html?file=/pdf/robot/Past-Present-and-Future-of-Simultaneous-Localization-And-Mapping-Towards-the-Robust-Perception-Age.pdf" width="100%" height="1280px" frameborder="0"></iframe></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;slam概念&quot;&gt;1. SLAM概念&lt;/h2&gt;
&lt;h3 id=&quot;slam是什么&quot;&gt;1.1 SLAM是什么？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;同时定位与地图构建&lt;/strong&gt;（英语：Simultaneous localization
and mapping，一般直
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="paper" scheme="https://silencht.github.io/categories/robot/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>orbslam1-translation</title>
    <link href="https://silencht.github.io/wiki/robot/paper/orbslam1-translation/"/>
    <id>https://silencht.github.io/wiki/robot/paper/orbslam1-translation/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要">摘要</h3><p>本文提出了ORB-SLAM，这是一种在大小场景、室内室外环境下都可以实时运行的基于特征的单目SLAM系统。系统对复杂的剧烈运动具有鲁棒性，允许宽基线的闭环和重定位，且包含完整的自动初始化。在最近几年的优秀算法基础上，我们从头开始设计了一种新颖的对包括追踪、建图、重定位、闭环所有SLAM任务在内都使用相同特征的系统。选择点和重建关键帧的适者生存策略具有很好的鲁棒性，并能够生成紧凑的可追踪的地图，只有当场景内容发生变化地图才改变，从而允许长时间运行。本文从最受欢迎的数据集中提供了27个序列的详尽评估。相对于其他最先进的单目SLAM方法，ORB-SLAM实现了前所未有的性能。为了造福社区，我们将源代码公开。</p><p><strong>关键字</strong>：长期建图，定位，单目视觉，识别，同时定位和建图（SLAM）</p><h3 id="i.-引言">I. 引言</h3><p>我们知道，在我们提供优质（strong）的匹配网络和良好的初始值预测的情况下，BA（bundleadjustment）方法可以给出相机定位的精确估计以及稀疏几何重建[1,2]。在很长一段时间内，在诸如VSLAM这种实时性应用中，BA方法（由于其理论算力的大开销）被认为是无法使用的。VSLAM的目标是在建图的同时估计相机的轨迹。如今我们知道，为了使BA计算成本在可承受范围内的同时还获得较为准确的结果，一个实时SLAM算法必须向BA提供以下信息：</p><ul><li>在选定帧（关键帧）子集中场景特征（地图点）的相应观察</li><li>复杂性随着关键帧数量增长，关键帧的筛选要避免不必要的冗余</li><li>关键帧和地图点之间强大的网络配置用以产生准确的结果，也就是说关键帧中的观察到的地图点能够提供显著的视差以及足够的回环匹配</li><li>提供一个尽可能准确的用于BA非线性优化的关键帧位姿初始值</li><li>探索中的局部地图，优化的重点是具备更好的可扩展性（对于局部地图，优化只在局部进行而与全局尺寸无关）</li><li>可以实时进行快速全局优化（比如位姿图）以结束（close）闭环的能力</li></ul><p>BA第一次实时应用是在Mouragon等人[3]提出的视觉里程计算法中，接着是Klein和Murray做出的突破性SLAM工作，其被称为并行追踪和建图（PTAM）[4]。尽管受制于小场景的应用，PTAM算法对关键帧的选择、特征匹配、点的三角化、每一帧的相机位姿估计、追踪失败后的重定位等提供了简单而有效的方法。不幸的是，缺少闭环检测和足够的对遮挡的处理（机制）、重定位的视图不变性差、在地图初始化时需要人工干预等因素严重限制了其应用。</p><p>在本文中，我们基于PTAM算法的主要框架，采用Gálvez-López和Tardós提出的placerecognition（场景/位置识别）[5]算法，Strasdat等人提出的scale-aware loopclosing（具备尺度感知的闭环检测）[6]算法以及文献[7]和[8]中的大尺度操作中共视（covisibility）信息的使用方法，重新设计了一种新的单目SLAM系统：ORB-SLAM，贡献主要包括：</p><ul><li>对所有的任务采用相同的特征：追踪、地图构建、重定位和闭环检测。这使得我们的系统更有效率、简单可靠。采用的ORB特征[9]在没有GPU的情况下也有很好的实时性，且具有旋转不变性和光照不变性。</li><li>支持在大场景中实时运行。由于共视图（covisibilitygraph）的使用，特征点的跟踪与构图主要集中在局部共视区域，而与全局地图的尺寸无关。</li><li>使用一种我们称为Essential Graph的位姿图（posegraph）来优化位姿实现实时回环检测。它是由系统维护的生成树、闭环的链接和共视图（covisibilitygraph）的强边共同构建的。</li><li>实时相机重定位具有明显的旋转不变特性和光照不变性。这就使得跟踪丢失后可以恢复，增强了地图的重用性。</li><li>一种新的基于模型选择的自动和鲁棒的初始化程序，其允许创建平面和非平面场景的初始建图</li><li>提出了一种用来选择地图点和关键帧的“适者生存”方法：生成时放宽要求但剔除时提高要求。这种策略可以剔除冗余的关键帧，从而增强追踪的鲁棒性以及长时间运行的能力。</li></ul><p>我们使用公共数据集对算法在室内和室外环境下的性能进行了评估，这些环境包括手持设备、汽车和机器人。值得一提的是，我们的方法与目前最优秀的直接SLAM算法[10]相比（直接SLAM算法直接通过对像素点的灰度进行优化而不是最小化特征重投影误差）能够实现更准确的摄像头定位。我们在文章的第IX-B部分还讨论了基于特征的SLAM算法比直接法更准确的可能原因。</p><p>闭环检测和重定位的方法是基于我们之前的工作[11]。系统最初的版本是论文[12]。本文中我们添加了初始化的方法、Essentialgraph、并完善了其他所有方法。我们详细描述了系统的各个板块，并且进行了详尽的实验验证。</p><p>据我们所知，这是目前最完整最可靠的单目SLAM系统。为了造福，我们将源代码开放。视频演示和源代码放在我们的项目网站上。</p><h3 id="ii.-相关工作">II. 相关工作</h3><h4 id="a位置识别">A、位置识别</h4><p>Williams等人在综述[13]中比较了几种用于位置识别的方法，得出的结论是：基于外观的技术（即图像到图像的匹配）在大环境下大概率比地图到地图或图像到地图的方法更准确。在基于外观匹配的方法中，bagsofwords（词袋）[14]技术（比如概率方法FAB-MAP[15]算法）以高效率脱颖而出。DBoW2方法[5]首次使用了从BRIEF描述子[16]和非常高效的FAST特征检测算法[17]中获得的二进制词袋。与迄今为止用于词袋方法中的SURF[18]和SIFT[19]特征相比，这将特征提取所需的时间减少了一个数量级以上。尽管系统表现的非常高效和鲁棒，但采用不具有旋转不变性和尺度不变性的BRIEF描述子，系统被限制在只能运行在同一平面内（否则会造成尺度变化），闭环检测也只能从相似的视角中进行。在我们之前的工作[11]中，我们提出了一个使用ORB特征的DBoW2词袋位置识别器。ORB特征是具有旋转不变和尺度不变特性（在一定范围内）的二进制特征，因此，用它生成的快速识别器具有较好的视角不变性。我们在四个不同的数据集中证明了识别器的高召回率和鲁棒性：从10K图像数据库中提取一个候选闭环的运算时间少于39毫秒。在本文的工作中，我们提出了一种改进版本的采用共视（covisibility）信息的位置识别方法，其在检索数据库时返回几个假设情况而不仅仅是最好的匹配。</p><h4 id="b地图初始化">B、地图初始化</h4><p>单目SLAM系统需要设计专门的程序来生成初始化地图，因为深度信息不可能从仅仅一幅图像中恢复出来。解决该问题的一个方法是一开始跟踪一个已知结构的对象[20]。而在使用滤波的方法中，可以用一个具有高不确定度的逆深度参数[21]来初始化点的深度信息，理想情况下该参数会在后期逐渐收敛到真值。最近Engel提出的半稠密方法[10]中就采用类似的方法将像素的深度信息初始化为一个具有高方差的随机值。</p><p>从两个视图的初始化方法要么假设局部场景平面性[4][22]，并使用Faugeras等人的方法[23]从单应矩阵（homography）中恢复相对相机姿态，要么使用Nister[26]的五点算法（该方法存在多解的问题）计算一个建模了平面和一般场景的本质矩阵（essentialmatrix）[24][25]（并利用本质矩阵恢复相对相机姿态）。这两种位姿重构方法在低视差下都没有很好的约束，如果平面场景内的所有点都过于接近摄像机中心之一，则结果会出现双重歧义[27]（twofoldambiguitysolution）。另一方面，非平面场景可以通过线性8点算法[2]来计算一个唯一的基础矩阵（fundamental matrix），相机的相对位姿就可以无歧义的恢复出来。</p><p>针对这一问题，我们在本文IV提出了一个新的基于模型选择的自动初始化方法，对平面场景算法选择单应性矩阵（homography），而对于非平面场景则选择基础矩阵（fundamentalmatrix）。模型选择的统计方法可参见Torr等人的论文[28]。基于类似的理论，我们设计了一种启发式初始化算法，算法会考虑到在接近退化情况（比如：平面，近似平面，或是低视差）下选择基础矩阵进行位姿估计存在的风险，则转而选择单应性计算。在平面的情况下，为了保险起见，如果最终解存在双重歧义则会避免进行初始化（因为可能会因为错误选择解而导致算法崩溃）。因此我们会延迟初始化过程，直到所选的模型在明显的视差下产生唯一的解。</p><h4 id="c单目slam">C、单目SLAM</h4><p>单目SLAM最初采用滤波方法[20],[21],[29],[30]来建模。在该类方法中，每一帧都通过滤波器联合估计地图特征位置和相机位姿。这样做带来的问题有：处理没什么新信息的连续帧图像时对计算资源的浪费、线性误差的累积。而另外一种SLAM方法是采用少数筛选过的图像（关键帧）来建图[3][4]。因为建图不再与帧率相关联，因此基于关键帧的SLAM方法不但节省了计算资源，还可以进行高精度的BA优化。Strasdar等人在论文[31]中证明了在相同的计算成本上基于关键帧的方法比滤波方法结果更精确。</p><p>最具代表性的基于关键帧SLAM系统可能是由Klein和Murray等人提出的PTAM算法[4]。它第一次提出将相机追踪track和建图mapping拆分成两个并行的线程运行，并在小环境的实时增强现实应用中取得了成功。随后[32]在原始版本基础上改进了边缘特征，在跟踪过程中增加了旋转估计步骤，实现了更好的重定位方法。PTAM中的地图点通过图像区块与FAST角点匹配，这使得地图点仅适合于特征跟踪而不适合用于位置识别。实际上，PTAM算法并没有进行大闭环检测，其重定位也仅是基于关键帧低分辨率缩略图的相关性进行的，因此视角不变性较差。</p><p>Strasdat等人在论文[6]中提出了一个基于GPU实现的大尺度单目SLAM系统，该系统前端采用光流算法，其次用FAST特征匹配和仅运动（<em>motion-only</em>）BA；后端是基于滑动窗口（sliding-window）的BA。闭环检测通过具有相似性约束（7自由度）的位姿图（posegraph）优化来进行，该方法可以矫正在单目SLAM系统中出现的尺度偏移（scaledrift）问题。在本文中，我们也将采用这种7自由度的位姿图优化方法，并将其应用到III-D节中定义的EssentialGraph中。</p><p>Strasdat等人在文献[7]中采用了PTAM的前端，但其跟踪部分仅在一个从共视图（covisibilitygraph）提取的局部图（localmap）中进行。他们提出了一个双窗口优化后端，在内部窗口中连续进行BA，在有限大小的外部窗口中构建位姿图。然而，只有当外部窗口尺寸足够大到可以包含整个闭环的情况下，闭环检测才能起作用。在我们的系统中，我们采用了Strasdat等人提出的使用基于共视信息的局部地图并通过共视图来构建位姿图的优秀想法，但（实际是）将它们应用在（我们）完全重新设计的前端和后端里。另一个区别是，我们没有使用特别的特征做闭环检测（比如SURF），而是基于与追踪、建图相同的特征进行位置识别，因此获得了鲁棒的帧率重定位和闭环检测。</p><p>在Pirker等人的论文[33]中作者提出了CD-SLAM，这是一个非常完善的系统，它包括闭环检测，重定位，大尺度运行以及对动态环境运行所做的工作。但文中并没有提及地图初始化。（而且，）公共接口的缺乏使我们没法对其进行精确性、鲁棒性和大场景下能力的测试对比。</p><p>Song等人在论文[34]提出的视觉里程计方法中使用了ORB特征做追踪和一个短暂滑动窗口做BA后端。相比之下，我们的系统更加普适，因为他们（的系统中）没有涉及全局重定位、闭环检测，而且地图也不能复用。他们还使用了相机到地面的真实距离来限制单目SLAM算法的尺度漂移。</p><p>Lim等人在我们提交本文最初的版本[12]之后发表了论文[25]，他们也采用相同的特征进行跟踪、建图和闭环检测。但是，由于Lim等人的（对不具备尺度不变性）BRIEF描述子的选择，因此其系统运行受限在平面轨迹上。他们的系统仅从最后一帧关键帧跟踪特征点，因此访问过的地图不能复用（与视觉里程计很像），并且存在系统无限增长的问题。我们在VIII-E小节里面将我们的系统与该系统进行了定性比较。</p><p>Engel等人在最近的论文[10]里提出了LSD-SLAM，其可以构建大场景的半稠密地图。系统并没有采用使用特征点的BA方法，而是选择直接法（优化也是直接通过图像像素灰度进行）。系统结果让人印象深刻，其在没有GPU加速的情况下可以实时构建一个半稠密地图，相比基于特征点的SLAM系统输出的稀疏地图而言，LSD-SLAM方法在机器人领域有更大的应用潜力。然而，该系统的运行依旧需要基于特征点做闭环检测，且相机定位的精度也明显低于PTAM和我们的系统。相关实验结果我们将在VIII-B小节中展示，这一令人惊讶的结果在IX-B小节进行讨论。</p><p>Forster等人在论文[22]中提出了介于直接法和基于特征点法之间的半直接视觉里程计SVO。该系统不需要对每帧图像都提取特征点，且可以以很高的帧率运行，在四轴飞行器上取得了令人印象深刻的效果。然而，SVO没有进行闭环检测，且目前的实现主要基于下视摄像头运行。</p><p>最后，我们想讨论一下关键帧的选择。所有的视觉SLAM工作相关的文献都同意选择所有的地图点和图像帧运行一起进行BA是不可行的。因此在论文[31]中，Strasdat等人证明性价比最高（cost-effective）的方法是保留尽可能多的（地图）点，同时只保留非冗余关键帧。PTAM通过非常谨慎的插入关键帧以避免运算复杂度过度增长。然而，这种严格限制关键帧插入的策略可能会在困难的探索条件下导致追踪失败。我们的适者生存（<em>survivalof thefifittest</em>）策略是在困难的场景下尽快插入关键帧，并稍后删除冗余的关键帧以避免额外的（计算）成本，这实现了前所未有的鲁棒性。</p><h3 id="iii.-系统架构">III. 系统架构</h3><h4 id="a特征选择">A、特征选择</h4><p>我们系统的主要设计思想是将SLAM系统的建图、跟踪使用的相同特征应用在位置识别以达到（高）帧率（级别的）重定位和闭环检测。这就避免了像之前一些工作[6][7] 需要额外插入一些识别性强的特征（recognitionfeatures）（以用于后期的闭环检测），因此我们的系统更有效率。我们每张图像的特征提取时间要远少于33毫秒，这就排除了流行的SIFT（<sub>300ms）[19]、SURF（</sub>300ms）[18]，或者是最近的A-KAZE(~100ms)[35]。为了获得更广泛的位置识别能力，我们需要（提取的特征具备）旋转不变性，这就排除了BRIEF[16]和LDB[36]。</p><p>我们选择了ORB[9]特征，它是关联了256位描述子（descriptor）的带方向（oriented）的多尺度（multi-scale）FAST角点。它们的计算和匹配速度非常快，同时对视角具有很好的旋转不变性（invariance）。这允许在更宽的基准线上匹配它们，所以提高了BA的精度。我们已经在论文[11]中证明了基于ORB特征的位置识别良好的性能。虽然本文的方案中采用ORB特征，但所提出的技术并不仅限于该特征。</p><h4id="b三个线程追踪局部建图和闭环检测">B、三个线程：追踪、局部建图和闭环检测</h4><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210829230353349.png" /></p><center>图1</center><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210829231343404.png" alt="image-20210829231343404" style="zoom: 50%;" /></p><center>图2a：关键帧(蓝)、当前相机(绿)、地图点(黑,红)、当前局部地图点(红)</center><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210829231423540.png" alt="image-20210829231423540" style="zoom:50%;" /></p><center>图2b：共视图</center><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210831214051985.png" alt="image-20210831214051985" style="zoom:50%;" /></p><center>图2c：生成树(绿)、闭环回路(红)</center><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210831214125201.png" alt="image-20210831214125201" style="zoom:50%;" /></p><center>图2d：本质图</center><p>我们的系统框架如图1所示，包括三个并行的线程：跟踪、局部建图和闭环检测。跟踪线程负责对每帧图像的相机进行定位，并决定什么时候插入新的关键帧。我们首先执行与前一帧图像的初始特征匹配，然后采用仅运动（<em>motion-only</em>）BA优化位姿。如果跟踪丢失（比如由于遮挡或是突然运动），则由位置识别模块进行全局重定位。一旦获得最初的相机位姿估计和特征匹配，则使用由系统维护的关键帧的共视图（covisibilitygraph）提取一个局部可视化地图，如图2(a),图2(b)所示。然后通过重投影方法搜索（当前帧）与局部地图点对应的匹配，并利用所有的匹配点再次优化当前相机位姿。最后，跟踪线程决定是否（将当前帧）插入新的关键帧。所有的跟踪步骤将在V小节详细阐述。创建初始化地图的新程序将在IV小节进行介绍。</p><p>局部建图线程负责处理新的关键帧，使用局部BA对相机位姿周围环境进行优化重构。在共视图（covisibilitygraph）已连接的所有关键帧中搜索新关键帧中未匹配的ORB特征新对应项，然后将之三角化为新的地图点。在创建后的一段时间内，根据跟踪过程中收集的信息，会应用严格苛刻的点剔除策略，以只保留高质量的点。局部建图线程也负责剔除（culling）冗余的关键帧。我们将在VI节详细说明局部建图的步骤。</p><p>闭环检测线程负责对每个新的关键帧进行闭环搜索（以确认是否形成闭环）。如果检测到了闭环，我们就计算一个通知闭环累积误差的相似变换。然后将闭环的两侧对齐，并将重复的点融合。最后，执行基于相似性约束[6]的位姿图优化以实现全局一致性。主要创新点在于，我们执行了基于EssentialGraph的优化，它是一个基于共视图covisibilitygraph的一个稀疏子图，更多细节将在III-D小节解释。VII节详细解释了闭环检测和校正步骤的细节。</p><p>我们使用在g2o[37]中实现的列文伯格-马夸尔特法（Levenberg-Marquardt）算法来进行所有的优化。在附录中，我们描述了每个优化中涉及的误差项、误差函数和变量。</p><h4 id="c地图点关键帧及其选择标准">C、地图点、关键帧及其选择标准</h4><p>每个地图点 <span class="math inline">\(P_{i}\)</span>存储以下信息：</p><ul><li>它在世界坐标系中的3D坐标 <spanclass="math inline">\(X_{w,i}\)</span></li><li>平均观测方向 <spanclass="math inline">\(n_{i}\)</span>，即该点所有观测方向（该方向是指连接该点和其对应观测关键帧光心的射线方向）的平均单位向量</li><li>一个具有代表性的ORB特征描述子 <spanclass="math inline">\(D_{i}\)</span>，它是（与该地图点）关联的ORB描述子，其汉明距离相对于能观察到该点的关键帧中的所有其他关联的描述子都最小</li><li>可观测到该点的最大 <span class="math inline">\(d_{max}\)</span>和最小 <span class="math inline">\(d_{min}\)</span>观测距离，根据ORB特征的尺度不变性限制（得出的）</li></ul><p>每个关键帧 <span class="math inline">\(K_{i}\)</span>存储以下信息：</p><ul><li>相机位姿 <spanclass="math inline">\(T_{i,w}\)</span>，这是一个将点从世界坐标系转换到相机坐标系下的刚体变换（矩阵）</li><li>相机内参，包括主点（principal point）和焦距（focal length）</li><li>从图像帧提取的所有ORB特征点，不管其是否已经关联了地图点。如果提供了畸变模型（distortionmodel）（参数），则其坐标将不会失真（undistorted）</li></ul><p>地图点云和关键帧的创建策略较为宽松，但是之后则会通过一个非常严格苛刻的删选机制进行挑选，该机制会检测出冗余的关键帧和匹配错误的或不可跟踪的地图点然后进行删除。这样做的好处在于探索时，地图在扩建过程中具有一定的弹性，使得系统在外界条件比较恶劣的情况下（比如：旋转，相机快速运动）仍然可以实现鲁棒的跟踪。而（与此同时）当相机对同一个环境不断重新访问时，地图的大小是可控的，这就利于该系统的长期工作。另外，与PTAM算法相比我们构建的地图中包含极少的异常值（outliers），但付出的代价就是点的总数更少。地图点和关键帧的剔除程序分别将在VI-B节和VI-E节解释。</p><h4 id="d共视图和本质图">D、共视图和本质图</h4><p>关键帧之间的共视（covisibility）信息在我们系统中几个模块上都非常有用，我们像论文[7]一样将其表示成一个无向加权图（undirectedweightedgraph）。<strong>（共视）图</strong>中每个节点代表一个关键帧，如果两个关键帧能同时观测到至少15个地图点，则这两个节点之间用一条边相连，两个关键帧能共同观测到的地图点数量作为这条边的权重θ。</p><p>为了矫正闭环回路，我们像论文[6]那样做位姿图优化，优化方法是延着位姿图将闭环回路的误差进行传播。考虑到共视图（covisibilitygraph）提供的所有边可能非常密集，我们提出构建一个保留了所有节点（关键帧）但边数却更少的本质图（EssentialGraph）。本质图仍旧保持了一个强大的网络以获得精确的结果。系统从初始关键帧开始增量式地构建一个<strong>生成树</strong>，该树提供了一个边数量最少的共视图（covisibilitygraph）的连接子图。当插入新的关键帧时，将该关键帧与树上与其有最多共同观测点的关键帧相链接；反之，当一个关键帧通过剔除策略被删除时，系统将更新受该关键帧影响的链接。<strong>本质图</strong>（EssentialGraph）包含了生成树（spanning tree）、具有高共视信息（covisibility）（即<spanclass="math inline">\(θ_{min}=100\)</span>）共视图的边的子集、以及闭环回路的边，（这样的组合共同）构建了一个强大的相机网络。图2展示了一个共视图、生成树和相关的本质图的例子。在本文VIII-E节的实验里，当（系统）运行位姿图优化时，结果就可以达到非常高的精度以至于（再运行）额外的全局BA优化几乎无法提升其精度。本质图的效率和<span class="math inline">\(θ_{min}\)</span>(对系统）的影响将在VIII-E节的结尾部分讨论。</p><h4 id="e基于词袋模型的位置识别">E、基于词袋模型的位置识别</h4><p>系统嵌入了基于DBoW2[5]算法来执行闭环检测和重定位的模块。视觉单词（visualwords）是一个离散化的特征描述子空间，被称为视觉词典（visualvocabulary）。视觉词典是通过大量图像中提取ORB描述子离线创建的。正如我们之前的论文[11]所展现的：如果图像的通用性足够强，则相同的视觉词典在不同的环境下也能获得很好的性能。SLAM系统增量地构建一个包含倒置索引的数据库，用于存储视觉词典里的每个视觉单词以及它们被哪些关键帧观测到，因此数据库的检索效率非常高。当一个关键帧通过剔除程序被删除时，数据库也会进行相应更新。</p><p>由于关键帧之间可能会存在视图上的重叠，因此检索数据库时，可能返回不止一个高分值的关键帧结果。原版的DBoW2考虑到了（视图）重叠，（然后）提高了时间上更近的图像的分值。这里的局限性（limitation）在于：没有包括那些观测了同一地点但在不同时间插入的关键帧。为了解决这一问题，我们将这些在共视图中相连的关键帧进行分组。另外，我们的数据库返回分值高于最好分值75%以上的所有关键帧。</p><p>用词袋模型来表示特征匹配的另外一个优势在论文[5]里有详细介绍。当我们想计算两组ORB特征的对应关系时，我们可以强制限制在视觉词典树上某一层（我们在6个里面选第2个？）的相同节点里进行暴力匹配，（以此）加快搜索速度。我们将这个技巧应用到三角化新的（地图）点，闭环检测和重定位的搜索匹配中。我们还通过方向一致性测试来改进对应性，这可以去除异常值，确保所有对应（匹配点的）旋转方向一致，具体请看论文[11]。</p><h3 id="iv.-地图自动初始化">IV. 地图自动初始化</h3><p>略</p><h3 id="v.-跟踪">V. 跟踪</h3><p>在这一部分，我们将详细介绍跟踪线程在每一帧相机图像上执行的步骤。在几个步骤中都提到的相机位姿优化，包括仅运动（<em>motion-only</em>）BA，将在附录部分进行阐述。</p><h4 id="aorb特征提取">A、ORB特征提取</h4><p>我们在8层图像金字塔上提取FAST角点，图像金字塔尺度因子为1.2。我们发现：图像分辨率从512×384到752×480之间，提取1000个角点比较合适。对于更高的分辨率，如KITTI数据集[40]中提供的1241×376分辨率，则提取2000个角点。为了确保特征点均匀分布，我们将每层图像分成网格（grid），每个单元格（cell）提取至少5个角点。然后检测每个单元格（cell）内的角点，如果（某个单元格）角点数量不够，就调整检测器的阈值（再检测一次）。如果某些单元格内检测不出角点（无纹理或者低对比度），则每个单元格保留的角点数量也相应调整。最后，根据保留的FAST角点计算其方向和ORB特征描述子。ORB特征描述子将用于系统后续所有的特征匹配，而不是像PTAM那样根据图像区块相关性（patchcorrelation）进行搜索。</p><h4 id="b通过前一帧估计初始位姿">B、通过前一帧估计初始位姿</h4><p>如果上一帧图像跟踪成功，我们就使用恒速运动（constant velocitymotion）模型来预测相机的位姿（即认为摄像头处于匀速运动），然后对在最后一帧中观察到的地图点进行引导搜索。如果没有找到足够多的匹配点（比如明显违反了运动模型（的规律），即非匀速运动），我们就加大以上一帧中地图点位置（为中心的）搜索范围。然后根据找到的匹配关系对位姿进行优化。</p><h4 id="c通过全局重定位来初始化位姿">C、通过全局重定位来初始化位姿</h4><p>如果（扩大了搜索范围还是）跟踪失败，则将当前帧转化为词袋（BoW）向量，并查询识别数据库中用于全局重定位的候选关键帧。然后如III-E节所描述的那样，计算每个候选关键帧中与地图点相对应的ORB特征对应关系。接着，对每个候选关键帧执行RANSAC迭代，并使用PnP算法尝试计算当前帧的位姿。如果我们找到一个具有足够多的有效点（inliers）的位姿，那么优化该位姿，并执行和候选关键帧的地图点进行更多匹配的引导搜索。最后，基于找到的所有匹配点对相机位姿进一步优化，如果有效点（inliers）足够多，则跟踪程序将持续执行。</p><h4 id="d跟踪局部地图">D、跟踪局部地图</h4><p>一旦我们有了对相机姿态的估计和一组初始特征匹配，我们就可以将地图投影到帧上，并搜索更多的地图点对应关系。为了降低大地图的复杂性，我们只投影一个<strong>局部地图</strong>。该局部地图包含一组关键帧<span class="math inline">\(K1\)</span>（它们和当前帧有共同的地图点），还包括与关键帧 <spanclass="math inline">\(K1\)</span> 在共视图中相邻的一组关键帧 <spanclass="math inline">\(K2\)</span> 。这个局部地图中有一个参考关键帧<spanclass="math inline">\(K_{ref} ∈K1\)</span>，它与当前帧具有最多共同的地图点。现在对 <spanclass="math inline">\(K1\)</span> , <spanclass="math inline">\(K2\)</span>中观测到的每个地图点，在当前帧中进行如下搜索：</p><ol type="1"><li>计算该地图点在当前帧中的投影点 <spanclass="math inline">\(x\)</span>。如果投影位置超出图像边缘，就将该地图点删除</li><li>计算当前地图点观测方向 <span class="math inline">\(v\)</span>和地图点平均观测方向 <span class="math inline">\(n\)</span> 的夹角。如果<span class="math inline">\(v\cdot n&lt; \cos(60°)\)</span>，就将该地图点删除</li><li>计算从地图点到相机光心的距离 <span class="math inline">\(d\)</span>。如果它不在地图点的尺度不变区间内，即 <spanclass="math inline">\(d∉[d_{min},d_{max}]\)</span>，就将该地图点删除</li><li>按照 <span class="math inline">\(d/d_{min}\)</span>计算当前帧的尺度</li><li>将地图点的代表特征描述子 <span class="math inline">\(D\)</span>和当前帧（位于预测的尺度层和靠近 <span class="math inline">\(x\)</span>）的未匹配ORB特征进行比较，做出最优匹配</li></ol><p>相机位姿最后通过当前帧中获得所有的地图点进行优化。</p><p><strong>补充</strong>：这个环节的目的是在当前帧和局部地图之间找到更多的匹配点对，来优化当前帧的位姿</p><h4 id="e新关键帧的判断">E、新关键帧的判断</h4><p>最后一步是决定当前帧是否可以作为新的关键帧。由于局部建图的过程中有一个剔除冗余关键帧的机制，所以我们将尝试尽可能快的插入新的关键帧以保证跟踪线程对具有挑战性的相机运动更具鲁棒性（尤其是对旋转运动）。要插入一个新的关键帧，必须满足以下所有条件：</p><ol type="1"><li><p>距离上一次全局重定位后已超过20帧</p></li><li><p>局部建图处于空闲状态，或距上一个关键帧插入后已超过20帧</p></li><li><p>当前帧跟踪至少有50个地图点</p></li><li><p>追踪中，当前帧与参考关键帧 <spanclass="math inline">\(K_{ref}\)</span>同时可观测到的（地图）点少于90%</p></li></ol><p>与PTAM中用关键帧之间的距离作为判断标准不同，我们加入一个最小的视图变换（即条件4）。条件1确保好的重定位，条件3确保好的跟踪。如果局部建图处于工作（busy）状态（即条件2的后半部分）的时候插入关键帧，则发送信号去暂停局部BA，以便尽可能快处理新的关键帧。</p><h3 id="vi.-局部建图">VI. 局部建图</h3><p>这章我们将描述根据每个新的关键帧 <spanclass="math inline">\(K_{i}\)</span> 构建局部地图的步骤。</p><h4 id="a关键帧插入">A、关键帧插入</h4><p>首先，我们更新共视图：为新关键帧 <spanclass="math inline">\(K_{i}\)</span>添加一个新节点，并更新因与其他关键帧有共同地图点（大于15个）产生的边。然后，我们更新与<span class="math inline">\(K_{i}\)</span>具有最多共同（地图）点的关键帧的生成树的链接。最后，我们计算该关键帧的词带表示，这将有助于通过数据关联来三角化新的（地图）点。</p><h4 id="b最近的地图点剔除">B、最近的地图点剔除</h4><p>地图点要想保留在地图中，必须在其创建后的前三个关键帧中通过一个严格的测试。该测试确保（留下的点都）能被跟踪，即这些点不是错误三角化（生成）的（比如由于错误的数据关联）。一个（地图）点必须满足下面两个条件：</p><ol type="1"><li>跟踪线程在预测该（地图）点可见的所有帧中找到该点的帧数占总帧数的25%以上</li><li>创建地图点之后，接下来应该至少有3个关键帧可以观察到这个地图点</li></ol><p>一旦一个地图点通过测试后，如果在任何时刻不能从三个及以上关键帧中观察到它，那么该地图点就会被剔除。当关键帧被剔除和局部BA丢弃异值点时，可能会发生这种情况。这个策略使得我们的地图包含很少的异常值（outliers）。</p><h4 id="c新地图点创建">C、新地图点创建</h4><p>新地图点的创建是通过对共视图（covisibility graph）中连接的关键帧<span class="math inline">\(K_{c}\)</span>中的ORB（特征点）进行三角化实现的。对 <spanclass="math inline">\(K_{i}\)</span>中每个未匹配的ORB（特征点），我们在其他关键帧的未匹配点中进行查找（看是否有匹配上的特征点）。这个匹配过程在III-E节中有阐述，然后将剔除那些不满足对极约束的匹配项。ORB（特征点）对三角化后，为了将其接受为新（地图）点，该点要进行位置是否在相机前方、重投影误差（小）以及尺度一致性方面的检查。起初，（虽然）一个地图点被两个关键帧观测到，但它可以与其他关键帧中进行搜索匹配，所以它可以投影到其他相连的关键帧中。搜索算法的细节在本文V-D节中有讲述。</p><h4 id="d局部ba">D、局部BA</h4><p>局部BA针对当前处理的关键帧 <span class="math inline">\(K_{i}\)</span>、所有在共视图中与 <span class="math inline">\(K_{i}\)</span>连接的关键帧 <span class="math inline">\(K_{c}\)</span>以及这些被关键帧观测的所有地图点进行优化。所有其他可以观测到这些（地图）点但（在共视图中）与<span class="math inline">\(K_{i}\)</span>没有连接的关键帧也包含在优化中（作为约束条件），但保持不变。优化过程中或者优化结束后，被标记为异常点的观测值会被剔除。有关此优化的更多细节，请参见附录。</p><h4 id="e局部关键帧筛选">E、局部关键帧筛选</h4><p>为了使重建保持简洁，局部建图尽量检测冗余的关键帧然后剔除它们。这样会有很大好处，因为随着关键帧数量的增加，BA优化的复杂度也随之增加。当系统在同一场景下运行时，除非场景有所变化，否则关键帧的数量不会无限增长。这样一来，就增强了系统在相同环境下的可持续运行性。如果关键帧<span class="math inline">\(K_{c}\)</span>中90%的（地图）点都可以被其他至少三个关键帧在相同或更精细的尺度下同时观测到（那认为<span class="math inline">\(K_{c}\)</span>是冗余的），我们就将其剔除。尺度条件确保了地图点维护的关键帧的观测它们的尺度是最精细的。这个策略受Tan等人的工作[24]的启发，在这项工作中，关键帧在经过一个变换检测的过程后被丢弃。</p><h3 id="vii.-闭环检测">VII. 闭环检测</h3><p>当局部建图线程处理完一个关键帧 <spanclass="math inline">\(K_{i}\)</span> 之后，闭环检测线程会尝试利用 <spanclass="math inline">\(K_{i}\)</span> 做回环检测。具体步骤如下。</p><h4 id="a候选回环检测">A、候选回环检测</h4><p>我们先计算 <span class="math inline">\(K_{i}\)</span>和它在共视图中相邻帧（<spanclass="math inline">\(θ_{min}=30\)</span>）的的词袋向量相似度，保留最低分值<span class="math inline">\(s_{min}\)</span>。然后，我们检索识别数据库，丢掉那些分值低于 <spanclass="math inline">\(s_{min}\)</span>的关键帧。这和DBoW2中均值化分值的操作类似，可以获得好的鲁棒性，DBoW2中计算的是前一帧图像，而我们是使用的共视（covisibility）信息。另外，所有直接连接到<span class="math inline">\(K_{i}\)</span>的关键帧都会从结果中删除。为了获得候选回环，我们必须连续检测到3个一致的候选回环（在共视图中相连的关键帧）。如果有几个与<span class="math inline">\(K_{i}\)</span>相似的地方，就可能会有几个候选回环。</p><h4 id="b计算相似变换">B、计算相似变换</h4><p>单目SLAM系统有7个自由度可能产生漂移（drift），3个平移，3个旋转和1个尺度因子[6]。因此，为了闭合回环，我们需要计算从当前关键帧 <spanclass="math inline">\(K_{i}\)</span> 到回环关键帧 <spanclass="math inline">\(K_{l}\)</span>的相似变换，以获得回环的累积误差。计算相似变换也可以作为回环的几何验证。</p><p>我们首先按照III-E节中解释的过程，计算与 <spanclass="math inline">\(K_{i}\)</span>中ORB相关联的地图点和候选回环关键帧之间的对应关系。此时，对每个候选回环，我们有了一个3D到3D的对应关系。或者，我们对每个候选（回环关键帧）执行RANSAC迭代，通过Horn方法[42]找到相似变换。如果我们用足够的有效数据（inliers）找到了相似变换<span class="math inline">\(S_{il}\)</span>，我们就可以优化它，并执行一个引导搜索（匹配）更多的对应关系。再此进行优化，如果<span class="math inline">\(S_{il}\)</span> 有足够多的有效数据支持时，<span class="math inline">\(K_{l}\)</span> 回环就被接受。</p><h4 id="c回环融合">C、回环融合</h4><p>回环矫正的第一步是融合重复的地图点，在共视图中插入与回环相关的的新边。首先，通过相似变换<span class="math inline">\(S_{il}\)</span> 矫正当前关键帧位姿 <spanclass="math inline">\(T_{iw}\)</span> ，并将该矫正传播到所有与 <spanclass="math inline">\(K_{i}\)</span>相邻的关键帧，连接转换，以便使回环的两侧进行对齐。然后，回环关键帧及其相邻（的关键帧）能观测到的所有地图点都投影到<span class="math inline">\(K_{i}\)</span> 以及与 <spanclass="math inline">\(K_{i}\)</span>相邻（的关键帧）上，并在投影的区域附近小范围内搜索它的对应匹配点，就像V-D节所做的那样。所有匹配的地图点和计算<span class="math inline">\(S_{il}\)</span>过程中的有效数据（inliers）都被融合。融合过程中涉及的所有关键帧将会更新它们在共视图中的边，创建的新边将用于闭合回环。</p><h4 id="d本质图优化">D、本质图优化</h4><p>如III-D节所示，为了有效地闭合回环，我们通过本质图（EssentialGraph）优化位姿图，这样可以将回环闭合的误差通过（本质）图传播。对相似性变换进行优化，以校正尺度漂移[6]。误差条件和损失函数详见附录。优化过后，每个地图点都根据可以观测到它的一个关键帧的校正进行变换。</p><h3 id="viii.-实验">VIII. 实验</h3><p>略</p><h3 id="ix.-结论和讨论">IX. 结论和讨论</h3><h4 id="a结论">A、结论</h4><p>略</p><h4 id="b稀疏特征点-vs.-稠密直接法">B、稀疏/特征点 vs. 稠密/直接法</h4><p>略</p><h4 id="c未来工作">C、未来工作</h4><p>我们系统的精度可以通过结合无限远点跟踪来进一步增强。这些没有足够视差的点，并没有包含在本文系统构建的地图中，但它们提供了相机旋转的信息[21]。</p><p>另一条路是将稀疏地图升级到一个更加稠密、对重建更实用的地图。由于我们关键帧的选择机制，关键帧包括一个紧凑的环境总结与非常高的姿态精度和丰富的共视信息。所以，ORB-SLAM稀疏地图是一个非常优秀的初始估计框架，可以在此基础上构建一个稠密而准确的场景地图。本条路第一个尝试工作在[47]中展示。</p><h3 id="附录非线性优化">附录：非线性优化</h3><p>略</p><h3 id="参考文献">参考文献</h3><p>略</p><h3 id="pdf原文">PDF原文</h3><div><p><iframe src="/pdfjs/web/viewer.html?file=/pdf/robot/ORB-SLAM1.pdf" width="100%" height="1280px" frameborder="0"></iframe></p></div><p>参考链接：</p><ol type="1"><li>https://blog.csdn.net/weixin_42905141/article/details/102857958</li><li>https://zhehangt.github.io/2017/04/20/SLAM/ORBSLAM/ORBSLAMPaper/</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;摘要&quot;&gt;摘要&lt;/h3&gt;
&lt;p&gt;本文提出了ORB-SLAM，这是一种在大小场景、室内室外环境下都可以实时运行的基于特征的单目SLAM系统。系统对复杂的剧烈运动具有鲁棒性，允许宽基线的闭环和重定位，且包含完整的自动初始化。在最近几年的优秀算法基础上，我们从头开始设计了
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="paper" scheme="https://silencht.github.io/categories/robot/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>orbslam2-translation</title>
    <link href="https://silencht.github.io/wiki/robot/paper/orbslam2-translation/"/>
    <id>https://silencht.github.io/wiki/robot/paper/orbslam2-translation/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="摘要">摘要</h3><p>本文提出了ORB-SLAM2，它是基于单目、双目和RGB-D相机的一个完整的SLAM系统，该系统包括地图复用、回环检测和重定位功能。这个系统可以适用于多种环境，无论是室内小型手持设备，还是工厂环境中飞行的无人机和城市中行驶的车辆，其都可以在标准CPU上实时运行。该系统的后端使用基于单目和双目观测的光束法平差法（bundleadjustment），这使得其可以精确估计轨迹的尺度。该系统包含一个轻量级的定位模式，它使用视觉里程计追踪未建图区域并匹配地图点，实现零漂移定位。在29个常用公开数据集上的实验评估显示本文方法在大多数情况下是精度最高的SLAM解决方案。我们公开了该系统的源代码，不仅是为了造福SLAM社区，同时也给其他领域的研究者提供一套能够开箱即用的SLAM解决方案。</p><h3 id="i.-引言">I. 引言</h3><p>同时定位建图（SLAM）在过去二十年中一直是计算机视觉和机器人领域的研究热点，最近它也吸引了高科技企业的关注。SLAM技术对未知环境进行建图，同时实时地在地图中定位传感器的位置。在不同传感器中，相机相对便宜，同时能够提供鲁棒准确的位置识别所需的丰富的环境信息，所以以摄像头为主要传感器的视觉SLAM解决方案，是当前最受青睐的研究热点。位置识别是SLAM系统中实现回环检测（当检测到传感器回到已建图区域时，修正探索过程中的累积误差）的关键模块，它能够在因遮挡或剧烈运动导致追踪失败后以及系统重新初始化时，重定位相机的位置。</p><p>视觉SLAM只需一个单目相机即可实现，这是最便宜也是最小的传感器设备。但是，仅靠一个单目相机无法观测到深度信息，所以地图和估计轨迹的尺度是未知的。另外，由于单目视觉SLAM系统无法仅根据第一帧图像进行三角化测量（triangulate），所以系统启动时需要多个视角或者滤波技术来生成一个初始地图。同时，单目SLAM会造成尺度漂移，在纯旋转的探索过程中可能会失败。不过，通过使用双目或者RGB-D相机，这些问题都可以被解决，从而实现更可靠的视觉SLAM解决方案。</p><p>本文中，在我们之前提出的单目ORB-SLAM的基础上，我们进一步提出了ORB-SLAM2，它有以下贡献：</p><ul><li>第一个开源的基于单目、双目、RGB-D相机的SLAM系统，其中包括回环检测、重定位、以及地图重用功能。</li><li>我们的RGB-D结果显示，相比较目前最好的基于迭代最近点法（ICP）或广度和深度误差最小法，我们通过使用光束法平差法（BA），可以达到更高的精度。</li><li>通过使用远近匹配双目点和单目观测，我们的双目结果比目前最好的直接双目SLAM的精度更高。</li><li>提出了一个轻量级的重定位模式，它可以在无法建图时，有效地重新使用地图。</li></ul><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210902143622836.png" alt="image-20210902143622836" style="zoom:33%;" /></p><center>图a</center><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210902143645915.png" alt="image-20210902143645915" style="zoom:33%;" /></p><center>图b</center><center>图 1 ORB-SLAM2对双目和RGB-D输入进行处理，估计相机轨迹，并建立环境的地图。该系统能够该系统能够实时地在标准CPU上进行闭合回环，重定位，重用地图，并具有高精度和高鲁棒性。</center><p>图 1展示了双目和RGB-D输入下ORB-SLAM2系统的输出。其中双目的例子展示了KITTI数据集00序列的最终估计轨迹和稀疏重建结果。这是一个具有多个回环闭合的城市场景数据序列，ORB-SLAM2系统成功检测到了这些回环。RGB-D的例子展示了TUMRGB-D数据集中的frl-room序列的关键帧位姿估计结果及所得到的稠密点云，其中稠密点云是根据关键帧位姿，将传感器深度图反向投影所得到的。需要注意的是，ORB-SLAM2系统并没有像KinectFusion之类的系统一样进行任何融合，但是却能够精确地估计关键帧位姿。附件视频中将会展示更多的例子。</p><p>本文余下章节中，我们将会在第2节中讨论相关工作，在第3节中介绍我们的系统，在第4节中给出实验评估结果，最后在第5节中进行总结。</p><h3 id="ii.-相关工作">II. 相关工作</h3><p>在本节中，我们将会讨论双目和RGB-DSLAM的相关工作。本节中的讨论和第四节中的评估只针对SLAM方法。</p><h4 id="a双目slam">A、双目SLAM</h4><p>Paz等人曾做出了一个早期的卓越的双目SLAM系统[5]，他们基于条件独立分治的扩展卡尔曼滤波SLAM（EKF-SLAM），使该系统在那个年代相比较其他方式可以在更大的场景中运行。最重要的是，它是第一个同时使用近特征点和远特征点（由于该点在双目相机中的视差较小，使其深度无法得到可靠估计），并对后者使用逆深度参数估计[6]。他们经验性地指出，当特征点的深度小于双目相机基线长度的40倍时，特征点可以被可靠地三角化。本文工作中我们延续了这种用不同方式处理近特征点和远特征点的策略，这部分内容将在3.1节中进行解释。</p><p>大多数现代的双目SLAM系统是基于关键帧[7]和局部BA优化来实现可伸缩性（scalability）。Strasdat等人的工作[8]在关键帧窗内采用BA优化（点-位姿约束），在关键帧窗外采用位姿图优化（位姿-位姿优化）。通过限制窗的大小，该方法可以实现恒定的时间复杂度，但无法保证全局一致性。Mei等人提出了RSLAM方法[9]，其使用了地标和位姿的相对位置表示法，并在限制时间复杂度的条件下，在激活区域内采用相对BA。RSLAM可以实现回环的闭合，这可以扩展回环两端的激活区域，但并不能增强全局一致性。最近Pire等人提出的S-PTAM[10]采用了局部BA，但它缺少闭合大回环的功能。与这些方法类似，我们也在局部关键帧集合中采用了BA，因此该方法的复杂度不受地图尺寸影响，我们可以在大场景中实施该方法。但是，我们的目标是建立一个全局一致的地图。与RSLAM类似，当闭合一个回环时，我们的系统会首先将两端对齐，因此追踪模块可以使用旧地图继续定位，之后采用位姿图优化来最小化回环中的累积漂移，再之后进行全局BA。</p><p>最近Engel等人提出的双目LSD-SLAM[11]是一种半稠密的方法，它最小化图像梯度较大区域的光度误差。该方法希望在不依赖特征的条件下，在运动模糊或纹理较弱的环境下获得更好的鲁棒性。但是，作为直接法，该方法的性能会由于未建模因素而显著下降，例如卷帘快门或非朗伯反射。</p><h4 id="brgb-d-slam">B、RGB-D SLAM</h4><p>Newcombe等人提出的KinectFusion [4]是最早也是最著名的RGB-DSLAM系统之一。该方法将传感器得到的所有深度数据融合至一个稠密的体积模型，并使用ICP来追踪相机位姿。由于该系统使用体积表示形式并且缺少回环检测，它只能应用于小规模的工作空间。Whelan等人提出的Kintinuous[12]使用了一个滚动循环缓冲区，并且包括了一个使用位置识别和位姿图优化的回环检测模块，从而能够在大规模场景运行。</p><p>Endres等人提出的RGB-D SLAM[13]可能是最早流行的开源系统。它是一个基于特征的系统，它的前端通过特征匹配和ICP来计算帧间的运动，它的后端使用位姿图优化，其回环检测约束条件由启发式搜索得到。与之相似，Kerl等人提出的DVO-SLAM[14]的后端也采用位姿图优化，其中关键帧之间的约束是由一个最小化光度和深度误差的视觉里程计计算得到。同时，DVO-SLAM在以往所有帧中启发式地搜索回环的候选者，而不依赖于位置识别。</p><p>最近Whelan等人提出的ElasticFusion[15]建立了环境的surfel地图，这是一种忽略位姿，而以地图为核心的方法，它采用对地图进行非刚性变形的方式来实现回环闭合，而不是采用位姿图优化的方法。该系统细节重建和定位精度是非常优秀的，但是由于地图中面元数量所带来的复杂度，目前它仍局限于建立房间大小的地图。</p><p>我们的ORB-SLAM2系统使用了一种Strasdat等人提出的方法[8]，该方法使用深度信息来为图像中提取的特征合成立体坐标。通过这种方法，我们的系统可以处理来自双目或者RGB-D的输入。与上述所有方法不同的是，我们方法的后端基于BA，并且能够得到一个全局一致的稀疏重建。因此我们的方法是轻量级的，可以在标准CPU上运行。我们的目标是实现长期并且全局一致的定位，而不是进行具有更多细节的稠密重建。但是，我们的方法也可以通过精度很高的关键帧位姿，进行深度图融合来实时地对局部环境进行准确重建，或者在全局BA后对所有关键帧的深度图进行处理从而得到整个场景的精准三维模型。</p><h3 id="iii.-orb-slam2">III. ORB-SLAM2</h3><p>基于双目和RGB-D相机的ORB-SLAM2是建立在我们的基于特征的单目ORB-SLAM[1]的基础上的。为读者方便，我们在这里总结一下单目ORB-SLAM的基本组成部分。总体概述了该系统基于双目和RGB-D相机的ORB-SLAM2是建立在我们的基于特征的单目ORB-SLAM的基础上的。为读者方便，我们在这里总结一下单目ORB-SLAM的基本组成部分。图2ORB-SLAM2由三个主要的并行线程组成：追踪、局部建图和回环检测。在回环检测后会执行第四个线程，进行全局BA。追踪线程会对双目和RGB-D输入进行预处理，从而使得系统其它部分可以独立于输入传感器运行。虽然这张图没有展示，但ORB-SLAM2也可以基于单目输入运行。图2总体概览了该系统。该系统具有三个主要的并行线程：1）追踪线程是用来在每一帧中定位相机的位置，通过匹配特征和局部地图并且进行运动BA（motion-onlyBA）最小化重投影误差；2）局部建图线程是用来管理和优化局部地图；3）回环检测线程是用来检测大回环，并通过执行位姿图优化来修正累积误差。该线程在位姿图优化后会启动第四个线程来执行全局BA，计算最优的结构和运动结果。</p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210902144136659.png" /></p><center>图 2ORB-SLAM2由三个主要的并行线程组成：追踪、局部建图和回环检测。在回环检测后会执行第四个线程，进行全局BA。追踪线程会对双目和RGB-D输入进行预处理，从而使得系统其它部分可以独立于输入传感器运行。虽然这张图没有展示，但ORB-SLAM2也可以基于单目输入运行[1]。(a)系统的线程和模块(b)输入的预处理</center><p>该系统嵌入了一个基于DBoW2[16]的位置识别模块，在发生追踪失败（例如：碰撞）或者在建好图的场景中重新初始化时用来进行重定位，以及用来进行回环检测。该系统维护了一个关联可见地图（convisiblemap）[8]，此地图将每两个观察到相同地图点的关键帧连接到一起；同时该系统也维护了一个最小生成树，它连接了所有的关键帧。这种地图结构实现了对于关键帧局部窗的检索，因此追踪线程和局部建图线程可以局部地运行，使其可以在大场景中工作；同时该结构在回环闭合进行位姿图优化时，也可作为优化的图结构。</p><p>该系统在追踪、建图和位置识别任务中，都使用相同的ORB特征[17]。这些特征对于旋转和尺度变化具有很好的鲁棒性，同时对于相机的自动增益、自动曝光和光线变化也具有不变性。另外，提取和匹配ORB特征的速度很快，使其可以实时运行，并且在词袋模型位置识别任务上表现出良好的查准率/查重率（precision/recall）[18]。</p><p>在本节的余下部分中，我们会展示如何使用双目/深度信息，以及系统的哪些部分将会被影响。关于该系统每一部分更详尽的描述，请参考我们的单目ORB-SLAM论文[1]。</p><h4id="a单目近处立体和远处立体关键点">A、单目、近处立体和远处立体关键点</h4><p>作为一种基于特征的方法，ORB-SLAM2会对输入进行预处理，在显著关键点位置提取特征，如图2b所示。接下来，输入的图片会被丢弃，系统的全部运算会基于这些特征，因此无论是双目还是RGB-D输入，本系统都可以工作。我们的系统会处理单目和双目的关键点，这些点又会被分为近处点和远处点。</p><p>立体（双目）关键点通过三维坐标 <spanclass="math inline">\(x_s=(u_L,v_L,u_R )\)</span> 来定义，<spanclass="math inline">\((u_L,v_L )\)</span> 是关键点在左图的坐标，<spanclass="math inline">\(u_R\)</span>是关键点在右图的水平坐标。对于双目相机，我们在左右两张图片中同时提取ORB特征。对于左图中的每个ORB特征，我们在右图中搜索一个相应的匹配。对于校正后的双目图像来说，极线是水平的，所以上述任务可以很高效地完成。之后我们根据左图ORB特征坐标和右图相匹配的特征水平坐标来生成立体关键点。对于RGB-D相机，正如Strasdat等人所言[8]，我们在RGB图像上提取ORB特征，对于每个坐标为<spanclass="math inline">\((u_L,v_L )\)</span>的特征，我们根据它的深度值<span class="math inline">\(d\)</span> 计算出一个虚拟的右图坐标： <spanclass="math display">\[u_R=u_L-(f_x b)/d\]</span> 其中 <span class="math inline">\(f_x\)</span>是水平焦距；<span class="math inline">\(b\)</span>是结果光投影机和红外相机之间的基线长度，在Kinect和AsusXtion相机中我们将其大概设定为8厘米。深度传感器的不确定性由虚拟的右坐标表示。通过这种方式，系统余下部分可以以相同的方法处理来自双目或者RGB-D输入的特征。</p><p>正如文献[5]所述，如果一个立体关键点的深度值小于双目/RGB-D的基线长度的40倍，则认为它是近处点，否则认为它是远处点。近处关键点可以被安全地三角化，因为它的深度可被精确估计，且提供了尺度、平移和旋转的信息。另一方面，远处关键点虽然提供了精确的旋转信息，但不能提供精确的尺度和平移信息。所以当远处关键点在多个视图中存在时，我们才对其进行三角化。</p><p>单目关键点通过左图中的二维坐标 <spanclass="math inline">\(x_m=(u_L,v_L)\)</span>定义，若ORB特征的双目匹配失效或者RGB-D相机无法得到其有效深度值，则采用此方式。这些点只会在多视图时进行三角化，且不会提供尺度信息，但它们可用于旋转和平移估计。</p><h4 id="b系统启动">B、系统启动</h4><p>使用双目或者RGB-D相机的最主要的好处之一是，我们可以直接获得单帧图像的深度信息，不用像在单目SLAM中一样需要使用特定的SFM（structurefrommotion）初始化。在系统启动时，我们将第一帧设为关键帧，将其位姿设置为初始位姿，并且根据所有的立体关键点来建立一个初始地图。</p><h4id="c单目和双目约束下的光束优化法ba">C、单目和双目约束下的光束优化法（BA）</h4><p>我们的系统在追踪线程中使用BA来优化相机位姿（纯运动BA），在局部建图线程中优化关键帧和点的局部窗（局部BA），在回环检测后优化所有的关键帧和点（全局BA）。我们使用g2o[19]中的实现的Levenberg-Marquardt方法来进行优化。</p><p>纯运动BA（motion-only BA）优化相机的旋转矩阵 <spanclass="math inline">\(\mathbf{R} \in S O(3)\)</span> 和位置 <spanclass="math inline">\(\mathbf{t} \in \mathbb{R}^{3}\)</span>，最小化相匹配的世界坐标系下的三维点 <spanclass="math inline">\(\mathbf{X}^{i} \in \mathbb{R}^{3}\)</span>和关键点 <span class="math inline">\(\mathbf{x}_{(\cdot)}^{i}\)</span>之间的重投影误差（单目点 <spanclass="math inline">\(\mathbf{x}_{\mathrm{m}}^{i} \in\mathbb{R}^{2}\)</span> 或者双目点 <spanclass="math inline">\(\mathbf{x}_{\mathrm{s}}^{i} \in\mathbb{R}^{3}\)</span>，对于所有匹配对 <span class="math inline">\(i\in \mathcal{X}\)</span> ）： <span class="math display">\[\{\mathbf{R}, \mathbf{t}\}=\underset{\mathbf{R},\mathbf{t}}{\operatorname{argmin}} \sum_{i \in \mathcal{X}}\rho\left(\left\|\mathbf{x}_{(\cdot)}^{i}-\pi_{(\cdot)}\left(\mathbf{R}\mathbf{X}^{i}+\mathbf{t}\right)\right\|_{\Sigma}^{2}\right)\]</span> 其中 <span class="math inline">\(ρ\)</span>是鲁棒Huber代价函数， <span class="math inline">\(\sum\)</span>是关键点尺度的协方差矩阵。其中投影函数 <spanclass="math inline">\(\pi_{(\cdot)}\)</span> ，单目投影函数 <spanclass="math inline">\(\pi_{(m)}\)</span> ，校正双目投影函数 <spanclass="math inline">\(\pi_{(s)}\)</span> 如下定义： <spanclass="math display">\[\pi_{\mathrm{m}}\left(\left[\begin{array}{l}X \\Y \\Z\end{array}\right]\right)=\left[\begin{array}{l}f_{x} \frac{X}{Z}+c_{x} \\f_{y} \frac{Y}{Z}+c_{y}\end{array}\right], \pi_{\mathrm{s}}\left(\left[\begin{array}{l}X \\Y \\Z\end{array}\right]\right)=\left[\begin{array}{c}f_{x} \frac{X}{Z}+c_{x} \\f_{y} \frac{Y}{Z}+c_{y} \\f_{x} \frac{X-b}{Z}+c_{x}\end{array}\right]\]</span> 其中 <span class="math inline">\(\left(f_x,f_y\right)\)</span>是焦距，<span class="math inline">\(\left(c_x,c_y\right)\)</span>是光心点，<span class="math inline">\(b\)</span>是基线长度，这些值都通过标定得到。</p><p>全局BA是局部BA的一种特殊情况，在全局BA中，除了初始关键帧因用来消除计算自由度而被固定之外，所有关键帧和地图点都会被优化。</p><p>局部BA对一个关联可见的关键帧 <spanclass="math inline">\(\mathcal{K}_L\)</span>集合和这些关键帧中所有可见的点 <spanclass="math inline">\(\mathcal{P}_L\)</span> 。所有不在 <spanclass="math inline">\(\mathcal{K}_L\)</span> 中，但也观测到 <spanclass="math inline">\(\mathcal{P}_L\)</span> 中的点的其它关键帧 <spanclass="math inline">\(\mathcal{K}_F\)</span>，也会参与到代价函数的计算中，但是不会被优化。我们将 <spanclass="math inline">\(\mathcal{P}_L\)</span>中的点与关键帧k中的关键点之间的匹配对的集合定义为 <spanclass="math inline">\(\mathcal{X}_k\)</span> ，将优化问题进行如下定义：<span class="math display">\[\begin{array}{c}\left\{\mathbf{X}^{i}, \mathbf{R}_{l}, \mathbf{t}_{l} | i \in\mathcal{P}_{L}, l \in \mathcal{K}_{L}\right\}=\underset{\mathbf{X}^{i},\mathbf{R}_{l}, \mathbf{t}_{l}}{\operatorname{argmin}} \sum_{k \in\mathcal{K}_{L} \cup \mathcal{K}_{F}} \sum_{j \in \mathcal{X}_{k}}\rho\left(E_{k j}\right) \\E_{kj}=\left\|\mathbf{x}_{(\cdot)}^{j}-\pi_{(\cdot)}\left(\mathbf{R}_{k}\mathbf{X}^{j}+\mathbf{t}_{k}\right)\right\|_{\Sigma}^{2}\end{array}\]</span>全局BA是局部BA的一种特殊情况，在全局BA中，除了初始关键帧因用来消除计算自由度而被固定之外，所有关键帧和地图点都会被优化。</p><h4 id="d回环检测和全局ba">D、回环检测和全局BA</h4><p>回环检测分两步进行：第一步是检测和确认回环，第二步是通过优化位姿图来修正回环。相较于单目ORB-SLAM可能会发生尺度漂移[20]，双目/深度信息会使尺度变得可以观测，所以几何验证和位姿图优化不再需要处理尺度漂移；同时它是基于刚体变换，而不是基于相似性。</p><p>在ORB-SLAM2中，我们在位姿图优化后，采用全局BA优化来得到最优解。这个优化过程可能开销会很大，所以我们将其放在一个独立的线程中，从而使得系统可以持续建立地图、检测回环。但这样的话，将BA输出与当前地图状态之间进行融合就会产生困难。如果在优化运行的同时发现了新的回环，那么我们就停止优化，转而去闭合回环，这将再次启动全局BA优化。当全局BA完成时，就需要将全局BA优化更新后的关键帧和点的集合，与在优化过程中插入的未更新的关键帧和点，进行融合。这通过将更新的关键帧的修正（未优化位姿至优化位姿的变换）沿生成树传递至未更新的关键帧来完成。未更新的点依据它们的参考帧的修正来进行变换。</p><h4 id="e关键帧的插入">E、关键帧的插入</h4><p>ORB-SLAM2沿用了单目ORB-SLAM中介绍的策略：频繁插入关键帧，之后再剔除冗余的关键帧。近处立体点和远处立体点之间的区别使我们在插入关键帧时可以引入一个新的条件，当环境中存在很大一块场景远离双目传感器时，这是非常重要的，如图3所示。在这样的环境中，我们需要有足够多的的近处点来精确地估计平移量，因此，当追踪的近处点数目低于<span class="math inline">\(\tau_{t}\)</span> 并且此帧能够创建至少 <spanclass="math inline">\(\tau_{c}\)</span>个新的近处立体点时，系统就会插将此帧作为一个新的关键帧插入。根据经验，根据经验，在我们的实验中，<span class="math inline">\(\tau_{t}=100 ,\tau_{c}=70\)</span>的效果较好。</p><p><imgsrc="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210902145958035.png" /></p><center>图 3 KITTI01中的追踪点。绿色点表示深度值小于40倍双目基线长度的点，蓝色点表示更远的点。在这种视频序列中，需要频繁地插入关键帧，使近处点的总数满足精确估计平移量的要求。远处点可用于估计旋转量，但对于估计平移量和尺度帮助不大。</center><h4 id="f定位模式">F、定位模式</h4><p>我们的系统包括了一个定位模式，只要环境没有大的变化，该模式就可以在建图良好的区域中有效地进行轻量级的长期定位。在此模式中，局部建图线程和回环检测线程是停用的，如果需要的话，相机会持续通过追踪线程的重定位功能进行定位。在此模式中，追踪线程会使用视觉里程计中的匹配对，并将其与地图点进行匹配。视觉里程计中的匹配对是指当前帧中的ORB特征和之前帧根据双目/深度信息所创建的三维点之间的匹配对。这些匹配对使得定位功能在未建图区域更加鲁棒，但是会产生累积漂移。与地图点的匹配保证了在已建图区域的定位是零漂移的。此模式会在附带的视频中进行展示说明。</p><h3 id="iv.-评估">IV. 评估</h3><p>略</p><h3 id="v.-结论">V. 结论</h3><p>我们提出了一个完整地基于单目、双目或RGB-D传感器的SLAM系统，其可以在标准CPU上实时实现重定位、回环检测和重用地图。我们的重点在于建立全局一致的地图，用于在实验中所介绍的大规模环境中进行长期定位。我们提出的包含重定位功能的定位模式，是一种可以在已知环境中进行鲁棒的、零漂移的、轻量级的定位方法。该模式可适用于特定应用，例如在环境建图良好的虚拟现实中追踪使用者的视点。</p><p>与当前最好的SLAM系统的对比，ORB在大多数情况下达到了最高的精度。在KITTI视觉里程计基准测试中，ORB-SLAM2是目前最好的双目SLAM解决方案。很重要的是，与最近流行的双目视觉里程计方法相比，ORB-SLAM2实现了在已建图区域的零漂移定位。</p><p>令人惊讶的是，我们的RGB-D结果显示，如果需要精度最高的相机定位，那么BA的表现比直接法或ICP更好，另外它的计算量也更小，不需要依赖GPU就可以实时运行。</p><p>我们发布了系统源代码、例子和使用说明，因此其他研究者可以很方便地使用本系统。据我们所知，ORB-SLAM2是第一个在单目、双目或RGB-D输入下都可以工作的开源视觉SLAM系统。另外，我们的源代码包括了一个增强现实的应用例子，其使用单目相机，用于展示我们的解决方案的可能性。</p><p>未来的研究方向可能包括：非重叠多幅相机、鱼眼相机、全景相机支持，大规模稠密融合、协作建图以及增强运动模糊的鲁棒性。</p><h3 id="pdf原文">PDF原文</h3><div><p><iframe src="/pdfjs/web/viewer.html?file=/pdf/robot/ORB-SLAM2.pdf" width="100%" height="1280px" frameborder="0"></iframe></p></div><p>参考链接：</p><ol type="1"><li>https://www.cnblogs.com/MingruiYu/p/12991119.html</li><li>https://zhehangt.github.io/2017/04/24/SLAM/ORBSLAM/ORBSLAM2Paper/</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;摘要&quot;&gt;摘要&lt;/h3&gt;
&lt;p&gt;本文提出了ORB-SLAM2，它是基于单目、双目和RGB-D相机的一个完整的SLAM系统，该系统包括地图复用、回环检测和重定位功能。这个系统可以适用于多种环境，无论是室内小型手持设备，还是工厂环境中飞行的无人机和城市中行驶的车辆，其都
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="paper" scheme="https://silencht.github.io/categories/robot/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>ros error solve</title>
    <link href="https://silencht.github.io/wiki/robot/ros/ros-error-solve/"/>
    <id>https://silencht.github.io/wiki/robot/ros/ros-error-solve/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="failed-to-load-library-libgrid_map_rviz_plugin.so">1. Failed toload library libgrid_map_rviz_plugin.so</h2><p>grid_map 的 rviz 插件出现错误，导致无法显示GridMap类型的地图.错误信息如下：</p><blockquote><p>GridMap The class required for this display,'grid_map_rviz_plugin/GridMap', could not be loaded. Error: Failed toload library /opt/ros/noetic/lib//libgrid_map_rviz_plugin.so. Make surethat you are calling the PLUGINLIB_EXPORT_CLASS macro in the librarycode, and that names are consistent between this macro and your XML.Error string: Could not load library (Poco exception =libgrid_map_core.so: cannot open shared object file: No such file ordirectory)</p></blockquote><h3 id="解决方法">解决方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/ros/noetic/lib</span><br><span class="line"><span class="built_in">ls</span> | grep grid</span><br><span class="line">changhe@changhe:/opt/ros/noetic/lib$ <span class="built_in">ls</span> | grep grid</span><br><span class="line">grid_map_demos</span><br><span class="line">grid_map_loader</span><br><span class="line">grid_map_visualization</span><br><span class="line">libgrid_map_cv.so</span><br><span class="line">libgrid_map_octomap.so</span><br><span class="line">libgrid_map_ros.so</span><br><span class="line">libgrid_map_rviz_plugin.so</span><br><span class="line">libvoxel_grid.so</span><br><span class="line"><span class="comment">#发现是有libgrid_map_rviz_plugin.so库的，继续查看该库的依赖信息</span></span><br><span class="line">changhe@changhe:/opt/ros/noetic/lib$ ldd libgrid_map_rviz_plugin.so </span><br><span class="line">linux-vdso.so.1 (0x00007ffe6f79e000)</span><br><span class="line">librviz.so =&gt; /opt/ros/noetic/lib/librviz.so (0x00007ff49eeaf000)</span><br><span class="line">libOgreMain.so.1.9.0 =&gt; /lib/x86_64-linux-gnu/libOgreMain.so.1.9.0 (0x00007ff49e8da000)</span><br><span class="line">libgrid_map_ros.so =&gt; /opt/ros/noetic/lib/libgrid_map_ros.so (0x00007ff49e887000)</span><br><span class="line">libgrid_map_core.so =&gt; not found</span><br><span class="line">libclass_loader.so =&gt; /opt/ros/noetic/lib/libclass_loader.so (0x00007ff49e85a000)</span><br><span class="line">libmessage_filters.so =&gt; /opt/ros/noetic/lib/libmessage_filters.so (0x00007ff49e850000)</span><br><span class="line">……略</span><br><span class="line"><span class="comment">#果然，其中有一个依赖libgrid_map_core.so =&gt; not found找不到。原因是几天前手动将该库删除过。现在将grid_map源码编译后的库复制过来即可</span></span><br><span class="line">changhe@changhe:/opt/ros/noetic/lib$ <span class="built_in">cd</span> ~/grid_map_core/lib/</span><br><span class="line">changhe@changhe:~/grid_map_core/lib$ <span class="built_in">ls</span></span><br><span class="line">libgrid_map_core.so</span><br><span class="line">changhe@changhe:~/grid_map_core/lib$ sudo <span class="built_in">cp</span> libgrid_map_core.so /opt/ros/noetic/lib/</span><br><span class="line"><span class="comment">#再次打开rviz，add GridMap类型，发现错误果然消失了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;failed-to-load-library-libgrid_map_rviz_plugin.so&quot;&gt;1. Failed to
load library libgrid_map_rviz_plugin.so&lt;/h2&gt;
&lt;p&gt;grid_map 的 rviz 插件出现
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="ros" scheme="https://silencht.github.io/categories/robot/ros/"/>
    
    
  </entry>
  
  <entry>
    <title>ros1</title>
    <link href="https://silencht.github.io/wiki/robot/ros/ros1/"/>
    <id>https://silencht.github.io/wiki/robot/ros/ros1/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="零参考链接">零、参考链接</h2><p>https://www.bilibili.com/video/BV1zt411G7Vn</p><p>http://wiki.ros.org/cn/ROS/Tutorials/</p><h2 id="一ros安装">一、ROS安装</h2><h3 id="参考网址">1.1 参考网址</h3><p>http://wiki.ros.org/melodic/Installation/Ubuntu</p><h3 id="安装步骤">1.2 安装步骤</h3><h4 id="setup-your-sources.list">1.2.1 Setup your sources.list</h4><p>软件源镜像版参考页面：http://wiki.ros.org/ROS/Installation/UbuntuMirrors</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">&#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br><span class="line"><span class="comment">#下面这个是清华镜像版，推荐</span></span><br><span class="line">sudo sh -c <span class="string">&#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="set-up-your-keys">1.2.2 Set up your keys</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure><h4 id="installation-ros">1.2.3 Installation ROS</h4><ul><li>First, make sure your Debian package index is up-to-date:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><ul><li><strong>Desktop-Full Install: (Recommended)</strong> : ROS, <ahref="http://wiki.ros.org/rqt">rqt</a>, <ahref="http://wiki.ros.org/rviz">rviz</a>, robot-generic libraries, 2D/3Dsimulators and 2D/3D perception</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure><h4 id="environment-setup">1.2.4 Environment setup</h4><p>It's convenient if the ROS environment variables are automaticallyadded to your bash session every time a new shell is launched:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/melodic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="dependencies-for-building-packages">1.2.5 Dependencies forbuilding packages</h4><p>Up to now you have installed what you need to run the core ROSpackages. To create and manage your own ROS workspaces, there arevarious tools and requirements that are distributed separately. Forexample, <a href="http://wiki.ros.org/rosinstall">rosinstall</a> is afrequently used command-line tool that enables you to easily downloadmany source trees for ROS packages with one command.</p><p>To install this tool and other dependencies for building ROSpackages, run:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure><h4 id="initialize-rosdepoptional">1.2.6 Initializerosdep（optional）</h4><p>Before you can use many ROS tools, you will need to initialize<code>rosdep</code>. <code>rosdep</code> enables you to easily installsystem dependencies for source you want to compile and is required torun some core components in ROS. If you have not yet installed<code>rosdep</code>, do so as follows.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python-rosdep</span><br></pre></td></tr></table></figure><p>With the following, you can initialize <code>rosdep</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若因网络问题执行不通，利用rosdep_update.md文件解决</span></span><br><span class="line">sudo rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><h3 id="测试安装">1.3 测试安装</h3><ul><li>启动ROS Master，输出如下图</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210520172849724.png" alt="image-20210520172849724" style="zoom: 50%;" /></p><ul><li>启动小海龟仿真器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210520173025132.png" alt="image-20210520173025132" style="zoom: 67%;" /></p><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210520173142478.png" alt="image-20210520173142478" style="zoom:50%;" /></p><ul><li>启动海龟控制节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210520173127843.png" alt="image-20210520173127843" style="zoom: 80%;" /></p><h2 id="二ros概念">二、ROS概念</h2><h3 id="节点">2.1 节点</h3><h4 id="node执行单元">2.1.1 Node——执行单元</h4><p>节点实际上只不过是ROS软件包中的一个可执行文件。ROS节点使用ROS<ahref="http://wiki.ros.org/cn/Client%20Libraries">客户端库</a>与其他节点通信。节点可以发布或订阅话题，也可以提供或使用<ahref="http://wiki.ros.org/Services">服务</a>。</p><ul><li>执行具体任务的进程、独立运行的可执行文件</li><li>不同节点可使用不同编程语言，可分布式运行在不同主机</li><li>节点在系统中命名必须唯一</li></ul><h4 id="ros-master控制中心">2.1.2 ROS Master——控制中心</h4><ul><li>为节点提供命名和注册服务</li><li>跟踪和记录<strong>话题/服务</strong>通信，辅助节点相互查找、建立连接</li><li>提供参数服务器，节点使用此服务器存储和检索运行时的参数</li></ul><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210520174556384.png" alt="image-20210520174556384" style="zoom: 67%;" /></p><h3 id="通信">2.2 通信</h3><h4 id="话题通信">2.2.1 话题通信</h4><h5 id="话题topic异步通信">1、 话题Topic——异步通信</h5><ul><li>节点间用来传输数据的重要总线</li><li>使用<strong>发布publish/订阅subscribe</strong>模型，数据由发布者传输到订阅者，同一个话题的订阅者或发布者可以<strong>不唯一</strong></li></ul><h5 id="消息message话题数据">2、 消息Message——话题数据</h5><ul><li>具有一定的类型和数据结构，包括ROS提供的标准类型和用户自定义类型</li><li>使用编程语言无关的.msg文件定义，编译过程中产生对应的代码文件</li></ul><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210521160350305.png" alt="image-20210521160350305" style="zoom:67%;" /></p><h4 id="服务通信">2.2.2 服务通信</h4><h5 id="服务service同步通信">服务Service——同步通信</h5><ul><li>使用<strong>客户端/服务器</strong>模型，客户端发送<strong>请求</strong>数据，服务器完成处理后返回<strong>应答</strong>数据</li><li>使用编程语言无关的.srv文件定义请求和应答数据结构，编译过程中生成对应的代码文件</li></ul><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210521160849024.png" alt="image-20210521160849024" style="zoom:67%;" /></p><h4 id="话题-vs-服务">2.2.3 话题 vs 服务</h4><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">topic</th><th style="text-align: center;">service</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">同步性</td><td style="text-align: center;">异步</td><td style="text-align: center;">同步</td></tr><tr class="even"><td style="text-align: center;">通信模型</td><td style="text-align: center;">发布/订阅</td><td style="text-align: center;">服务器/客户端</td></tr><tr class="odd"><td style="text-align: center;">底层协议</td><td style="text-align: center;">ROSTCP/ROSUDP</td><td style="text-align: center;">ROSTCP/ROSUDP</td></tr><tr class="even"><td style="text-align: center;">反馈机制</td><td style="text-align: center;">无</td><td style="text-align: center;">有</td></tr><tr class="odd"><td style="text-align: center;">缓冲区</td><td style="text-align: center;">有</td><td style="text-align: center;">无</td></tr><tr class="even"><td style="text-align: center;">实时性</td><td style="text-align: center;">弱</td><td style="text-align: center;">强</td></tr><tr class="odd"><td style="text-align: center;">节点关系</td><td style="text-align: center;">多对多</td><td style="text-align: center;">一对多（一个service）</td></tr><tr class="even"><td style="text-align: center;">适用场景</td><td style="text-align: center;">数据传输</td><td style="text-align: center;">逻辑处理</td></tr></tbody></table><h4 id="参数">2.2.4 参数</h4><h5 id="参数parameter全局共享字典">参数Parameter——全局共享字典</h5><ul><li>可通过<strong>网络</strong>访问的共享、多变量字典</li><li>节点使用此服务器来存储和检索<strong>运行时的参数</strong></li><li>适合存储<strong>静态</strong>、非二进制的配置参数，不适合存储动态配置的数据</li></ul><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210521161720441.png" alt="image-20210521161720441" style="zoom: 50%;" /></p><h3 id="文件系统">2.3 文件系统</h3><ul><li><p>功能包Package</p><p>ROS软件中的基本单元，包含节点源码、配置文件、数据定义等</p></li><li><p>清单Manifest</p><p>对软件包的描述，记录功能包的基本信息：作者信息、许可信息、依赖选项、编译标志等</p></li><li><p>元功能包Meta Package</p><p>组织多个用于同一目的的功能包</p><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210521162611135.png" alt="image-20210521162611135" style="zoom: 50%;" /></p></li></ul><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210521162639077.png" alt="image-20210521162639077" style="zoom:50%;" /></p><h3 id="主要命令">2.4 主要命令</h3><ul><li>以海龟仿真器为例：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行,其中rosrun usage:rosrun &lt;package&gt; &lt;executable&gt;</span></span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br><span class="line"><span class="comment">#查看系统中运行的计算图</span></span><br><span class="line">rtq_graph</span><br><span class="line"><span class="comment">#查看节点列表</span></span><br><span class="line">rosnode list</span><br><span class="line"><span class="comment">#查看/turtlesim节点信息</span></span><br><span class="line">rosnode info /turtlesim </span><br><span class="line"><span class="comment">#查看话题列表</span></span><br><span class="line">rostopic list</span><br><span class="line"><span class="comment">#发布/turtle1/cmd_vel话题关于坐标的消息，消息频率为10次/秒 (geo开始的内容使用tab补全)</span></span><br><span class="line">rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist <span class="string">&quot;linear:</span></span><br><span class="line"><span class="string">  x:1.0</span></span><br><span class="line"><span class="string">  y:0.0</span></span><br><span class="line"><span class="string">  z:0.0</span></span><br><span class="line"><span class="string">angular:</span></span><br><span class="line"><span class="string">  x:0.0</span></span><br><span class="line"><span class="string">  y:0.0</span></span><br><span class="line"><span class="string">  z:0.0&quot;</span></span><br><span class="line"><span class="comment">#查看话题的消息结构</span></span><br><span class="line">rosmsg show geometry_msgs/Twist</span><br><span class="line"><span class="comment">#查看服务列表</span></span><br><span class="line">rosservice list</span><br><span class="line"><span class="comment">#发布某服务请求,在（5.0,5.0）坐标位置产生一个初试角度为0的新海龟</span></span><br><span class="line">rosservice call /spawn <span class="string">&quot;x:5.0</span></span><br><span class="line"><span class="string">y:5.0</span></span><br><span class="line"><span class="string">theta:0.0</span></span><br><span class="line"><span class="string">name:&#x27;turtle2&#x27;&quot;</span></span><br><span class="line"><span class="comment">#话题记录,-all全部记录,-O压缩包</span></span><br><span class="line">rosbag record -a -O cmd_record</span><br><span class="line"><span class="comment">#话题复现</span></span><br><span class="line">rosbag play cmd_record.bag</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#寻找软件包位置命令</span></span><br><span class="line">rospack find [package_name]</span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">rospack find roscpp</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">/opt/ros/&lt;distro&gt;/share/roscpp</span><br><span class="line"></span><br><span class="line"><span class="comment">#roscd是rosbash命令集的一部分，它允许你直接切换目录（cd）到某个软件包或者软件包集当中</span></span><br><span class="line">roscd [locationname[/subdir]]</span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">roscd roscpp</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">YOUR_INSTALL_PATH/share/roscpp</span><br><span class="line"><span class="comment">#roscd只能切换到那些路径已经包含在ROS_PACKAGE_PATH环境变量中的软件包</span></span><br><span class="line"><span class="comment">#如此种种，你也许已经注意到了ROS命令工具的的命名方式：</span></span><br><span class="line">rospack = ros + pack(age)</span><br><span class="line">roscd = ros + <span class="built_in">cd</span></span><br><span class="line">rosls = ros + <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><h2 id="三话题应用">三、话题应用</h2><h3 id="创建工作空间和功能包">3.1 创建工作空间和功能包</h3><ul><li>工作目录结构</li></ul><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210522161705472.png" alt="image-20210522161705472" style="zoom:80%;" /></p><p>工作空间workspace：一个存放工程开发相关文件的文件夹。</p><p>工作空间下共有四个主要文件夹：</p><ul><li>src：代码空间，放功能包的源码等</li><li>build：编译空间，编译过程中的中间二进制文件等</li><li>devel：开发空间，开发过程中生成的可执行文件和库等，与install功能类似</li><li>install：安装空间，开发结束后生成的可执行文件等</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个名为catkin_ws(自己命名)的工作空间，参数-p 确保目录名称存在，不存在的就新建一个。</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/catkin_ws/src</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_init_workspace  <span class="comment">#将该目录初始化为ros工作空间</span></span><br><span class="line"><span class="comment">#编译工作空间，你可以认为catkin_make是在标准CMake工作流程中依次调用了cmake和make</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/</span><br><span class="line">catkin_make</span><br><span class="line"><span class="comment">#编译安装命令</span></span><br><span class="line">catkin_make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建功能包：catkin_create_pkg &lt;package_name&gt; [depend1][depend2]···</span></span><br><span class="line"><span class="comment">#功能包需要用到c++、python语言所以需要roscpp和rospy依赖，std_msgs是ros官方提供的标准消息结构</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg test_pkg std_msgs rospy roscpp</span><br><span class="line"><span class="comment">#编译构建功能包</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="comment">#设置工作空间的环境变量</span></span><br><span class="line"><span class="built_in">source</span> ~/catkin_ws/devel/setup.bash</span><br><span class="line"><span class="comment">#检查环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$ROS_PACKAGE_PATH</span></span><br><span class="line"><span class="comment">#输出示例</span></span><br><span class="line">/home/&lt;username&gt;/catkin_ws/src:/opt/ros/&lt;distro&gt;/share</span><br><span class="line"></span><br><span class="line"><span class="comment">#注：ROS_PACKAGE_PATH环境变量应该包含那些保存有ROS软件包的路径，并且每个路径之间用冒号（:）分隔开来</span></span><br><span class="line"><span class="built_in">export</span> ROS_PACKAGE_PATH=/home/user/ros/ros-pkg:/another/path</span><br><span class="line"><span class="comment">#注：在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。若要每次启动可用，可将之加入~/.bashrc文件</span></span><br></pre></td></tr></table></figure><h3 id="publisher实现">3.2 Publisher实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建名为learning_topic的功能包</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_topic std_msgs rospy roscpp geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210522151830922.png" alt="image-20210522151830922" style="zoom: 80%;" /></p><h4 id="c版">3.2.1 C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_topic/src/velocity_publisher.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ROS节点初始化</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;velocity_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Publisher对象，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">ros::Publisher turtle_vel_pub = n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置循环的频率，类似2.4节中的 -r 10</span></span><br><span class="line"><span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, </span><br><span class="line">vel_msg.linear.x, vel_msg.angular.z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照循环频率延时</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/catkin_ws/src/learning_topic/src/CMakeLists.txt 加入下面的编译选项内容</span></span><br><span class="line"><span class="keyword">add_executable</span>(velocity_publisher src/velocity_publisher.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(velocity_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入working space根目录编译，并运行publisher</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行</span></span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic velocity_publisher</span><br></pre></td></tr></table></figure><h4 id="python版">3.2.2 python版</h4><p>~/catkin_ws/src/learning_topic/scripts/velocity_publisher.py代码如下</p><p>第三行代码的python解释器由于版本问题可能要写为python3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> Twist</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">velocity_publisher</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;velocity_publisher&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">    turtle_vel_pub = rospy.Publisher(<span class="string">&#x27;/turtle1/cmd_vel&#x27;</span>, Twist, queue_size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置循环的频率</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line"><span class="comment"># 初始化geometry_msgs::Twist类型的消息</span></span><br><span class="line">        vel_msg = Twist()</span><br><span class="line">        vel_msg.linear.x = <span class="number">0.5</span></span><br><span class="line">        vel_msg.angular.z = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布消息</span></span><br><span class="line">        turtle_vel_pub.publish(vel_msg)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]&quot;</span>, </span><br><span class="line">vel_msg.linear.x, vel_msg.angular.z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照循环频率延时</span></span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        velocity_publisher()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给.py文件添加执行权限,编译过程等暂时存疑</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/learning_topic/scripts/</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 velocity_publisher.py</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行</span></span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic velocity_publisher.py</span><br></pre></td></tr></table></figure><h3 id="subscriber实现">3.3 Subscriber实现</h3><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210522151914764.png" alt="image-20210522151914764" style="zoom:80%;" /></p><h4 id="c版-1">3.3.1 C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_topic/src/pose_subscriber.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;turtlesim/Pose.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> turtlesim::Pose::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg-&gt;x, msg-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;pose_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span></span><br><span class="line">    ros::Subscriber pose_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/turtle1/pose&quot;</span>, <span class="number">10</span>, poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/catkin_ws/src/learning_topic/src/CMakeLists.txt 加入下面的编译选项内容</span></span><br><span class="line"><span class="keyword">add_executable</span>(pose_subscriber src/pose_subscriber.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(pose_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入working space根目录编译，并运行subscriber</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行</span></span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_topic velocity_publisher</span><br><span class="line">rosrun learning_topic pose_subscriber <span class="comment">#开启订阅者</span></span><br></pre></td></tr></table></figure><h4 id="python版-1">3.3.2 python版</h4><p>~/catkin_ws/src/learning_topic/scripts/pose_subscriber.py代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> turtlesim.msg <span class="keyword">import</span> Pose</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">poseCallback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Turtle pose: x:%0.6f, y:%0.6f&quot;</span>, msg.x, msg.y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pose_subscriber</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;pose_subscriber&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback</span></span><br><span class="line">    rospy.Subscriber(<span class="string">&quot;/turtle1/pose&quot;</span>, Pose, poseCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环等待回调函数</span></span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pose_subscriber()</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给.py文件添加执行权限,编译过程等暂时存疑</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/learning_topic/scripts/</span><br><span class="line">sudo <span class="built_in">chmod</span> 755 pose_subscriber.py</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行</span></span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br><span class="line">rosrun learning_topic pose_subscriber.py</span><br></pre></td></tr></table></figure><h3 id="话题消息自定义">3.4 话题消息自定义</h3><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210522160821468.png" alt="image-20210522160821468" style="zoom:80%;" /></p><h4 id="定义msg文件">3.4.1 定义msg文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/learning_topic/</span><br><span class="line"><span class="built_in">mkdir</span> msg</span><br><span class="line"><span class="built_in">cd</span> msg</span><br><span class="line"><span class="built_in">touch</span> Person.msg</span><br><span class="line"><span class="comment">#在Person.msg文件中输入以下内容并保存：</span></span><br><span class="line">string name</span><br><span class="line">uint8  age</span><br><span class="line">uint8  sex</span><br><span class="line"></span><br><span class="line">uint8 unknown = 0</span><br><span class="line">uint8 male    = 1</span><br><span class="line">uint8 female  = 2</span><br></pre></td></tr></table></figure><h4 id="在package.xml添加功能包依赖">3.4.2在package.xml添加功能包依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/learning_topic/</span><br><span class="line"><span class="comment">#打开package.xml文件，在文件下方依赖位置，输入以下内容并保存：</span></span><br><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><h4 id="在cmakelists.txt添加编译内容">3.4.3在CMakeLists.txt添加编译内容</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_topic/</span><br><span class="line"><span class="comment">#打开CMakeLists.txt，在适当位置，输入以下内容并保存：</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  Person.msg</span><br><span class="line">)</span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line">catkin_package(CATKIN_DEPENDS </span><br><span class="line">  geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="编译生成语言相关文件">3.4.4 编译生成语言相关文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="comment">#编译结果：路径~/catkin_ws/devel/include/learning_topic下生成Person.h头文件</span></span><br></pre></td></tr></table></figure><h4 id="自定义话题消息的使用">3.4.5 自定义话题消息的使用</h4><h5 id="publisherc">1、publisher（c++）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_topic/src/person_publisher.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_publisher&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span></span><br><span class="line">    ros::Publisher person_info_pub = n.<span class="built_in">advertise</span>&lt;learning_topic::Person&gt;(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置循环的频率</span></span><br><span class="line">    <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化learning_topic::Person类型的消息</span></span><br><span class="line">    learning_topic::Person person_msg;</span><br><span class="line">person_msg.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">person_msg.age  = <span class="number">18</span>;</span><br><span class="line">person_msg.sex  = learning_topic::Person::male;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布消息</span></span><br><span class="line">person_info_pub.<span class="built_in">publish</span>(person_msg);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line">  person_msg.name.<span class="built_in">c_str</span>(), person_msg.age, person_msg.sex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照循环频率延时</span></span><br><span class="line">        loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="subscriberc">2、subscriber（c++）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_topic/src/person_subscriber.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_topic/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收到订阅的消息后，会进入消息回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">personInfoCallback</span><span class="params">(<span class="type">const</span> learning_topic::Person::ConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将接收到的消息打印出来</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line"> msg-&gt;name.<span class="built_in">c_str</span>(), msg-&gt;age, msg-&gt;sex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_subscriber&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span></span><br><span class="line">    ros::Subscriber person_info_sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;/person_info&quot;</span>, <span class="number">10</span>, personInfoCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5id="在cmakelists.txt添加编译内容-1">3、在CMakeLists.txt添加编译内容</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_topic/</span><br><span class="line"><span class="comment">#打开CMakeLists.txt，在适当位置，输入以下内容并保存：</span></span><br><span class="line"><span class="keyword">add_executable</span>(person_publisher src/person_publisher.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_publisher <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_publisher <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(person_subscriber src/person_subscriber.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_subscriber <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_subscriber <span class="variable">$&#123;PROJECT_NAME&#125;</span>_generate_messages_cpp)</span><br></pre></td></tr></table></figure><h5 id="编译与运行">4、编译与运行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line">roscore</span><br><span class="line">rosrun learning_topic person_subscriber</span><br><span class="line">rosrun learning_topic person_publisher</span><br><span class="line"><span class="comment">#一旦pub和sub建立连接,就算关闭roscore,也不会影响两者的连接</span></span><br><span class="line"><span class="comment">#因为roscore只负责两者前期的“牵手&quot;,相当于一个”婚介所“,一旦连接之后,就与roscore就无关了</span></span><br></pre></td></tr></table></figure><h5 id="publisherpython">5、publisher（python）</h5><p>~/catkin_ws/src/learning_topic/scripts/person_publisher.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将发布/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> learning_topic.msg <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">velocity_publisher</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;person_publisher&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10</span></span><br><span class="line">    person_info_pub = rospy.Publisher(<span class="string">&#x27;/person_info&#x27;</span>, Person, queue_size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置循环的频率</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line"><span class="comment"># 初始化learning_topic::Person类型的消息</span></span><br><span class="line">    person_msg = Person()</span><br><span class="line">    person_msg.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">    person_msg.age  = <span class="number">18</span>;</span><br><span class="line">    person_msg.sex  = Person.male;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布消息</span></span><br><span class="line">        person_info_pub.publish(person_msg)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Publsh person message[%s, %d, %d]&quot;</span>, </span><br><span class="line">person_msg.name, person_msg.age, person_msg.sex)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照循环频率延时</span></span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        velocity_publisher()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="subscriberpython">6、subscriber（python）</h5><p>~/catkin_ws/src/learning_topic/scripts/person_subscriber.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> learning_topic.msg <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">personInfoCallback</span>(<span class="params">msg</span>):</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Subcribe Person Info: name:%s  age:%d  sex:%d&quot;</span>, </span><br><span class="line"> msg.name, msg.age, msg.sex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person_subscriber</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;person_subscriber&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback</span></span><br><span class="line">    rospy.Subscriber(<span class="string">&quot;/person_info&quot;</span>, Person, personInfoCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环等待回调函数</span></span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    person_subscriber()</span><br></pre></td></tr></table></figure><h2 id="四服务应用">四、服务应用</h2><h3 id="创建功能包">4.1 创建功能包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_service roscpp rospy std_msgs geometry_msgs turtlesim</span><br></pre></td></tr></table></figure><h3 id="client实现">4.2 Client实现</h3><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210522174729345.png" alt="image-20210522174729345" style="zoom:80%;" /></p><h4 id="c版-2">4.2.1 C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_service/src/turtle_spawn.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>); <span class="comment">//阻塞型函数</span></span><br><span class="line">ros::ServiceClient add_turtle = node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化turtlesim::Spawn的请求数据</span></span><br><span class="line">turtlesim::Spawn srv;</span><br><span class="line">srv.request.x = <span class="number">2.0</span>;</span><br><span class="line">srv.request.y = <span class="number">2.0</span>;</span><br><span class="line">srv.request.name = <span class="string">&quot;turtle2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to spawn turtle[x:%0.6f, y:%0.6f, name:%s]&quot;</span>, </span><br><span class="line"> srv.request.x, srv.request.y, srv.request.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示服务调用结果</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Spawn turtle successfully [name:%s]&quot;</span>, srv.response.name.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/catkin_ws/src/learning_service/src/CMakeLists.txt 加入下面的编译选项内容</span></span><br><span class="line">add_executable(turtle_spawn src/turtle_spawn.cpp)</span><br><span class="line">target_link_libraries(turtle_spawn <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入working space根目录编译，生成可执行文件</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行</span></span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_service turtle_spawn</span><br></pre></td></tr></table></figure><h4 id="python版-2">4.2.2 python版</h4><p>~/catkin_ws/src/learning_service/scripts/turtle_spawn.py内容如下（注意添加执行权限）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> turtlesim.srv <span class="keyword">import</span> Spawn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">turtle_spawn</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;turtle_spawn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">    rospy.wait_for_service(<span class="string">&#x27;/spawn&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        add_turtle = rospy.ServiceProxy(<span class="string">&#x27;/spawn&#x27;</span>, Spawn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求服务调用，输入请求数据</span></span><br><span class="line">        response = add_turtle(<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>, <span class="string">&quot;turtle2&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> response.name</span><br><span class="line">    <span class="keyword">except</span> rospy.ServiceException, e:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Service call failed: %s&quot;</span>%e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="comment">#服务调用并显示调用结果</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Spwan turtle successfully [name:%s]&quot;</span> %(turtle_spawn())</span><br></pre></td></tr></table></figure><h3 id="server实现">4.3 Server实现</h3><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210522174838657.png" alt="image-20210522174838657" style="zoom:80%;" /></p><h4 id="c版-3">4.3.1 C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_service/src/turtle_command_server.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_srvs/Trigger.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">ros::Publisher turtle_vel_pub;</span><br><span class="line"><span class="type">bool</span> pubCommand = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">commandCallback</span><span class="params">(std_srvs::Trigger::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         std_srvs::Trigger::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pubCommand = !pubCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Publish turtle velocity command [%s]&quot;</span>, pubCommand==<span class="literal">true</span>?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置反馈数据</span></span><br><span class="line">res.success = <span class="literal">true</span>;</span><br><span class="line">res.message = <span class="string">&quot;Change turtle command state!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;turtle_command_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/turtle_command的server，注册回调函数commandCallback</span></span><br><span class="line">    ros::ServiceServer command_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/turtle_command&quot;</span>, commandCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10</span></span><br><span class="line">turtle_vel_pub = n.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle1/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to receive turtle command.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置循环的频率，类似2.4节中的 -r 10</span></span><br><span class="line"><span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 查看一次回调函数队列</span></span><br><span class="line">    ros::<span class="built_in">spinOnce</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果标志为true，则发布速度指令</span></span><br><span class="line"><span class="keyword">if</span>(pubCommand)</span><br><span class="line">&#123;</span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span>;</span><br><span class="line">vel_msg.angular.z = <span class="number">0.2</span>;</span><br><span class="line">turtle_vel_pub.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按照循环频率延时</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/catkin_ws/src/learning_service/src/CMakeLists.txt 加入下面的编译选项内容</span></span><br><span class="line"><span class="keyword">add_executable</span>(turtle_command_server src/turtle_command_server.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(turtle_command_server <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入working space根目录编译，生成可执行文件</span></span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash <span class="comment">#不想每次设置环境变量，可以直接写入 ~/.bashrc的最后一行</span></span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_service turtle_command_server</span><br><span class="line">rosservice call /turtle_command <span class="string">&quot;&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="python版-3">4.3.2 python版</h4><p>~/catkin_ws/src/learning_service/scripts/turtle_command_server.py内容如下（注意添加执行权限）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> thread,time</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> Twist</span><br><span class="line"><span class="keyword">from</span> std_srvs.srv <span class="keyword">import</span> Trigger, TriggerResponse</span><br><span class="line"></span><br><span class="line">pubCommand = <span class="literal">False</span>;</span><br><span class="line">turtle_vel_pub = rospy.Publisher(<span class="string">&#x27;/turtle1/cmd_vel&#x27;</span>, Twist, queue_size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">command_thread</span>():</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">if</span> pubCommand:</span><br><span class="line">vel_msg = Twist()</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span></span><br><span class="line">vel_msg.angular.z = <span class="number">0.2</span></span><br><span class="line">turtle_vel_pub.publish(vel_msg)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">commandCallback</span>(<span class="params">req</span>):</span><br><span class="line"><span class="keyword">global</span> pubCommand</span><br><span class="line">pubCommand = <span class="built_in">bool</span>(<span class="number">1</span>-pubCommand)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示请求数据</span></span><br><span class="line">rospy.loginfo(<span class="string">&quot;Publish turtle velocity command![%d]&quot;</span>, pubCommand)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反馈数据</span></span><br><span class="line"><span class="keyword">return</span> TriggerResponse(<span class="number">1</span>, <span class="string">&quot;Change turtle command state!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">turtle_command_server</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;turtle_command_server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为/turtle_command的server，注册回调函数commandCallback</span></span><br><span class="line">    s = rospy.Service(<span class="string">&#x27;/turtle_command&#x27;</span>, Trigger, commandCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Ready to receive turtle command.&quot;</span></span><br><span class="line"></span><br><span class="line">    thread.start_new_thread(command_thread, ())</span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    turtle_command_server()</span><br></pre></td></tr></table></figure><h3 id="服务数据自定义">4.4 服务数据自定义</h3><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210522195616472.png" alt="image-20210522195616472" style="zoom:80%;" /></p><h4 id="定义srv文件">4.4.1 定义srv文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/learning_service/</span><br><span class="line"><span class="built_in">mkdir</span> srv</span><br><span class="line"><span class="built_in">cd</span> srv</span><br><span class="line"><span class="built_in">touch</span> Person.srv</span><br><span class="line"><span class="comment">#在Person.srv文件中输入以下内容并保存：</span></span><br><span class="line"><span class="comment">#---上方是request数据，下方是response数据</span></span><br><span class="line">string name</span><br><span class="line">uint8  age</span><br><span class="line">uint8  sex</span><br><span class="line"></span><br><span class="line">uint8 unknown = 0</span><br><span class="line">uint8 male    = 1</span><br><span class="line">uint8 female  = 2</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">string result</span><br></pre></td></tr></table></figure><h4 id="在package.xml添加功能包依赖-1">4.4.2在package.xml添加功能包依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src/learning_service/</span><br><span class="line"><span class="comment">#打开package.xml文件，在文件下方依赖位置，输入以下内容并保存：</span></span><br><span class="line">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;</span><br><span class="line">&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;</span><br></pre></td></tr></table></figure><h4 id="在cmakelists.txt添加编译内容-2">4.4.3在CMakeLists.txt添加编译内容</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_service/</span><br><span class="line"><span class="comment">#打开CMakeLists.txt，在适当位置，输入以下内容并保存：</span></span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  geometry_msgs</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  turtlesim</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line">add_service_files(</span><br><span class="line">  FILES</span><br><span class="line">  Person.srv</span><br><span class="line">)</span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line">catkin_package(CATKIN_DEPENDS  </span><br><span class="line">  geometry_msgs roscpp rospy std_msgs turtlesim message_runtime</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="编译生成语言相关文件-1">4.4.4 编译生成语言相关文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="comment">#编译结果：路径~/catkin_ws/devel/include/learning_service下生成PersonRequest.h和PersonResponse.h头文件</span></span><br></pre></td></tr></table></figure><h4 id="自定义服务数据的使用">4.4.5 自定义服务数据的使用</h4><h5 id="serverc">1、server（c++）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_service/src/person_server.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程将执行/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// service回调函数，输入参数req，输出参数res</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">personCallback</span><span class="params">(learning_service::Person::Request  &amp;req,</span></span></span><br><span class="line"><span class="params"><span class="function">         learning_service::Person::Response &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 显示请求数据</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name.<span class="built_in">c_str</span>(), req.age, req.sex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置反馈数据</span></span><br><span class="line">res.result = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个名为/show_person的server，注册回调函数personCallback</span></span><br><span class="line">    ros::ServiceServer person_service = n.<span class="built_in">advertiseService</span>(<span class="string">&quot;/show_person&quot;</span>, personCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Ready to show person informtion.&quot;</span>);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="clientc">2、client（c++）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_service/src/person_client.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;learning_service/Person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;person_client&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line">ros::ServiceClient person_client = node.<span class="built_in">serviceClient</span>&lt;learning_service::Person&gt;(<span class="string">&quot;/show_person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化learning_service::Person的请求数据</span></span><br><span class="line">learning_service::Person srv;</span><br><span class="line">srv.request.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">srv.request.age  = <span class="number">20</span>;</span><br><span class="line">srv.request.sex  = learning_service::Person::Request::male;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求服务调用</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Call service to show person[name:%s, age:%d, sex:%d]&quot;</span>, </span><br><span class="line"> srv.request.name.<span class="built_in">c_str</span>(), srv.request.age, srv.request.sex);</span><br><span class="line"></span><br><span class="line">person_client.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示服务调用结果</span></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Show person result : %s&quot;</span>, srv.response.result.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5id="在cmakelists.txt添加编译内容-3">3、在CMakeLists.txt添加编译内容</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_service/</span><br><span class="line"><span class="comment">#打开CMakeLists.txt，在适当位置，输入以下内容并保存：</span></span><br><span class="line"><span class="keyword">add_executable</span>(person_server src/person_server.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_server <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_server <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(person_client src/person_client.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(person_client <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">add_dependencies</span>(person_client <span class="variable">$&#123;PROJECT_NAME&#125;</span>_gencpp)</span><br></pre></td></tr></table></figure><h5 id="编译与运行-1">4、编译与运行</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">roscore</span><br><span class="line">rosrun learning_service person_server</span><br><span class="line">rosrun learning_service person_client</span><br></pre></td></tr></table></figure><h5 id="serverpython">5、server（python）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将执行/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> learning_service.srv <span class="keyword">import</span> Person, PersonResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">personCallback</span>(<span class="params">req</span>):</span><br><span class="line"><span class="comment"># 显示请求数据</span></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Person: name:%s  age:%d  sex:%d&quot;</span>, req.name, req.age, req.sex)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反馈数据</span></span><br><span class="line">    <span class="keyword">return</span> PersonResponse(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person_server</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;person_server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为/show_person的server，注册回调函数personCallback</span></span><br><span class="line">    s = rospy.Service(<span class="string">&#x27;/show_person&#x27;</span>, Person, personCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环等待回调函数</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Ready to show person informtion.&quot;</span></span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    person_server()</span><br></pre></td></tr></table></figure><h5 id="clientpython">6、client（python）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> learning_service.srv <span class="keyword">import</span> Person, PersonRequest</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">person_client</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;person_client&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">    rospy.wait_for_service(<span class="string">&#x27;/show_person&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        person_client = rospy.ServiceProxy(<span class="string">&#x27;/show_person&#x27;</span>, Person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求服务调用，输入请求数据</span></span><br><span class="line">        response = person_client(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>, PersonRequest.male)</span><br><span class="line">        <span class="keyword">return</span> response.result</span><br><span class="line">    <span class="keyword">except</span> rospy.ServiceException, e:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Service call failed: %s&quot;</span>%e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="comment">#服务调用并显示调用结果</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Show person result : %s&quot;</span> %(person_client())</span><br></pre></td></tr></table></figure><h2 id="五参数应用">五、参数应用</h2><p><img src="https://silencht.oss-cn-beijing.aliyuncs.com/img/image-20210524175228081.png" alt="image-20210524175228081" style="zoom:80%;" /></p><h3 id="创建功能包-1">5.1 创建功能包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_parameter roscpp rospy std_srvs</span><br></pre></td></tr></table></figure><h3 id="参数命令行使用">5.2 参数命令行使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出当前所有参数</span></span><br><span class="line">rosparam list</span><br><span class="line"><span class="comment">#显示某个参数的值</span></span><br><span class="line">rosparam get param_key</span><br><span class="line"><span class="comment">#设置某个参数的值</span></span><br><span class="line">rosparam <span class="built_in">set</span> param_key param_value</span><br><span class="line"><span class="comment">#保存参数到文件</span></span><br><span class="line">rosparam dump file_name</span><br><span class="line"><span class="comment">#从文件读取参数</span></span><br><span class="line">rosparam load file_name</span><br><span class="line"><span class="comment">#删除参数</span></span><br><span class="line">rosparam delete param_key</span><br></pre></td></tr></table></figure><h3 id="实现">5.3 实现</h3><h4 id="c版-4">5.3.1 C++版</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_parameter/src/parameter_config.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程设置/读取海龟例程中的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;std_srvs/Empty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ROS节点初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;parameter_config&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">    ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/background_r&quot;</span>, red);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/background_g&quot;</span>, green);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">ros::param::<span class="built_in">set</span>(<span class="string">&quot;/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取背景颜色参数</span></span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/background_r&quot;</span>, red);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/background_g&quot;</span>, green);</span><br><span class="line">ros::param::<span class="built_in">get</span>(<span class="string">&quot;/background_b&quot;</span>, blue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ROS_INFO</span>(<span class="string">&quot;Re-get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发现/clear服务后，创建一个服务客户端，服务数据类型empty调用服务，刷新背景颜色</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">ros::ServiceClient clear_background = node.<span class="built_in">serviceClient</span>&lt;std_srvs::Empty&gt;(<span class="string">&quot;/clear&quot;</span>);</span><br><span class="line">std_srvs::Empty srv;</span><br><span class="line">clear_background.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_parameter/</span><br><span class="line"><span class="comment">#打开CMakeLists.txt，在适当位置，输入以下内容并保存：</span></span><br><span class="line"><span class="keyword">add_executable</span>(parameter_config src/parameter_config.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(parameter_config <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun learning_parameter parameter_config</span><br></pre></td></tr></table></figure><h4 id="python版-4">5.3.2 python版</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程设置/读取海龟例程中的参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_srvs.srv <span class="keyword">import</span> Empty</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parameter_config</span>():</span><br><span class="line"><span class="comment"># ROS节点初始化</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;parameter_config&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取背景颜色参数</span></span><br><span class="line">    red   = rospy.get_param(<span class="string">&#x27;/background_r&#x27;</span>)</span><br><span class="line">    green = rospy.get_param(<span class="string">&#x27;/background_g&#x27;</span>)</span><br><span class="line">    blue  = rospy.get_param(<span class="string">&#x27;/background_b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置背景颜色参数</span></span><br><span class="line">    rospy.set_param(<span class="string">&quot;/background_r&quot;</span>, <span class="number">255</span>);</span><br><span class="line">    rospy.set_param(<span class="string">&quot;/background_g&quot;</span>, <span class="number">255</span>);</span><br><span class="line">    rospy.set_param(<span class="string">&quot;/background_b&quot;</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Set Backgroud Color[255, 255, 255]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取背景颜色参数</span></span><br><span class="line">    red   = rospy.get_param(<span class="string">&#x27;/background_r&#x27;</span>)</span><br><span class="line">    green = rospy.get_param(<span class="string">&#x27;/background_g&#x27;</span>)</span><br><span class="line">    blue  = rospy.get_param(<span class="string">&#x27;/background_b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Get Backgroud Color[%d, %d, %d]&quot;</span>, red, green, blue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service</span></span><br><span class="line">    rospy.wait_for_service(<span class="string">&#x27;/clear&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        clear_background = rospy.ServiceProxy(<span class="string">&#x27;/clear&#x27;</span>, Empty)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求服务调用，输入请求数据</span></span><br><span class="line">        response = clear_background()</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">except</span> rospy.ServiceException, e:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Service call failed: %s&quot;</span>%e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parameter_config()</span><br></pre></td></tr></table></figure><h2 id="六tf坐标系">六、tf坐标系</h2><h3 id="创建功能包-2">6.1 创建功能包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-turtle-tf</span><br><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_tf roscpp rospy tf turtlesim</span><br></pre></td></tr></table></figure><h3 id="实现-1">6.2 实现</h3><h4 id="broadcasterc">6.2.1 broadcaster（c++）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_tf/src/turtle_tf_broadcaster.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程产生tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_broadcaster.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Pose.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string turtle_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poseCallback</span><span class="params">(<span class="type">const</span> turtlesim::PoseConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建tf的广播器</span></span><br><span class="line"><span class="type">static</span> tf::TransformBroadcaster br;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化tf数据</span></span><br><span class="line">tf::Transform transform;</span><br><span class="line">transform.<span class="built_in">setOrigin</span>( tf::<span class="built_in">Vector3</span>(msg-&gt;x, msg-&gt;y, <span class="number">0.0</span>) );</span><br><span class="line">tf::Quaternion q;</span><br><span class="line">q.<span class="built_in">setRPY</span>(<span class="number">0</span>, <span class="number">0</span>, msg-&gt;theta);</span><br><span class="line">transform.<span class="built_in">setRotation</span>(q);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播world与海龟坐标系之间的tf数据</span></span><br><span class="line">br.<span class="built_in">sendTransform</span>(tf::<span class="built_in">StampedTransform</span>(transform, ros::Time::<span class="built_in">now</span>(), <span class="string">&quot;world&quot;</span>, turtle_name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_broadcaster&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入参数作为海龟的名字</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;need turtle name as argument&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">turtle_name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅海龟的位姿话题</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line">ros::Subscriber sub = node.<span class="built_in">subscribe</span>(turtle_name+<span class="string">&quot;/pose&quot;</span>, <span class="number">10</span>, &amp;poseCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待回调函数</span></span><br><span class="line">ros::<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="listenerc">6.2.2 listener（c++）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ~/catkin_ws/src/learning_tf/src/turtle_tf_listener.cpp代码如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该例程监听tf数据，并计算、发布turtle2的速度指令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tf/transform_listener.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;geometry_msgs/Twist.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;turtlesim/Spawn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化ROS节点</span></span><br><span class="line">ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;my_tf_listener&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点句柄</span></span><br><span class="line">ros::NodeHandle node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求产生turtle2</span></span><br><span class="line">ros::service::<span class="built_in">waitForService</span>(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">ros::ServiceClient add_turtle = node.<span class="built_in">serviceClient</span>&lt;turtlesim::Spawn&gt;(<span class="string">&quot;/spawn&quot;</span>);</span><br><span class="line">turtlesim::Spawn srv;</span><br><span class="line">add_turtle.<span class="built_in">call</span>(srv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建发布turtle2速度控制指令的发布者</span></span><br><span class="line">ros::Publisher turtle_vel = node.<span class="built_in">advertise</span>&lt;geometry_msgs::Twist&gt;(<span class="string">&quot;/turtle2/cmd_vel&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建tf的监听器</span></span><br><span class="line">tf::TransformListener listener;</span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">rate</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (node.<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取turtle1与turtle2坐标系之间的tf数据</span></span><br><span class="line">tf::StampedTransform transform;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">listener.<span class="built_in">waitForTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), ros::<span class="built_in">Duration</span>(<span class="number">3.0</span>));</span><br><span class="line">listener.<span class="built_in">lookupTransform</span>(<span class="string">&quot;/turtle2&quot;</span>, <span class="string">&quot;/turtle1&quot;</span>, ros::<span class="built_in">Time</span>(<span class="number">0</span>), transform);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (tf::TransformException &amp;ex) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ROS_ERROR</span>(<span class="string">&quot;%s&quot;</span>,ex.<span class="built_in">what</span>());</span><br><span class="line">ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>).<span class="built_in">sleep</span>();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令</span></span><br><span class="line">geometry_msgs::Twist vel_msg;</span><br><span class="line">vel_msg.angular.z = <span class="number">4.0</span> * <span class="built_in">atan2</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(),</span><br><span class="line">                        transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>());</span><br><span class="line">vel_msg.linear.x = <span class="number">0.5</span> * <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">x</span>(), <span class="number">2</span>) +</span><br><span class="line">                      <span class="built_in">pow</span>(transform.<span class="built_in">getOrigin</span>().<span class="built_in">y</span>(), <span class="number">2</span>));</span><br><span class="line">turtle_vel.<span class="built_in">publish</span>(vel_msg);</span><br><span class="line"></span><br><span class="line">rate.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="在cmakelists.txt添加编译内容-4">6.2.3在CMakeLists.txt添加编译内容</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~/catkin_ws/src/learning_tf/</span><br><span class="line"><span class="comment">#打开CMakeLists.txt，在适当位置，输入以下内容并保存：</span></span><br><span class="line"><span class="keyword">add_executable</span>(turtle_tf_broadcaster src/turtle_tf_broadcaster.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(turtle_tf_broadcaster <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(turtle_tf_listener src/turtle_tf_listener.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(turtle_tf_listener <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="编译与运行-2">6.2.4 编译与运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> devel/setup.bash</span><br><span class="line">roscore</span><br><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line"><span class="comment">#最后的/turtle1是main函数中的输入参数，前面(__name:=turtle1_tf_broadcaster)</span></span><br><span class="line"><span class="comment">#使用了节点名的重映射，即turtle1_tf_broadcaster会代替6.2.1节中节点初始化名</span></span><br><span class="line"><span class="comment">#my_tf_broadcaster，这就方便了相同程序同时（使用不同节点名）重复运行</span></span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1</span><br><span class="line">rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2</span><br><span class="line">rosrun learning_tf turtle_tf_listener</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><h4 id="broadcasterpython">6.2.5 broadcaster（python）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> roslib</span><br><span class="line">roslib.load_manifest(<span class="string">&#x27;learning_tf&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tf</span><br><span class="line"><span class="keyword">import</span> turtlesim.msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_turtle_pose</span>(<span class="params">msg, turtlename</span>):</span><br><span class="line">    br = tf.TransformBroadcaster()</span><br><span class="line">    br.sendTransform((msg.x, msg.y, <span class="number">0</span>),</span><br><span class="line">                     tf.transformations.quaternion_from_euler(<span class="number">0</span>, <span class="number">0</span>, msg.theta),</span><br><span class="line">                     rospy.Time.now(),</span><br><span class="line">                     turtlename,</span><br><span class="line">                     <span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;turtle_tf_broadcaster&#x27;</span>)</span><br><span class="line">    turtlename = rospy.get_param(<span class="string">&#x27;~turtle&#x27;</span>)</span><br><span class="line">    rospy.Subscriber(<span class="string">&#x27;/%s/pose&#x27;</span> % turtlename,</span><br><span class="line">                     turtlesim.msg.Pose,</span><br><span class="line">                     handle_turtle_pose,</span><br><span class="line">                     turtlename)</span><br><span class="line">    rospy.spin()</span><br></pre></td></tr></table></figure><h4 id="listenerpython">6.2.6 listener（python）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 该例程将请求/show_person服务，服务数据类型learning_service::Person</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> roslib</span><br><span class="line">roslib.load_manifest(<span class="string">&#x27;learning_tf&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> tf</span><br><span class="line"><span class="keyword">import</span> geometry_msgs.msg</span><br><span class="line"><span class="keyword">import</span> turtlesim.srv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;turtle_tf_listener&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    listener = tf.TransformListener()</span><br><span class="line"></span><br><span class="line">    rospy.wait_for_service(<span class="string">&#x27;spawn&#x27;</span>)</span><br><span class="line">    spawner = rospy.ServiceProxy(<span class="string">&#x27;spawn&#x27;</span>, turtlesim.srv.Spawn)</span><br><span class="line">    spawner(<span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;turtle2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    turtle_vel = rospy.Publisher(<span class="string">&#x27;turtle2/cmd_vel&#x27;</span>, geometry_msgs.msg.Twist,queue_size=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    rate = rospy.Rate(<span class="number">10.0</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            (trans,rot) = listener.lookupTransform(<span class="string">&#x27;/turtle2&#x27;</span>, <span class="string">&#x27;/turtle1&#x27;</span>, rospy.Time(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">except</span> (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        angular = <span class="number">4</span> * math.atan2(trans[<span class="number">1</span>], trans[<span class="number">0</span>])</span><br><span class="line">        linear = <span class="number">0.5</span> * math.sqrt(trans[<span class="number">0</span>] ** <span class="number">2</span> + trans[<span class="number">1</span>] ** <span class="number">2</span>)</span><br><span class="line">        cmd = geometry_msgs.msg.Twist()</span><br><span class="line">        cmd.linear.x = linear</span><br><span class="line">        cmd.angular.z = angular</span><br><span class="line">        turtle_vel.publish(cmd)</span><br><span class="line"></span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><h4 id="运行">6.2.7 运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun learning_tf turtle_tf_broadcaster.py __name:=turtle1_tf_broadcaster _turtle:=/turtle1</span><br></pre></td></tr></table></figure><h2 id="七launch启动文件">七、launch启动文件</h2><h4 id="简单启动文件">7.1 简单启动文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws/src</span><br><span class="line">catkin_create_pkg learning_launch</span><br><span class="line"><span class="built_in">cd</span> learning_launch</span><br><span class="line"><span class="built_in">mkdir</span> launch</span><br><span class="line"><span class="built_in">cd</span> launch</span><br><span class="line"><span class="built_in">touch</span> simple.launch</span><br><span class="line">sudo vim simple.launch</span><br><span class="line"><span class="comment">#输入以下内容</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_subscriber&quot;</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;learning_topic&quot;</span> <span class="attr">type</span>=<span class="string">&quot;person_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">catkin_make</span><br><span class="line"><span class="comment">#命令：roslaunch [package] [filename.launch]</span></span><br><span class="line">roslaunch learning_launch simple.launch</span><br></pre></td></tr></table></figure><h4 id="官方参考网址">7.2 官方参考网址</h4><p>https://wiki.ros.org/roslaunch/XML</p><h4 id="常用标签注释">7.3 常用标签注释</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--launch文件中的根元素用该标签定义，只作为其他自标签容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--node启动节点;pkg:节点所在功能包名;type:可执行文件名称;name:重定义节点名</span></span><br><span class="line"><span class="comment">【注：name会替换掉程序初始化时的节点名】</span></span><br><span class="line"><span class="comment">【可选:output(日志输出到屏幕，若不设置，将写入日志文件)</span></span><br><span class="line"><span class="comment">  respawn(节点失效是否重启)</span></span><br><span class="line"><span class="comment">  required(节点失效关闭整个launch文件)</span></span><br><span class="line"><span class="comment">  ns(在命名空间中运行此节点)</span></span><br><span class="line"><span class="comment">  args(给节点输入参数)】</span></span><br><span class="line"><span class="comment">模板： &lt;node pkg=&quot;package_name&quot; type=&quot;executable|python&quot; name=&quot;node_name&quot; /&gt;    </span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;bar1&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;foo_pkg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bar&quot;</span> <span class="attr">args</span>=<span class="string">&quot;--test&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;true&quot;</span> <span class="attr">output</span>=<span class="string">&quot;sceen&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!--若干个节点划分进同一个命名空间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;namespace&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name1&quot;</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name2&quot;</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--条件判断执行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">if</span>=<span class="string">&quot;$(arg foo1)&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name1&quot;</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">unless</span>=<span class="string">&quot;$(arg foo2)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;pkg_name2&quot;</span> <span class="attr">...</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">&lt;!--重命名，from 原始名称 to 新名称</span></span><br><span class="line"><span class="comment">可以这样理解这个替换标签（存疑）：你有一个节点订阅了「chatter」话题，但是你只有一个节点发布 「hello」话题，而「hello」和「chatter」的类型相同，所以我们可以将「chatter」简单地替换为「hello」，从而实现订阅「hello」话题</span></span><br><span class="line"><span class="comment"> --&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">remap</span> <span class="attr">from</span> = <span class="string">&quot;/different_topic&quot;</span> <span class="attr">to</span> = <span class="string">&quot;/needed_topic&quot;</span> /&gt;</span>  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!--定义节点所运行的机器信息，如果只在本地运行则不需要配置，它主要使用在SSH和远程机器</span></span><br><span class="line"><span class="comment">【参数:name：机器名称</span></span><br><span class="line"><span class="comment">  address：机器的网络地址</span></span><br><span class="line"><span class="comment">  env-loader：设置机器的环境变量，必须是一个设置了所有要求变量的 shell 脚本</span></span><br><span class="line"><span class="comment">  user：用户名称】 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">machine</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">address</span>=<span class="string">&quot;foo-address&quot;</span> <span class="attr">env-loader</span>=<span class="string">&quot;/opt/ros/kinetic/env.sh&quot;</span> <span class="attr">user</span>=<span class="string">&quot;someone&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--可以在启动的节点上设置环境变量，这个标签基本只会使用在 launch、include、node、machine 这 4 个标签内部，当使用在 launch 内部时，env 设置的环境标量会应用到内部定义的节点。  </span></span><br><span class="line"><span class="comment">【参数:name：环境变量名称</span></span><br><span class="line"><span class="comment">  value：环境变量值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span> <span class="attr">name</span>=<span class="string">&quot;ENV_EXAMPLE&quot;</span> <span class="attr">value</span>=<span class="string">&quot;some value&quot;</span> /&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!--设置全局参数，存储在参数服务器中:name(参数名)type(参数类型)value(参数值)</span></span><br><span class="line"><span class="comment">param 标签也可以为一组 group 节点同时设置参数。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;publish_frequency&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10.0&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!--允许节点从参数服务器上增删改YAML文件，也可以使用在远程机器上，需要注意的是 delete 必须在 load 或者 dump 之后进行导入之后进行</span></span><br><span class="line"><span class="comment">【参数:command：load，dump，delete</span></span><br><span class="line"><span class="comment">  file：参数文件的路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;params&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!--设置launch文件内部的局部参数:name(参数名)value(参数值)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;arg-name&quot;</span> <span class="attr">default</span>=<span class="string">&quot;arg-value&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--两个调用arg的例子--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg arg-name)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;node&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;package&quot;</span> <span class="attr">type</span>=<span class="string">&quot;type&quot;</span> <span class="attr">args</span>=<span class="string">&quot;$(arg arg-name)&quot;</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!--包含其他launch文件，类似C语言的头文件包含:file是路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(dirname)/other.launch&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="八可视化工具">八、可视化工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#工具集合</span></span><br><span class="line">rqt</span><br><span class="line"><span class="comment">#日志输出</span></span><br><span class="line">rqt_console</span><br><span class="line"><span class="comment">#计算图可视化</span></span><br><span class="line">rqt_graph</span><br><span class="line"><span class="comment">#数据绘图</span></span><br><span class="line">rqt_plot</span><br><span class="line"><span class="comment">#图像渲染工具</span></span><br><span class="line">rqt_image_view</span><br><span class="line"><span class="comment">#三维可视化工具（数据显示）</span></span><br><span class="line">rviz</span><br><span class="line"><span class="comment">#三维物理仿真平台</span></span><br><span class="line">roslaunch gazebo_ros + tab补全</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;零参考链接&quot;&gt;零、参考链接&lt;/h2&gt;
&lt;p&gt;https://www.bilibili.com/video/BV1zt411G7Vn&lt;/p&gt;
&lt;p&gt;http://wiki.ros.org/cn/ROS/Tutorials/&lt;/p&gt;
&lt;h2 id=&quot;一ros安装&quot;&gt;一
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="ros" scheme="https://silencht.github.io/categories/robot/ros/"/>
    
    
  </entry>
  
  <entry>
    <title>conda</title>
    <link href="https://silencht.github.io/wiki/cs/python/conda/conda/"/>
    <id>https://silencht.github.io/wiki/cs/python/conda/conda/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官方源文档链接">0.<ahref="https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html">官方源文档链接</a></h2><h2 id="管理conda">1.管理conda</h2><p>验证conda是否安装成功，在Windows : anaconda prompt终端或Linux/Unix/Mac 的终端下输入:</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure></p><p>conda显示你安装的版本号.</p><p>举例: <code>conda 4.7.12</code></p><p>更新当前conda版本. 输入以下命令:</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure></p><p>conda比较版本，然后显示出可以安装的版本。如果有新版本conda可用，输入<code>y</code> 来更新:</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proceed ([y]/n)? y</span><br></pre></td></tr></table></figure></p><h2 id="管理环境">2.管理环境</h2><p>conda允许你创建一个不会与其他环境有关的，包含文件、包和它们的依赖的分离式环境。</p><p>当你开始使用conda时，你已经有了一个名为base的默认环境。但是，当你不想要将程序放入你的基环境的话，可以创建一个使你的程序与其他程序相隔离的分离式环境。</p><ol type="1"><li><p>创建新环境并给它安装一个包。</p><p>我们将创建一个名为<code>snwflakes</code>的新环境，然后安装<code>BioPython</code>包。在终端输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name snowflakes biopython</span><br></pre></td></tr></table></figure><p>Conda检查查看BioPython需要哪些其他软件包（“依赖项”）,然后询问你是否继续:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proceed ([y]/n)? y</span><br></pre></td></tr></table></figure><p>键入<code>y</code>和回车继续</p></li><li><p>为了激活和使用刚才安装的新环境, 输入以下内容:</p><ul><li>Windows、macOS and Linux，Conda 4.6以上版本:</li></ul><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate snowflakes</span><br></pre></td></tr></table></figure></p><p><strong>NOTE</strong>: <code>conda activate</code> only works onconda 4.6 and later versions.</p><p>现在你就处于 <code>snowflakes</code>环境中了,任何你键入的conda命令都将作用于这个环境，直到你切换到其他环境（即deactivatedsnowflakes）</p></li><li><p>为了看到你所有的环境列表，键入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p>环境列表与下方所列相似（3、4行 为不同系统所示）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">base           /home/username/Anaconda3</span><br><span class="line">snowflakes   * /home/username/Anaconda3/envs/snowflakes  （Linux）</span><br><span class="line">snowflakes   *  D:\anaconda\envs\snowflakes （Winodws）</span><br></pre></td></tr></table></figure><p><strong>Tip</strong>：当前活跃环境是环境列表中带有<code>*</code>的</p></li><li><p>关闭当前环境，切换至默认环境 (即base)，键入:<code>conda activate</code></p></li><li><p>删除环境</p><p>如果当前位于snowflakes环境内，则先退出环境，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p>回到base环境后，输入删除snowflakes环境的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove -n snowflakes</span><br></pre></td></tr></table></figure></li><li><p>安装conda后取消命令行前出现的base，取消每次启动终端后自动激活conda的base环境</p><p><strong>方法一：</strong></p><p>每次手动在命令行通过 <code>conda deactivate</code>退出base环境，回到系统自动的环境</p><p><strong>方法二：</strong></p><ul><li>通过将auto_activate_base参数设置为false实现：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --set auto_activate_base false</span><br></pre></td></tr></table></figure><ul><li><p>要进入base环境的话通过 <code>conda activate base</code>命令</p></li><li><p>若以后还是希望base保持自动激活，通过<code>conda config --set auto_activate_base true</code> 来恢复</p></li></ul></li></ol><h2 id="管理python">3.管理Python</h2><p>当你创建一个新环境时，conda安装的Python版本与你安装的anaconda软件的默认Python版本相同。如果你想要使用一个不同的Python版本，比如Python3.5, 你可以在创建一个新的环境时，指定你想要的Python版本。</p><ol type="1"><li><p>创建一个名为 "snakes"且包含Python 3.5的新环境:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name snakes python=3.5</span><br></pre></td></tr></table></figure><p>当conda询问你是否继续时,键入 "y" 然后按回车键.</p></li><li><p>激活新环境:</p><ul><li>Windows、macOS and Linux，Conda 4.6以上版本: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate snakes</span><br></pre></td></tr></table></figure></li></ul></li><li><p>核实snakes环境已经被添加和激活:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p>Conda显示了所有的环境列表，然后在当前激活的环境前加了<code>*</code>号:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">base                     /home/username/anaconda3</span><br><span class="line">snakes                *  /home/username/anaconda3/envs/snakes</span><br><span class="line">snowflakes               /home/username/anaconda3/envs/snowflakes</span><br></pre></td></tr></table></figure><p>当前激活的环境名称同样在你的终端命令行的<code>$</code>符号前用<code>()</code>括起来显示，像下面这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(snakes) $</span><br></pre></td></tr></table></figure></li><li><p>确定你当前环境安装的Python版本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure></li><li><p>关闭当前环境，回到默认环境 (即base):<code>conda activate</code></p></li></ol><h2 id="管理包">4.管理包</h2><p>在这一节，你可以检查你安装了哪些包、核实哪些是能用的、寻找确定的包然后安装它。</p><ol type="1"><li><p>为了寻找一个你已经安装的包，首先激活你要寻找这个包的环境.如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate snakes</span><br></pre></td></tr></table></figure></li><li><p>检查当前环境下有哪些包可用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li><li><p>添加一些软件源（国外服务器网速太慢，使用一些国内镜像源，如：下面添加了两个源）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://conda.anaconda.org/menpo</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure></li><li><p>查看当前源有哪些:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --show channels</span><br></pre></td></tr></table></figure></li><li><p>若要删除某些源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove channels https://pypi.doubanio.com/simple/</span><br></pre></td></tr></table></figure></li><li><p>检查是否可以从Anaconda存储库中获得尚未安装的名为“opencv”的软件包（必须连接到Internet）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search opencv</span><br></pre></td></tr></table></figure><p>Conda在Anaconda存储库中显示具有该名称的所有软件包的列表，因此我们知道它可用。</p></li><li><p>向当前环境中安装新包:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install opencv</span><br></pre></td></tr></table></figure></li><li><p>在已安装的包列表里检查是否包安装成功:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;官方源文档链接&quot;&gt;0.&lt;a
href=&quot;https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html&quot;&gt;官方源文档链接&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;管理conda
      
    
    </summary>
    
      <category term="cs" scheme="https://silencht.github.io/categories/cs/"/>
    
      <category term="python" scheme="https://silencht.github.io/categories/cs/python/"/>
    
      <category term="conda" scheme="https://silencht.github.io/categories/cs/python/conda/"/>
    
    
  </entry>
  
  <entry>
    <title>rosdep-update</title>
    <link href="https://silencht.github.io/wiki/robot/ros/rosdep-update/"/>
    <id>https://silencht.github.io/wiki/robot/ros/rosdep-update/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ros-rosdep-update报错解决方法">ROS rosdepupdate报错解决方法</h2><h3 id="一问题描述">一、问题描述</h3><p><strong>操作系统</strong>：Ubuntu18.04<strong>ROS版本</strong>：melodic <strong>错误描述</strong>：</p><p>rosdep init 和 rosdepupdate命令因网络原因无法正确执行，错误信息可能如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[rosdep init]</span><br><span class="line">ERROR: cannot download default sources list from:</span><br><span class="line">https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list</span><br><span class="line">Website may be down.</span><br><span class="line"></span><br><span class="line">[rosdep update]</span><br><span class="line">reading <span class="keyword">in</span> sources list data from /etc/ros/rosdep/sources.list.d</span><br><span class="line">ERROR: unable to process <span class="built_in">source</span> [https://raw.github.com/ros/rosdistro/master/rosdep/osx-homebrew.yaml]:</span><br><span class="line">&lt;urlopen error [Errno 111] Connection refused&gt;……</span><br></pre></td></tr></table></figure><h3 id="二解决方法">二、解决方法</h3><p>放弃从网络自动下载文件，手动下载所需文件到本地，然后在本地执行脚本即可。</p><p>步骤如下：</p><h4 id="下载文件到本地">2.1 下载文件到本地</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设你的用户名为 username</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ros/rosdistro.git</span><br><span class="line"><span class="comment"># 此时主文件夹目录下出现rosdistro文件夹，路径为/home/username/rosdistro</span></span><br></pre></td></tr></table></figure><h4 id="创建20-default.list文件">2.2 创建20-default.list文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动创建脚本所需的文件</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/ros/rosdep/sources.list.d</span><br><span class="line"><span class="built_in">cd</span> /etc/ros/rosdep/sources.list.d</span><br><span class="line">sudo gedit 20-default.list</span><br><span class="line"><span class="comment"># 输入以下内容并保存：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># os-specific listings first</span></span><br><span class="line">yaml file:///home/username/rosdistro/rosdep/osx-homebrew.yaml osx</span><br><span class="line"></span><br><span class="line"><span class="comment"># generic</span></span><br><span class="line">yaml file:///home/username/rosdistro/rosdep/base.yaml</span><br><span class="line">yaml file:///home/username/rosdistro/rosdep/python.yaml</span><br><span class="line">yaml file:///home/username/rosdistro/rosdep/ruby.yaml</span><br><span class="line">gbpdistro file:///home/username/rosdistro/releases/fuerte.yaml fuerte</span><br><span class="line"></span><br><span class="line"><span class="comment"># newer distributions (Groovy, Hydro, ...) must not be listed anymore, they are being fetched from the rosdistro index.yaml instead</span></span><br></pre></td></tr></table></figure><h4 id="修改脚本url为本地路径">2.3 修改脚本URL为本地路径</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/python2.7/dist-packages/rosdep2/</span><br><span class="line">sudo gedit gbpdistro_support.py</span><br><span class="line"><span class="comment"># 将 FUERTE_GBPDISTRO_URL 后面路径改为如下，并保存</span></span><br><span class="line">FUERTE_GBPDISTRO_URL = <span class="string">&#x27;file:///home/username/rosdistro/releases/fuerte.yaml&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/python2.7/dist-packages/rosdep2/</span><br><span class="line">sudo gedit rep3.py</span><br><span class="line"><span class="comment"># 将 REP3_TARGETS_URL 后面路径改为如下，并保存</span></span><br><span class="line">REP3_TARGETS_URL = <span class="string">&#x27;file:///home/username/rosdistro/releases/targets.yaml&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/python2.7/dist-packages/rosdistro/</span><br><span class="line">sudo gedit __init__.py</span><br><span class="line"><span class="comment"># 将 DEFAULT_INDEX_URL 后面路径改为如下，并保存</span></span><br><span class="line">DEFAULT_INDEX_URL = <span class="string">&#x27;file:///home/username/rosdistro/index-v4.yaml&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="启动更新命令">2.4 启动更新命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rosdep update</span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line">reading <span class="keyword">in</span> sources list data from /etc/ros/rosdep/sources.list.d</span><br><span class="line">Hit file:///home/silencht/rosdistro/rosdep/osx-homebrew.yaml</span><br><span class="line">Hit file:///home/silencht/rosdistro/rosdep/base.yaml</span><br><span class="line">Hit file:///home/silencht/rosdistro/rosdep/python.yaml</span><br><span class="line">Hit file:///home/silencht/rosdistro/rosdep/ruby.yaml</span><br><span class="line">Hit file:///home/silencht/rosdistro/releases/fuerte.yaml</span><br><span class="line">Query rosdistro index file:///home/silencht/rosdistro/index-v4.yaml</span><br><span class="line">Skip end-of-life distro <span class="string">&quot;ardent&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;bouncy&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;crystal&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;dashing&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;eloquent&quot;</span></span><br><span class="line">Add distro <span class="string">&quot;foxy&quot;</span></span><br><span class="line">Add distro <span class="string">&quot;galactic&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;groovy&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;hydro&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;indigo&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;jade&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;kinetic&quot;</span></span><br><span class="line">Skip end-of-life distro <span class="string">&quot;lunar&quot;</span></span><br><span class="line">Add distro <span class="string">&quot;melodic&quot;</span></span><br><span class="line">Add distro <span class="string">&quot;noetic&quot;</span></span><br><span class="line">Add distro <span class="string">&quot;rolling&quot;</span></span><br><span class="line">updated cache <span class="keyword">in</span> /home/silencht/.ros/rosdep/sources.cache</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ros-rosdep-update报错解决方法&quot;&gt;ROS rosdep
update报错解决方法&lt;/h2&gt;
&lt;h3 id=&quot;一问题描述&quot;&gt;一、问题描述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;操作系统&lt;/strong&gt;：Ubuntu18.04
&lt;strong&gt;ROS版本&lt;
      
    
    </summary>
    
      <category term="robot" scheme="https://silencht.github.io/categories/robot/"/>
    
      <category term="ros" scheme="https://silencht.github.io/categories/robot/ros/"/>
    
    
  </entry>
  
  <entry>
    <title>init-ubuntu</title>
    <link href="https://silencht.github.io/wiki/cs/system/Unix&amp;Linux/init-ubuntu/"/>
    <id>https://silencht.github.io/wiki/cs/system/Unix&amp;Linux/init-ubuntu/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装常用软件">1、安装常用软件</h3><ul><li><p>搜狗输入法（<ahref="https://pinyin.sogou.com/linux/">搜狗输入法官网</a>）</p><p>注：搜狗输入法不支持Nvidia开发板的ARM64架构，所以输入法参见<ahref="./nvidia_jetson_agx_xavier.md">nvidia_jetson_agx_xavier文件</a></p></li><li><p>typora（<a href="https://www.typora.io/">typora官网</a>）</p><p>注：typora不支持ARM64架构。所以Markdown阅读器参见<ahref="./nvidia_jetson_agx_xavier.md">nvidia_jetson_agx_xavier文件</a></p></li><li><p>visual studio code（<ahref="https://code.visualstudio.com/">visual studio code官网</a>）</p><p>注：英伟达板子应该下载Linux，Arm64版本的</p></li><li><p>chrome（<ahref="https://www.google.com/chrome/">谷歌浏览器官网</a>）</p><p>注：英伟达板子自带chromium</p></li></ul><h3 id="换源">2、换源</h3><ul><li>普通电脑换源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先备份源列表</span></span><br><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list_backup</span><br><span class="line"><span class="comment"># 打开sources.list文件</span></span><br><span class="line">sudo gedit /etc/apt/sources.list</span><br><span class="line"><span class="comment">#编辑/etc/apt/sources.list文件, 删除原文内容，复制添加下列镜像源</span></span><br><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"><span class="comment">#更新软件列表</span></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><ul><li>NVIDIA Jetson AGX Xavier开发板ARM架构CPU系统换源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb [<span class="built_in">arch</span>=arm64] https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span></span><br><span class="line">deb [<span class="built_in">arch</span>=arm64] https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb [<span class="built_in">arch</span>=arm64] https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb [<span class="built_in">arch</span>=arm64] https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>一定要指明架构：[arch=arm64] ，不然 apt-get update 会陷入amd等架构目录的获取。</p><h3 id="安装基础工具">3、安装基础工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装C/C++等软件依赖</span></span><br><span class="line">sudo apt-get install build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装vim</span></span><br><span class="line">sudo apt install vim</span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">vim <span class="comment">#进入后输入:q按回车退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#安装git</span></span><br><span class="line">sudo apt install git-all</span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装miniconda</span></span><br><span class="line"><span class="comment">#下载网址https://docs.conda.io/en/latest/miniconda.html ，根据系统和版本自行选择</span></span><br><span class="line"><span class="comment">#下载好一个后缀为*.sh文件，添加权限并运行，输入命令（无权限的话，加上sudo提升权限）</span></span><br><span class="line"><span class="built_in">chmod</span> 777 *.sh <span class="comment">#*为你刚下载的路径+文件名</span></span><br><span class="line">bash *.sh</span><br><span class="line"><span class="comment">#根据脚本提示输入enter、yes等回答</span></span><br><span class="line"><span class="comment">#测试是否安装成功，若有conda信息说明成功</span></span><br><span class="line">conda</span><br><span class="line"><span class="comment">#若显示conda命令不存在，先重启环境变量，然后继续测试conda命令</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">conda</span><br><span class="line"><span class="comment">#若还是显示conda命令不存在，则自行修改环境变量，具体方法使用搜索引擎.</span></span><br><span class="line"><span class="comment">#conda使用教程见 ./SilenchtNote/Conda/Conda.md</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载密码管理器enpass</span></span><br><span class="line"><span class="comment"># For Ubuntu and Debian based systems，To install Enpass, add a new repository to /etc/apt/sources.list:</span></span><br><span class="line">sudo -i</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://apt.enpass.io/ stable main&quot;</span> &gt;  /etc/apt/sources.list.d/enpass.list</span><br><span class="line"><span class="comment"># And import key that is used to sign the release:</span></span><br><span class="line">wget -O - https://apt.enpass.io/keys/enpass-linux.key | apt-key add -</span><br><span class="line"><span class="comment"># After that, you can install Enpass as any other software package:</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install enpass</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># Seclect WebDav and input URL: https://dav.jianguoyun.com/dav/</span></span><br><span class="line"><span class="comment"># input username and password</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装常用软件&quot;&gt;1、安装常用软件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;搜狗输入法（&lt;a
href=&quot;https://pinyin.sogou.com/linux/&quot;&gt;搜狗输入法官网&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;注：搜狗输入法不支持Nvidia开发板的ARM64架构，所以
      
    
    </summary>
    
      <category term="cs" scheme="https://silencht.github.io/categories/cs/"/>
    
      <category term="system" scheme="https://silencht.github.io/categories/cs/system/"/>
    
      <category term="Unix&amp;Linux" scheme="https://silencht.github.io/categories/cs/system/Unix-Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>gtk2-symbols-debug</title>
    <link href="https://silencht.github.io/wiki/cs/system/bug/gtk2-symbols-debug/"/>
    <id>https://silencht.github.io/wiki/cs/system/bug/gtk2-symbols-debug/</id>
    <published>2023-11-29T02:08:16.537Z</published>
    <updated>2023-11-29T02:08:16.537Z</updated>
    
    <content type="html"><![CDATA[<h2id="gtk-2.x-symbols-detected.-using-gtk-2.x-and-gtk-3-in-the-same-process-is-not-supported">GTK+2.x symbols detected. Using GTK+ 2.x and GTK+ 3 in the same process isnot supported</h2><h3 id="环境描述">1、环境描述</h3><ul><li>操作系统：ubuntu18.04.5 LTS （AMD64）</li><li>相关软件：ORB-SLAM2、ROS-melodic（OpenCV：3.2.0installed）、OpenCV：3.4.15（手动编译，编译时CMake添加参数：-DWITH_GTK_2_X=ON）</li><li>ROS使用包（与错误相关）：opencv_bridge、image_geometry</li><li>编译指令：catkin_make</li><li>注：实际这里的orbslam2是经过修改且加了很多其他功能的</li></ul><h3 id="命令行错误信息">2、命令行错误信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: warning: libopencv_calib3d.so.3.2, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_calib3d.so.3.4</span><br><span class="line">/usr/bin/ld: warning: libopencv_features2d.so.3.2, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_features2d.so.3.4</span><br><span class="line">/usr/bin/ld: warning: libopencv_highgui.so.3.2, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_highgui.so.3.4</span><br><span class="line">/usr/bin/ld: warning: libopencv_core.so.3.2, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_core.so.3.4</span><br><span class="line">/usr/bin/ld: warning: libopencv_ml.so.3.4, needed by /home/silencht/slam-nav-add/src/semantic_slam_nav_ros/lib/libslam_semantic_nav_ros.so, may conflict with libopencv_ml.so.3.2</span><br><span class="line">/usr/bin/ld: warning: libopencv_imgcodecs.so.3.2, needed by /usr/lib/x86_64-linux-gnu/libopencv_highgui.so.3.2.0, may conflict with libopencv_imgcodecs.so.3.4</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Display:1072): Gtk-ERROR **: 18:03:31.545: GTK+ 2.x symbols detected. Using GTK+ 2.x and GTK+ 3 <span class="keyword">in</span> the same process is not supported</span><br></pre></td></tr></table></figure><h3 id="排查过程">3、排查过程</h3><p>该问题陆续困扰我很久，简要说一下正确解决路线：</p><h4 id="stackoverflow相关问题">3.1、<ahref="https://stackoverflow.com/questions/42534129/">stackoverflow相关问题</a></h4><p>通过回答可得知，程序中有多个库用了不同版本的GTK库，因此造成了冲突。因此，首先要排查到底是哪些库的使用与GTK相关。</p><p>回答介绍了<strong>一个查看动态库依赖的命令</strong>：<code>ldd</code>（list dynamic dependencies）</p><p><strong>作用</strong>：列出程序或动态库的依赖关系。</p><p><ahref="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html"><strong>例如</strong></a>查看 test 程序运行所依赖的库:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/opt/app/todeav1/test<span class="variable">$ldd</span> <span class="built_in">test</span></span><br><span class="line">libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)</span><br><span class="line">libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003996400000)</span><br><span class="line">libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00000039a5600000)</span><br><span class="line">libc.so.6 =&gt; not found</span><br><span class="line"><span class="comment">#第一列：程序需要依赖什么库</span></span><br><span class="line"><span class="comment">#第二列: 程序所需库在系统中的路径位置</span></span><br><span class="line"><span class="comment">#第三列：即括号中的数，为库加载的开始地址</span></span><br><span class="line"><span class="comment">#如果需要某个库，但程序在系统找不到对应的库，会出现第5行的not found信息</span></span><br></pre></td></tr></table></figure><h4 id="利用ldd命令排查">3.2、利用ldd命令排查</h4><h5 id="gtk库">1、GTK库</h5><p>通过查阅<a href="https://www.gtk.org/">GTK官网</a>得知，GTK是一款跨平台的为创造图形化用户界面而设计的工具库。</p><blockquote><p>Offering a complete set of UI elements, GTK is suitable for projectsranging from small one-off tools to complete application suites.</p></blockquote><h5 id="使用ldd命令排查库依赖">2、使用ldd命令排查库依赖</h5><p>orbslam本身用的库：</p><p>orbslam2/lib/liborbslam2.so</p><p>orbslam2/Thirdparty/DBoW2/lib/libDBoW2.so</p><p>orbslam2/Thirdparty/g2o/lib/libg2o.so</p><p>opencv库</p><p>pangolin、eigen3等orbslam所需的库</p><p>ros功能包的相关库等。</p><p><strong>首先</strong>通过使用<code>ldd liborbslam2.so | grep gtk</code>命令发现liborbslam2.so 确实链接了gtk2和gtk3两个版本的库，输出类似如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libgtk-x11-2.0.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgtk-x11-2.0.so.0（0x00*）</span><br><span class="line">libgtk-3.so.0 =&gt; /usr/lib/x86_64-linux-gnu/libgtk-3.so.0（0x00*）</span><br></pre></td></tr></table></figure><p><strong>缩小排查范围，分析</strong>：因为GTK是UI工具库，因此较大可能是因为涉及到绘制界面、图形等相关的库依赖出现问题。因此初步推断是opencv、pangolin等库依赖出现问题。</p><p>简单排查pangolin库发现没有出现问题。</p><p>通过查看orbslam源码中system.h、viewer.h、mapdrawer.h等文件，发现引用了opencv_highgui.h等绘制ui的相关头文件。</p><p>定位liborbslam2.so依赖的opencv库，使用命令<code>ldd liborbslam2.so | grep opencv</code>，输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">silencht@silencht:~/slam_ws/src/orbslam2/lib$ ldd libslam_semantic_nav_ros.so | grep libopencv</span><br><span class="line">libopencv_calib3d.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_calib3d.so.3.2 (0x00007fce94e1c000)</span><br><span class="line">libopencv_core.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_core.so.3.2 (0x00007fce949e1000)</span><br><span class="line">libopencv_features2d.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_features2d.so.3.2 (0x00007fce9472c000)</span><br><span class="line">libopencv_highgui.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_highgui.so.3.2 (0x00007fce94520000)</span><br><span class="line">libopencv_imgproc.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_imgproc.so.3.2 (0x00007fce93fcf000)</span><br><span class="line">libopencv_video.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_video.so.3.2 (0x00007fce93d6c000)</span><br><span class="line">libopencv_text.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_text.so.3.2 (0x00007fce93a4d000)</span><br><span class="line">libopencv_core.so.3.4 =&gt; /usr/local/lib/libopencv_core.so.3.4 (0x00007fce8fef8000)</span><br><span class="line">libopencv_imgcodecs.so.3.4 =&gt; /usr/local/lib/libopencv_imgcodecs.so.3.4 (0x00007fce8fa9f000)</span><br><span class="line">libopencv_ml.so.3.4 =&gt; /usr/local/lib/libopencv_ml.so.3.4 (0x00007fce8f3e6000)</span><br><span class="line">libopencv_flann.so.3.4 =&gt; /usr/local/lib/libopencv_flann.so.3.4 (0x00007fce8d785000)</span><br><span class="line">libopencv_flann.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_flann.so.3.2 (0x00007fce8c287000)</span><br><span class="line">libopencv_imgcodecs.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_imgcodecs.so.3.2 (0x00007fce8a13f000)</span><br><span class="line">libopencv_ml.so.3.2 =&gt; /usr/lib/x86_64-linux-gnu/libopencv_ml.so.3.2 (0x00007fce896df000)</span><br><span class="line">libopencv_imgproc.so.3.4 =&gt; /usr/local/lib/libopencv_imgproc.so.3.4 (0x00007fce82950000)</span><br></pre></td></tr></table></figure><p>发现一个问题，由于ROS系统安装的时候自带了OpenCV 3.2.0（lib文件安装位置位于 /usr/lib/x86_64-linux-gnu/），而我自用的OpenCV3.4.15（安装在/usr/local/lib/）。<strong>在编译链接orbslam工程的时候，由于不恰当的配置造成了一部分文件引用了OpenCV3.2.0，而一部分文件引用了OpenCV 3.4.15</strong> 。</p><p>那么查看3.2.0版本的 libopencv_highgui.so依赖（实际上为了稳妥起见，我将所有依赖的OpenCV库文件都排查过一遍），</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/x86_64-linux-gnu/</span><br><span class="line">ldd libopencv_highgui.so.3.2 | grep gtk</span><br></pre></td></tr></table></figure><p>从输出可发现，确实是3.2.0的libopencv_highgui.so文件依赖了gtk3版本库，而其他文件均依赖gtk2版本库。在绘制界面时，gtk2和3版本同时调用，产生了冲突。</p><p>问题转到：<strong>查找ROS自带 OpenCV 库与 自行安装 OpenCV冲突问题</strong>。</p><p><ahref="https://blog.csdn.net/qq_34570910/article/details/78245795">单纯</a>修改/opt/ros/kinetic/share/cv_bridge/cmake下*Config.cmake文件版本库，或者更改CmakeLists.txt中的find_package() 并不能完全解决问题。</p><p>经排查，是编译orbslam工程的CmakeLists.txt中使用的ros功能包opencv_bridge 和 image_geometry 的库依赖了OpenCV 3.2.0</p><hr /><h3 id="解决办法">4、解决办法</h3><p>懒得详细写了。俩方法：</p><h4 id="单独卸载这俩ros功能包">4.1、单独卸载这俩ROS功能包</h4><p>去github下载相应的包，放到ros工作空间的src文件夹下，配置他们的CmakeLists.txt文件中相应的编译路径，使他们编译的时候使用自己安装的OpenCV 3.4.15 库。</p><h4id="直接卸载ros自带的opencv我使用的">4.2、直接卸载ros自带的OpenCV（<ahref="https://luyanan.com/news/info/20091648620111">我使用的</a>）</h4><p><strong>简述</strong>：</p><p>卸载该 OpenCV（即3.2.0版本） 会使得所有依赖此OpenCV的ROS功能包全部卸载。卸载完成后，去github下载工程所需要的缺失的功能包（opencv_bridge和image_geometry），放到ros工作空间的src文件夹下，配置他们的CmakeLists.txt文件，使他们编译的时候使用自己安装的OpenCV 库。</p><p><strong>步骤</strong>：</p><h5id="使用-dpkg---get-selections-grep-opencv-指令查找所有opencv相关包">1、使用<code>dpkg --get-selections | grep opencv</code>指令查找所有opencv相关包</h5><p>输出可能如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">libopencv-calib3d-dev:amd64install</span><br><span class="line">libopencv-calib3d3.2:amd64install</span><br><span class="line">libopencv-contrib-dev:amd64install</span><br><span class="line">libopencv-contrib3.2:amd64install</span><br><span class="line">libopencv-core-dev:amd64install</span><br><span class="line">libopencv-core3.2:amd64install</span><br><span class="line">libopencv-devinstall</span><br><span class="line">libopencv-features2d-dev:amd64install</span><br><span class="line">libopencv-features2d3.2:amd64install</span><br><span class="line">libopencv-flann-dev:amd64install</span><br><span class="line">libopencv-flann3.2:amd64install</span><br><span class="line">libopencv-highgui-dev:amd64install</span><br><span class="line">libopencv-highgui3.2:amd64install</span><br><span class="line">libopencv-imgcodecs-dev:amd64install</span><br><span class="line">libopencv-imgcodecs3.2:amd64install</span><br><span class="line">libopencv-imgproc-dev:amd64install</span><br><span class="line">libopencv-imgproc3.2:amd64install</span><br><span class="line">libopencv-ml-dev:amd64install</span><br><span class="line">libopencv-ml3.2:amd64install</span><br><span class="line">libopencv-objdetect-dev:amd64install</span><br><span class="line">libopencv-objdetect3.2:amd64install</span><br><span class="line">libopencv-photo-dev:amd64install</span><br><span class="line">libopencv-photo3.2:amd64install</span><br><span class="line">libopencv-shape-dev:amd64install</span><br><span class="line">libopencv-shape3.2:amd64install</span><br><span class="line">libopencv-stitching-dev:amd64install</span><br><span class="line">libopencv-stitching3.2:amd64install</span><br><span class="line">libopencv-superres-dev:amd64install</span><br><span class="line">libopencv-superres3.2:amd64install</span><br><span class="line">libopencv-ts-dev:amd64install</span><br><span class="line">libopencv-video-dev:amd64install</span><br><span class="line">libopencv-video3.2:amd64install</span><br><span class="line">libopencv-videoio-dev:amd64install</span><br><span class="line">libopencv-videoio3.2:amd64install</span><br><span class="line">libopencv-videostab-dev:amd64install</span><br><span class="line">libopencv-videostab3.2:amd64install</span><br><span class="line">libopencv-viz-dev:amd64install</span><br><span class="line">libopencv-viz3.2:amd64install</span><br><span class="line">libopencv3.2-javainstall</span><br><span class="line">libopencv3.2-jniinstall</span><br><span class="line">python-opencvinstall</span><br><span class="line">ros-melodic-vision-opencvinstall</span><br></pre></td></tr></table></figure><h5 id="从输出中看到-libopencv-core3.2amd64-install">2、从输出中看到libopencv-core3.2:amd64 install</h5><p>使用命令 <code>sudo apt-get remove libopencv-core3.2</code>卸载opencv3.2.0，注意不要添加 purge 参数</p><h5id="输完指令后会出现如下类似输出">3、输完指令后会出现如下类似输出</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">下列软件包将被【卸载】：</span><br><span class="line">  libopencv-dev ros-melodic-camera-calibration ros-melodic-compressed-depth-image-transport</span><br><span class="line">…………………………………………略</span><br><span class="line"> 升级了 0 个软件包，新安装了 0 个软件包，要卸载 29 个软件包，有 204 个软件包未被升级。</span><br><span class="line">解压缩后将会空出 23.7 MB 的空间。</span><br><span class="line">您希望继续执行吗？ [Y/n]</span><br></pre></td></tr></table></figure><p>仔细检查上述要卸载的软件包，若没问题输入Y，然后点回车。ROS里依赖OpenCV的包全都会被卸载。</p><p>卸载完成后，新开一个终端，输入<code>roscore</code>，若成功运行，则基本无问题。</p><h5 id="下载ros对应功能包">4、下载ros对应功能包</h5><p>网址：https://github.com/ros-perception/vision_opencv</p><p>将 opencv_bridge 和 image_geometry，放到ros工作空间的src文件夹下。</p><p>使用<code>pkg-config --modversion opencv</code> 查看当前 OpenCV版本，输出3.4.15则无问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pkg-config --modversion opencv</span><br><span class="line">3.4.15</span><br></pre></td></tr></table></figure><h3 id="后续">5、后续</h3><p>删除ROS工作空间之前的build和devel文件，重新编译（catkin_make）整个工程。</p><h3 id="附">6、附</h3><p>一些相关问题网页链接：<ahref="https://www.cnblogs.com/cv-pr/p/5366764.html">1</a> <ahref="https://github.com/raulmur/ORB_SLAM2/issues/118">2</a> <ahref="https://github.com/raulmur/ORB_SLAM2/issues/103">3</a> <ahref="https://blog.csdn.net/hansry/article/details/76764491">4</a> <ahref="https://blog.csdn.net/bigdog_1027/article/details/79092263">5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2
id=&quot;gtk-2.x-symbols-detected.-using-gtk-2.x-and-gtk-3-in-the-same-process-is-not-supported&quot;&gt;GTK+
2.x symbols detected. Using GTK+ 2.x an
      
    
    </summary>
    
      <category term="cs" scheme="https://silencht.github.io/categories/cs/"/>
    
      <category term="system" scheme="https://silencht.github.io/categories/cs/system/"/>
    
      <category term="bug" scheme="https://silencht.github.io/categories/cs/system/bug/"/>
    
    
  </entry>
  
</feed>
